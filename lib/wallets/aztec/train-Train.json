{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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Ui0CAAAtCjAcBCosHAsAKh0LHBwKLgsAJwIdAEgnAiEEKy0IACstCgUsLQodLQAIACEAJQAAGlItAgAALQosHgQqCx4dACocHQsnAhwAaCcCHgQrLQgAKy0KBSwtChwtAAgAHgAlAAAaUi0CAAAtCiwdBCoKHRwAKgscChwKKgsAJwIcAHAnAh4EIS0IACEtCgUiLQocIwAIAB4AJQAAGlItAgAALQoiHQQqCx0FACoKBQstCAEFJwIKBBgACAEKAScDBQQBACIFAgotCgocLQ4LHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcLQ4FCRwKHwUAHAoSCgAcChYLABwKGBIAHAoaFgAcChsYABwKERoAHAoOEQAcCgQOAC0IAQQnAhsEDAAIARsBJwMEBAEAIgQCGy0KGxwtDgYcACIcAhwtDgUcACIcAhwtDiAcACIcAhwtDgocACIcAhwtDgscACIcAhwtDhIcACIcAhwtDhYcACIcAhwtDhgcACIcAhwtDhocACIcAhwtDhEcACIcAhwtDg4cHAoZBQAcCggGABwKDAgAHAoTCgAcChQLABwKFQwAHAoPDgAcCgMPAC0IAQMnAhEEDAAIAREBJwMDBAEAIgMCES0KERItDgcSACISAhItDgUSACISAhItDhASACISAhItDgYSACISAhItDggSACISAhItDgoSACISAhItDgsSACISAhItDgwSACISAhItDg4SACISAhItDg8SACISAhIuDIBKABIuCIBFABcjAAANqw0iABeATgAFJAIABQAAEg4jAAANwC0LCQQtCwQFACIFAgUtDgUELQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkrAgAHAAAA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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3djjS9cqV3L/tYB8n4JedWDGMgj2VDgCAZGo1PhLl3VwbJWHy7d7HZVfUZMGAdqJ/v3d2xMpkZK5NkJPmff/vf/+l/+x//53/953/9P/7tv//tv/wv//m3/+3f//lf/uWf/8//+i//9t/+8T/++d/+9fGv//m36/5/helv/6X8w+Mnj58yfur4aeOnj591/Gz9p1zjZxk/RzwZ8WTEkxFPRjwZ8WTEkxFPRzwd8XTE0xFPRzwd8XTE0xFPRzwd8WzEsxHPRjwb8WzEsxHPRjwb8WzEsxHPRzwf8XzE8xHPRzwf8XzE8xHPRzwf8eqIV0e8OuLVEa+OeHXEqyNeHfHqiFdHvDbitRGvjXhtxGuPeHr/1PHTxk8fP+v42eInXdf4WcZPGj95/JTxU8fPRzy7f/r4WcfP1n+Wa/ws4+cjXrt/3sfHN8gEnWATfEKdcJ+1P4CuCWUCTbgj1xtkgk64I5cbfEKd8IhMtwRfE8oEmsATZIJOsAk+oU6YkWVGlhlZZmSZkWVGlhlZZmSZkWVGlhlZZ2SdkXVG1hlZZ2SdkXVGvnOJ7ot5J1OHNuBOpw5lAk3gCTJBJ9iEGdlmZJuRfUb2GdlnZJ+RfUb2GdlnZJ+RfUb2GbnOyHVGrjNynZHrjFxn5Doj1xm5zsh1Rm4zcpuR24zcZuQ2I7cZuc3IbUZuM3Ibkfm6JpQJNIEnyASdYBN8Qp0wI5cZuczIZUYuM3KZkcuMXGbkOwep3lAntAF3DnYoE2gCT5AJOsEmzMg0I9OMzDPynYPMN9AEniATdIJN8Al1Qhtw52CHGVlmZJmRZUa+c5DtBpvgE+qENuDOwQ5lAk3gCTJhRtYZWWdknZHvHJTrAXcOdigTaAJPkAk6wSb4hDphRvYZ2Wdkn5F9RvYZ2Wdkn5F9RvYZ2WfkOiPXGbnOyHVGrjNynZHrjFxn5Doj1xm5zchtRm4zcpuR24zcZuQ2I7cZuc3IbUSW65pQJtAEniATdIJN8Al1woxcZuQyI5cZuczIZUYuM3KZkcuMXGbkMiPTjEwzMs3INCPTjEwzMs3INCPTjEwzMs/IPCPzjMwzMs/IPCPzjMwzMs/IPCPLjCwzsszIMiPLjCwzsszIMiPLjCwzss7IOiPrjKwzss7IOiPrjKwzss7IMwdl5qDMHJTIQbqBJ8gEnWATfEKd0AZEDgaUCTOyz8g+I/uM7DOyz8g+I/uMXGfkOiPXGbnOyHVGrjNynZHrjFxn5Dojtxm5zchtRm4zcpuR24zcZuQ2I7cZuY3Iel0TygSawBNkgk6wCT6hTpiRy4xcZuQyI5cZuczIZUYuM3KZkcuMXGZkmpFpRqYZmWZkmpFpRqYZmWZkmpFpRuYZmWdknpF5RuYZmWdknpF5RuYZmWdkmZFlRpYZWWZkmZFlRpYZWWZkmZFlRtYZWWdknZF1RtYZWWdknZF1RtYZWWdkm5FtRp45qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagRg4+Xg80cjCgTKAJPEEm6ASb4BPqhBHZrmtCmUAT7l5guUEm6ASb4BPqhDbgzsEOZQJNmJHLjFxm5DIj3zmodEOd0AbcOdihTKAJPEEm6ASbMCPTjEwzMs/Idw6q3kATeMId2W/QCTbBJ9QJbcCdgx3KBJrAE2ZkmZFlRpYZ+c5Bu25oA+4c7FAm0ASeIBN0gk3wCTOyzsg2I9uMfOeg3VfnzsEOMkEn2ASfUCe0AXcOdigTZmSfkX1G9hnZZ2SfkX1G9hm5zsh1Rq4zcp2R64xcZ+Q6I9cZuc7IdUZuM3KbkduM3GbkNiO3GbnNyG1GbjNyG5H9uiaUCTSBJ8gEnWATfEKdMCOXGbnMyGVGLjNymZHLjFxm5DIjlxm5zMg0I9OMTDMyzcg0I9OMTDMyzcg0I9OMzDMyz8g8I/OMzDMyz8g8I/OMzDMyz8gyI8uMLDOyzMgyI8uMLDOyzMgyI8uMrDOyzsg6I+uMrDOyzsiRg3yDT6gT2oDIwYAygSbwBJmgE2Zkm5FtRrYZ2Wdkn5F9RvYZ2Wdkn5F9RvYZ2Wdkn5HrjFxn5Doj1xm5zsh1Rq4zcp2R64xcZ+Q2I7cZuc3IbUZuM3KbkduM3GbkNiO3Eble14QygSbwBJmgE2yCT6gTZuQyI5cZuczIZUYuM3KZkcuMXGbkMiOXGZlmZJqRaUamGZlmZJqRaUamGZlmZJqReUbmGZlnZJ6ReUbmGZlnZJ6ReUbmGVlmZJmRZUaWGVlmZJmRZUaWGVlmZJmRdUbWGVlnZJ2RdUbWGXnmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYNt5mCbOdhmDraZg23mYJs52GYOtpmDbeZgmznYZg62mYNt5mCbOdhmDraZg23mYJs52GYOtpmDbeZgmznYIgftBp4gE3SCTfAJdUIbEDkYUCbMyDwj84zMM3LkoN/gE+qENiByMKBMoAk8QSbohBlZZmSZkWVG1hlZZ2SdkXVG1hlZZ2SdkXVG1hlZZ2SbkW1GthnZZmSbkW1GthnZZmSbkW1G9hnZZ2SfkX1G9hnZZ2SfkX1G9hnZZ+Q6I9cZuc7IdUauM3KdkeuMXGfkOiPXGbnNyG1GbjNym5HbjHznoJcbbIJPeER2uaF1KNedhINKEiVxkiRpkiV5Uk1KjZIaJTVKapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKmReV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmedRLuQWxEmSpEmW5Ek1qU2KPO9UklLDU8NTw1PDU8NTw1PDU6OmRk2Nmho1NWpq1NSoqVFTo6ZGTY2WGi01Wmq01Gip0VKjpUZLjZYabWpEUdGgkkRJnCRJmmRJnlSTUqOkRkmNkholNUpqlNQoqVFSo6RGSQ1KDUoNSg1KDUoNSg1KDUoNSg1KDU4NTg1ODU4NTg1ODU4NTg1ODU4NSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTY3Icw+SJE2yJE+qSW1S5HmnkkRJqWGpYalhqWGpYalhqeGp4anhqeGp4anhqeGp4anhqeGpUVOjpkZNjZoaNTVqatTUqKlRU6OmRkuNlhotNVpqtNRoqdFSo6VGS402NaJwaVBJoiROkiRNsiRPqkmpUVKjpEZJjZIaJTVKapTUKKlRUqOkBqUGpQalBqUGpQalBqUGpcad57UEtUl3ng96aFQJoiROkiRNsiRPqklt0p3ng1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1PDUsNSw1LDUsNSw1LDUsNSw1LDUsNTw1PDU8NTw1PDU8NTw1PDU8NTo6ZGTY2aGjU1amrU1KipUVOjpkZNjZYaLTVaarTUaKnRUqOlRkuNlhptakRx1KCSREmcJEmaZEmeVJNSo6RGSY2SGiU1SmqU1CipUVKjpEZJDUoNSg1KDUoNSg1KDUoNSg1KDUoNTo3Mc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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EwAqGBMUHAoKEwIcChEKAgQqEy8RBCoKORMAKhETCi0IAREAAAECARwKEhMAJwISACAnAh4EPy0IAD8tCgtALQoSQQAIAB4AJQAAI9MtAgAALQpAGAQqOxgSACoTEhgnAhIAQCcCHgQ/LQgAPy0KC0AtChJBAAgAHgAlAAAj0y0CAAAtCkATBCo8ExIAKhgSExwKPhIAJwIYAEgnAh8EOy0IADstCgs8LQoYPQAIAB8AJQAAI9MtAgAALQo8HgQqEh4YACoTGBInAhMAaCcCHgQ7LQgAOy0KCzwtChM9AAgAHgAlAAAj0y0CAAAtCjwYBCoQGBMAKhITEBwKOhIAJwITAHAnAh4EHy0IAB8tCgsgLQoTIQAIAB4AJQAAI9MtAgAALQogGAQqEhgLACoQCxItCAELJwIQBBgACAEQAScDCwQBACILAhAtChATLQ4SEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATLQ4LERwKGgsAHAoXEAAcChkSABwKGxMAHAocFwAcCh0YABwKFRkAHAoUFQAcCgoUAC0IAQonAhoEDAAIARoBJwMKBAEAIgoCGi0KGhstDgwbACIbAhstDgsbACIbAhstDhYbACIbAhstDhAbACIbAhstDhIbACIbAhstDhMbACIbAhstDhcbACIbAhstDhgbACIbAhstDhkbACIbAhstDhUbACIbAhstDhQbHAoJCwAcCgcJAC0IAQcnAgwEDAAIAQwBJwMHBAEAIgcCDC0KDBAtDgYQACIQAhAtDgsQACIQAhAtDggQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAtDgkQACIQAhAuDIBKABAuCIBG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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+LM2oBIoVAIEQBAAF5AAF4BLblVZ5U2QZVuWRMmSSK22lqxcKJIQQRIAdxAfC0EQAElwAUmQ4iLJkixb3mS727Ll9nLa454+4+7p8Zxxt2d6utunt9OnN3e3Z47HPZ5BkPkyb958f8nKF4UkWXEOUD9/vLjvxYsXL17Ejx8/E7yVVp3/l2ldj7X+ym9Mcm93629+sFQwxMqvUuQcaf0dpbqNt/5OtP6uaP1d2fo72fqbBf10AWNaBXkjLWZjLSYTLfCVLdAsggHezmu7GY9AvsPb3fqdHywVJomvJf5cvlqfDLqTsfylSdCzL/0Ipgf8vBjaV8Ogy2YC4jvV+o32JmWcLV0cdK5PQhmXvgbYGcr7usJX8n421OVw6RuQN0Z534S8ccr7FuRNUN7PQd4Kyvs25K2kvJ+HvEnK+wXIy1LedyBP+qC09+qgk2fYH4qCP+UB/3xauEiRfwrq5tL7wqCdOnyb5UqpXqnO1hbm6gulWrk6VylXK9WZ+dlCoV7N1+fn8wvFWr5aac7NzM00moWFRqNQm68283Mz1ZJg/xjodMyuXnnB/3E/+G0/+BN+8IuC//5Q032psVDJl2aqs3MLhWZ1tplfKFfmStVmpVKv1ufLjcpMvl6ozRZqxUJzbq46M1OtzcwXCs3G/Exzblawf1LFbszN1eYXKs18s9qcL1bzxXxxoVZvzuRnz/NoNmozzWapPJ+fKc3Vq7V6pVaYr5Xmis1aY76Zn2+36wdU7Hpxptqs1esL5XxzvlSpVubO2858ZeE8wFyhNFuo1ubP21Sz0KjWKrWFaiN/nlejUK1XCvVKaUawPwg6t+sLHfwPecHv2MzNXvALbZv/sB/9LAj+R8JAadu5QvW8D6jXy4W5eq1eyjdKzfO9f65ars8W5px5luYW6qWZSuO80yjMVSvFmcbMbLV63k6rtUJbNz+lYjeKlXK5NF+olAuV2XpptlHPz9Wac/VSoVooLBTq9WbzvO9ZOG/4zdnK/Ox522zUGpXG3MLs+Q7QtsmPqtiDJcH+mIJdmCsVi5XSfCU/P1fPF8r1WnGuWHTGf14xtWJjvlyYb5aL5VKtft6JlueqBdfpavPNuW7sjw8udyFK7ltCH7bS8V+3+sEvC/4n/OC3beaTgJ8J7H3Bp/zgt+X/tB/8dvt+xo/+m4L/WS/yl9pj4E97kb/Uts+faeEHVtiFTt/9nDV2Pt8eAz8fjb1otybYX1Cwi9VSLX8+gqjOnB8aGnMz533++dCxsTDXaM4Wqwu1cr5YLxQKjfL5/4qNenl+4fywsjDbOD+MLJxn19bJF0Mf7VmoCX7VGH+2mp9vzM5WBH/BGH9hYbZSPa9Pwa8Z45dqs41mqdL2B3Vj/OpMudmcKVUFv2GMP1PIN2aKlbZtNo3x5xfyM7PnI2rBv80Y/3x8X6rPV9ux2Zes9bPQyNfqhXmZE97ewhceLgnvO4x5t9J8hvgFQff6SkD8sySrdRyfIX4oD+qH10fuDHtlzSl56GM4b1S5J3w0rAVDrJohVt0Qq2GI1TTEus0QS/q1375Wbo+jd3rBL80J/h4v+PmG4H/ZBz7EXncBfmAnfxt/L+BnPODf7Uf/bfx7/OinPW+6t4XvA3ufPXY7PtrvR+/t+O6AH/z2fOk+P/jt+Pd+P/htv/OAH/x5wX/QD347/n3ID347fnzYD347/n3ED377ueFBL/iFtn0+6ge/rf9DgG/n94ttvxz6wW/r/7AX/FJb/iN+8Nu+/6gX/HIb/5gf/Lb/f8wPftv/H/eD347bHveCP9Oe35/wgj/bbt8n/OC344eTfvDb68Wn/OC310NP+8Fv2/+TfvDb9v+UH/z2+PK0H/x2/HPGD347/nnGD357fHzWD347PnnOD357fHzeD37bf571g9/2ny94wa+0x/cX/eC3/edLfvDb/vOcH/y2/3zZD37bf77iB7/tP7/iB7/t3171g9/2b6/5wW/7t9f94Lf9zxst/MAMe6Ho9sK5PXZnN7+F5/aSrWlh39bY/6N79tbu/MiBLy807sXVeneNOxfx/mjQm1YHnV1q51Fvvf3LjX37q1++O6os3x+LwFzXwXzf3rv231ut7X9vvX5vY9++KIRMEJ8caraD+snGvftu33sXo40vDu19X6reftcH6ow2kRJN9hOuAHrDODsv+05XknzIG/cQG86h62meEyH/LMlqvCZRyBA/kYf1g8+JMkGntbFsTsnjNswqfLIKn5ySx3H5IFgvGmI9aYh11hDLso7PGWKdMcR63hDrKUOsQ4ZYlrq37EMvDSnWCUMsS5uw1L2lfZ0yxLLs25Y2cdIQy9JHv2KINazjo8x3JoPe+MD6ua7DXO0HvyS6WBWjC+QvsRLGVpmIv4LFecIrS1jGdSvE1Q3l53bG9wJRB1FYq/rEmlTyfLRpNqbezD+KXouXhX4qBh/pp4NeG54iXazxo4tiXLvhu13CfzXUud5YOHDbzXtvCyiNkh5Eb1uJTvZ6jAS9+l4dgRXQ7610bxTwMDm86dZ1s7G/9qVbq7fd1qifl34fUfYUldfM+D5Pi5DGswkXF+tKPLnhQho36ZKY/Gqg3bO3Wn9f9e59B/Y0RkiVOANmdSIcV5ubKgMi4T1ee8E3Cl2SN660dR/Ecfme34hsiLmtUWSQvGngvZLycpCXpby1gCUrcRmFz6hSd6mv4/fK5g4u07Gs2JbTlIeeMAe82SZWKXykbiMK/WrCihrJRlPw06IAXrGJW3VK04WlHi7lFB7cjkvvigqlt7sr8htBFtoj7GpFntWKfqQtp5Q8wRIfMB7oo/VqqCPSs/8Yp3srWg2WI0yX5C3FuOgG74l+3QpwJtNdN+2kCL/tUC6ktVPhnw28DuGFOLvQIma/40s5n6ZdUV4ej7jt0K+jnSL9FNSRx69pkGOc7m0gO0WbZjtdo9QH76GdTrdwJyPqs7v1Oz9QqlS4jwsP5O0n4i/U0vYD4Z8NfNpdpx9o7aT5Ey3WkbI5JY+fRkwrfKYVPjklj1dIBsE6a4h10hDrtCHWS0OKdcYQ63lDrKcMsQ4ZYj1riGVp98Oor7hxsF8slyxt9Zwh1tOGWJa2alnHE4ZYw9q3XzPEOmyIJTuOtHUPjpWw71nP3ZCf1APvIf8syWorTydW0vSqxbSin5wf/bTlySny5BT98HoTt537J/uecM6A9DmoI9LjtZTHe19oNViOMF3iOcNapT54D+cMn8l01w3bhu3UZzsgP5Eb7yH/bOCz3+Rj7ULr/5NBbzsb6iefpl1RXmnLdUqeYF3U+o12ivRroY5Ij9dSHu99mewUbZrtdJ1SH7yHdnob2Sm2Ddupl3YoNFPbqfDPBj77TcdONbvIKXqcDHrb2VA/+TTtivJKW16k5AnW+tZvtFOkXwd1RHq8lvJ472GyU7Rpfkv8IqU+eA/t9EALdzKiPrtbv/MDpZmy1pZ2+JXClFJP7meoazu7LqXuZ8I/G/TahY9+tp7kibID0d0GRdacksc2skHhs0Hhk1PyeF4zCNZpQ6xDhlgnDbGeNcQ6YYh1xhDrOUMsS5s4ZYj1uCHWS0ZYmn8eRK4XjeRy6ZwhlmXffs0Qy9IXWvbH5w2xLNvxdUMsS5uw1L1V3w6M62hpE2cNsYbVT1jK9W6ImZbHtAune8v++KQhlmUdvzKkclnGE5Z15OcDOLfMtP5OBr19z3Ce3cgQP6kH3kP+WZLVVp7OPFvT63pFr6K7jYqsOSWP59kbFT4bFT45JY/HjEGwThtiHTLEsqzjGUOs5w2xzhliWer+NUOs5XbsD+t1QyxLmzhliHXWEMvSf71kiGWpe0tbtdT9sPovS1u1tK/nDLEs29HSviz7kKV9vWiIdcIQy7KOwxrLWdbRMp4Y1nYc1ljuK4ZYwxrnWMaYy/HEO6MPWfoJS7ms7Mtd87rqIHK9bCSXS5a6t4wBZKzl/W6C75LfNbRi6j22vIbmZQ9WwhqatrduMui1Q0P9FNK0M8orbXmxkidYm1q/cU8Y0m+EOiI9Xkt5vLe3pZQcYb6ZF3bLcLFSH7wn+nV7wm5v/ZiMqM/u1u/8YGmO10OFB/JGPRnaXaqvSSH/bODT7jr9QGsnzb+I7jYpsuaCXtthe9ik8Nmk8FnGGi6sTxphxfkwyXdpUiln7W+Rn9QD7yH/bODVLxTi9Kr5S9HPJX70096jfIkizyWKfqQtNyt5grWl9RvHI6S/BOqI9Hgt5fHeczQebQZa7gOblfrgPRyPnhzprhu2Ddupn3ZI/86H8M8GPvtNx041u9D6/2TQ286G+smnaVeUV9pyi5InWHLaFNop0m+GOiI9Xkt5vPdVslO0abbTLUp98B7a6SutH9NBdP9M058RV/PbrEMsx/3BS3sXGvm0/UH4ZwOf/bPTHzan1KvoZ4sX/dSbaewH5ZW23KrkCdalrd/YH5B+C9QR6fFayuO971J/wL7D/WGrUh+8h/3hO+S3sW3YTr20Qz7fTGunwj8b+PSTHTvV7EIb/yaD3nY2lKeRpl1RXmnLS5U8wbqs9RvtFOm3Qh2RHq+lPN77PbJTtGl+V+9SpT54D+30t2i+y/XZ3fqdHyg1Clpb2uFX26ezXuoFvzg/qbSXHf7CnOBf7gd/VvCv8II/127fbV7wZ9r6udIPfl3wr/JjP235t3vBL5UEf4cX/EZb/qu94Jfb+Nd4wV9o999rveDPt+3/Oj/6abfvTi/4zRnB3+VHP235r/cjf9v/3wj4lmsRgp/3gt85KfqmoJNGlToJf4lFbgD6TMRfweI84ZUlLF9xn1Y3lJ/nfTeBPKiDKKyb+sSaVPJ8tOmNMfVG/lMxsnI9XOIzcBarE5dOGWIdN8R60QhLi20HkeuIoVxbjeTS4t9BsC4zxFphhOXSsdBOrsuN5HLXVwwp1jZDrCsNsa4yxNpuiLXDEOtqIyyX+MuOg8h1jaFcLxjKda2RXO76OkMsq7HDXe80xNpliHW9EZZLvHY6LFjyDNnveld53u96V6nqd72rXPe73jVT8rveVa74Xe8ql/2uR5VrMheQMVJ4oO3imGc3bymnftdU+GdJVlt5OvPH7SQP64f3B+1QZM0peewDdih8dih8ckoe7xUeBOsVQ6wThljPGmKdMcQ6ZYh1yBDrOUOs04ZYLw0plqWtPmWIZaV7LS4YFlu17I/nDLGGtT++bIhl2YeGVfdPG2JZ+gnLsdbSR1vq3lJfw2pflrGJZTta6v7d4CdeM8Jy1zxHHkSuY6GdXJcZyWWJ5dLR0E6uyw3lOhbaYT1uiGUll7veFthhrTDCcsnKJlw6boTlrq8IbLBcOhYOp1xWtjrMvnCtoVyW/uuKIZVrGPXlkqWtXhnYYLl0LLTDsvJfLr1uiGUZfz1piGW5pmAZk1vOFSzXHiW+l3XsbZCXaf31+wwgv+hnANv8yBP7DGCboldtP6yhPPU07YzySltereQJljyTHwcspN8BdUR6vJbyeO9/aTVcjjBd4ncHrlbqg/dEv+7dgf9ptLtu2DZsp37aIf03ZoV/NvDabwpxdrFd0aNmF1I2p+RxTJ+2vbS25711g2CdNcQ6aYh12hDrpSHFOmOI9bwh1lOGWIcMsV4wxLLsQ5bt+Ioh1glDrHOGWJZ929K+LPuQpV99N+j+OUMsSx8tvnA66I2HJoNuPv3OHbC80Pl9H2ym6Pd9sJlZv++DlZsSd10Les2Q7nCfpl2MOJf6PA3hnyVZbeXpxKw7SR7WD8esuxRZc0oe76/apfDZpfDJKXnsWwfBesUQ64Qh1rOGWGcMsU4ZYh0yxHrBEOtFQyxL3Q+rrZ4zxDptiGVpX5Y+56wh1rtB988ZYlnW8aUhxbLs208ZYlnp3l3z3slhsdVhjQEssZbH7eVx++0ydiyP28vj9vK4/c7U/bDa6suGWJb6svQ5lrp/2hDLsg9ZjtvD6qOHNZ6wrKNl7GvZjpa6fzf4ideMsNw176EYBGuHIZbVOrm7vtoIyyXeHzqIXGsN5ToW2mE9boh13AjLXfPzr2Xdx9eR97cPgnWZIdblRlguWerrOiO5LG3VJcs+NKx2P6x1fKf7Qku5XFoeO97+Y4dLjxlhuWvLPQ/HQju5rjSSy11fYYhlNda6ZDk+WunLpWOhHZal/3rdEMtyzvekIZblMx3LdQDL9QnL/Tn8DhLuDcu0/mpnhjs+u1u/8wOlYup3O4R/lmS1laezT07T605Fr6K76xVZc0reFXCNecjneoVPTsljex8E6yVDrJOGWGcNsV4xxDptiPXikMp1yhDrkCHWa4ZYhw2xXjfEstTX84ZYlv3xnCGWpd1b+kLLdnzSEMvS51jaxHOGWJa6PzGkcr1giGVpE5axieW4bdmOw+q/LO3Lsj8Oq4+2xLK0r6cMsUT3/F6P4Lukfb/JcK5XzhA/qQfeQ/5ZktVWns5cT9OrNocW3d2oyJpT8vgZtPaNoBsVPjklj33zIFhnDbFOGmKdNsR6aUixeFwcBOt5Q6ynDLEOGWK9YIh1whDLsj+eM8SytC9LfT1riGVpX5Z9yNKvWtqEpV8d1r5t2R8t+9ArhliW/fHdYF/PGWJZxgB8TgTG23xORL8xP5YXuimlXKb11+83VedTn4Mg/LOKTnzE/Dem1Gs/3+t015bfn+SxaRCsVwyxThhiPWuIdcYQy/JbqYcMsay+w+eS1XdXXbLU/bDa6jlDrNOGWJb2ZelzzhpivRt0/5whlmUdXxpSLMu+/ZQhlpXu3bXVd6NdsrTVYY0BLLGGddy21L1lDGDpoy3jiWG11eVx+8KNacsxeX9YyzH5hbOv5bjwwtnXMMaFLlnqa1ht9WVDLEt9WfocS90/bYhl2Ycsx45h9dHDOqZZ1tEy9rVsR0vdvxv8xGtGWO6a9zgNItdRQ7l2GMnlrtcaYlk+H7LU15WGcj0e2mEdN8Jy1/yu9DDYhEvHQjssK91b9m3r/mjVh9z11UZYLln2x3eDffE5LoNgXWaIdbkRlkuW+rrOSC5LX+iSpY8eVrsf1jq+08daS7lcWo5N3v5jh0uPGWFZxhMuHQvt5LKKyd31FYZYVmOtS5bjo5W+XDoW2mFZ+q/XDbEs1xSeNMSyfG5luc5kuf51yhCLz3HBva2Z1t/JoLe/OD67W7/zg6XU57gI/yzJaixPIU6v2j5t0U/ejzwLGcJHefKKfqQtC0qeYBVbv/Fb0kifhzoiPV5Lebz33ybe+psjTJf4W9IFpT54T/TrIP/jRHfdsG3YTv20Q6Ge1k6Ffzbw2m8KcXah9X/NLqRsTsnjNZy07aW1Pe9NGATrrCHWSUOs04ZYLw0p1hlDrOcNsZ4yxDpkiPWCIZZlH7Jsx1cMsU4YYp0zxLLs25b2ZSmXZTtaymXpJyxtwrIdnzPEsvT3/L4hxlb8vmFcfKrxwfJCN6WUk9hqMuiNUeziqbmZDPGTeuA95J9VdOIjviuk1KvorqjImlPyeO2qqPApKnxySh730UGwXjHEOmGI9awh1hlDrFOGWIcMsV4wxHrREMtS98Nqq+cMsU4bYlnal6Vclu1oKZelX7W0Cct2fM4Qy1L3Lw0plqWfeMoQy0r37prfXRwWWx3WeMISazkGWI4BfPrV5RhgOQZYjgGWY4AkLEt9DautvmyIZamvYfUTTxtiWfahYR07hjX2HVb7soyjLdvRUvfvBj/xmhGWu+Z9EINg7TDEslq/d9dXG2G5xO+yDCLXWkO5joV2WI8bYlnJZd2OVnK5dNwIy9omrNrRXV9qJJe7vswQ63IjLJcs9XWdkVzu+hojLJeG1VaPhXZY7/T+aF3HYbQvl5bHoWW757zHjLDcteUekWOhnVxXGsnlrq8wxLIat12yHGut9OXSsdAOy9IXvm6IZTkXfdIQy/K5leX6hOW6ieV+Jn6/aQXkZVp/ZV8h+nPHZ3frd36wlPrbZcI/S7Iay9PeV7g26NXrCkWvorstiqw5ynOJ3/PZovDZovBZKiytvd2/3a3f+YHSzMyUwpttDfc32LVtYS6trQn/bNDbtj5sbSvJE9VuortLFVlzSh634aUKn0sVPjklj5+zDoL1jCGWpVxnjbDc9erABsu6jocMsZ4zxHrJEOspQyxLfZ0zxHrVEOsFQ6zThliWuj9jiHXKEMuyjq8ZYh02xJK5B8cWLu1u/c3nm+VKqV6pztYW5uoLpVq5OlcpVyvVmfnZQqFezdfn5/MLxVq+WmnOzczNNJqFhUajUJuvNvNzM9Wy39hhpjIZ9Pp4w9ikIPiX+cEvCv7lfvBLgn+lH/x2++7wgz8j+Ff7wZ8V/Gv84M/5ff+rMC/4RT/4VcEv+cGvC37ZD35D8Gf84DcFf9YLfjEv+BU/+G3/NucHv+3f5v3gt/3bD/jBb/u3H/SD3/ZvP+QHv+3fftgPfnv8/RE/+G3/+R4/+G3/udsPftt/vtcP/oLg/6gf/Jrgv88Pftv//5gf/Lb//3E/+G3//xNe8Ett//9+P/ht//+TfvDb/v8DfvDb/v+DfvDb/vNDfvDb/vNmP/ht//ZhP/ht//YRP/ht//NTfvDb/uejfvDb/udjfvDb/ufjXvDLbf9wix/8tn+41Q9+2z98wg9+Oz78pB/8dnz4KT/4bf/2aT/4bf/2GT/47fjws37w2/7zp/3gt/3nz/jBb8eHn/OD3/bPn/eD3/bPX/CD3/bPX/SD3/bPVS/4M+34cMEPftv/1/zgt/1/3Q9+2/83/OC3/X/TD37b/9/mB7/t/78UdFIHu9RYqORLM9XZuYVCszrbzC+UK3OlarNSqVfr8+VGZSZfL9RmC7VioTk3V52ZqdZm5guFZmN+pjnX9v23q9iDpM66/B0+9FJotvvVnYCfMZN/ro2/xwt+vm2XX1Z135ibq80vVJr5ZrU5X6yeX2csLtTqzZn87Pn2bTZqM81mqTx/vvvM1au1eqVWmK+V5orNWmO+mZ9vY9/lRff1ts/cq8heLNdnF6r5SrNSrc41zw9wxfr5P7PnLbI5U6zOl2rV8zWoLzSq5x9VzRdr9WK91Jg7X5FGaX620eiMJ3erehkkldpj7T0qdr04U23W6vWFcr45X6pUK3Pn5ZyvLJxX7FyhNFuo1ubPP2drFhrVWqW2UG3kz7dBo1CtVwr1Smceeq8Xe+k8p9hn3qZzb/7vjkL+45VvYcm5fOPAayXVq3V0cvusZ5fuDjs045CP9BtbDzHd73/UAp2iMoLh0iSVt/WvhfkM8QsCfW+T8M8quvGxt2mC5GH98N6mFYqsOcpziZ91r1D4aPv1NKzXDbEOGWK9YIh12hDreUOsU4ZYZwyxLOv4lCHWsNrXCUOsFw2xzhliWdqXpb6eNcSytC/LPnTWEMvSJiz9aj/78TGOMRy3i2njCOG/VPvxVwbp9Or23a5qXe/ZW62/r3r3vgN7GiOkSgzDWJ0Ix9VGtWDeKN0bI7r3h92/PxT2lgsUbJcvTZ6l+7tbv/MDpdmGmNtdigyStxd4T1De3ZC3gvJwivJG2KHjNKrUXerr2uaVzR1cpmNZsS33Uh4eq3038GabWKnwkbqNKPSThLVSKSftlsTPcxcv+LWnfClDOonSi/CPc3dp3ZHwWip3pNUtzs2j3fEUVMOa7BNrUsnz0aZxbhj5T8XIqtWD/XHaaaPQZ2PkQvpphbeUFR1OQZ710BqlQ+yLwn810NYbCwduu3nvbQGlUdKD6G0T0cl4MxL02uBkBFZAvzfRvVHAwxS3DJKmP4ucLuUULFmeWQ6T2mk5TFoOk95tYZI2/PDqKq+6urS79Tc/UKoXJhWZOthzhWq5Olevlwtz9Vq9lG+UmrV8da56/rFCYc493CrNLdRLM5VGvVItzFUrxZnGzGy1ev4pV7VWKDp5P9BSljZk4aot2gB+sXBS0e040f9S7q2/jt+HWwWca2jdDhYO7Lnz4439997euK9xfvTZF1BK6s8fCbt//1TYW05Ly669nXy5djYh365dml7S29m1j1PeO8W1aw/KkA+7dqRfjGuP4jel3OPu72mmk7r784zT12w9Q/w0HbvUZ/fncztRnQjH1V5s97eI7PxMzPrv/tzFsfuvpLxBur/Ut9/uj23J3R9dKHd/bSKPfKRuIwp9lrCiFjxGF8FPohZ0FxzRCO1DLSDPbiK/DnC5DsvRSzstRy/L0cu7LXrR3Btvs/G5Roa8J4Perra79TefbxQr5XJpvlApFyqz9dJso56fqzXn6qVCtVBYKNTrzWa5WlkoNyrN2cr87ExprlFrVBpzC7PFQrOsubJMYPbKW8VNSs8OMAl2CbdyTUI+0j/WunD8zsEkWI5iuK+65/Z6dX/jx++650DjQKP+kb37G/vee1f9x+9r3LW/7ynxT4bdvz8Q9pbTkuFSRpFvCPYqkNtwEKiJta9W6iV5GNzhMg4nzdOI3M4Sf6MPT4M9dIry0KrXUB5a4TTloZfPUd6EIs9iezvqaEVEvSz4oI44uF1pyEd7IsH6tuAT9+TH0xPRBanHqqA3cd/AttX6Brf1Gsjj9pmGPNZpDmTYF3boOCWN7H+Sor+9m/Uro1MQLOvXQr+L0eHqLR1cpuN6YFutJlrcLJ6h8nwYp9RzTCnv0l1hN5bQ/8lkR+4dW7pl08YPjvBs2z79oZnCPxv0jk8+JpTaRjvUjzah3Ld/773V2xofb1TrKDrCXQz3MR+T0GBol1F+Z+j3COEcDHtxOIn68JpNNQgGHxaxHHffEUM+iMUP8ll/Lnl+byK1efN7E2Ne5Il/b2JM0avn7l+J627ak1ctfOZdBDgRi5twjwS9rh9DwXG69x9aFxxSusTuWZuwa8vpTvZ/M9ldN19hvLSvtjggfcXR/5fJ7rpIOdQnlhU/M070d8LE9y9poq3ZvuTx5iu8xv49qtyL8zts05762IymX0ncxiijNr2ShcCMgqWFJVInZ2vX9hGWoM65PcYUWdk2RJ4oP6K1h9BJe3h6V2xW61dcf35ehXnYbx8OO3SctPaQOvXbHqhzlk3z3YghNqO9nzhB5SYUWUX/jB3FmxfKAqiDtG2OsHe3fucHSoWC6AvPfJUkefgsBe2ck9Z+Irdrvy8sMsxfR3mo84soD9t6PeXhGLaB8nAM20h5OG27mPJwSW4T5eGU6xLKwynXZsrDKdcWysMpl5ylO0k4xjayoH0TICC58Fxf7HucNBsRufu1kRFFF9r0/lLKw3P3L6M8tPXLKe8iyLuC8tZD3jbK2wB5V1LeRsi7ivJwrrOd8jZB3g7KuwTyroZrbJvx1rXYitCILxpR8rSxajwhn20SE9qU9tAnQ7QZokVsngONRPBBHM0/o+1ivMbfmEAawdgK8o0H0b6fxyGkRz68RIVLguNBb7/juBfxWbe8BM3tjrpdS7QrIvho7Teu1BF1EvW+f5RO1hE9xhbaPoSJPuWZ7FOei4h+0liebJ/yrCf6rLE8q/qUZwPRrzKWZ3Wf8mwk+tXG8kwRfSZBnosj5I+SJ63vGgt0H83+PENyj9B9oV0TU68xhc8mose53Fig6ypNvTJB7zyJ65UhWpEzo2BPK+WYHvlcQvTamiLLEgR63McbPVCuEcrDWIcfW2obJbS4lteA0Lb5ZT/thacppX5Rjzaxr2uxMq+loI6jHmNif3VYcfPraUUeXhfB/WvanidelxH6u1vKcb9f3dKNqW0D1ebzQq+9GKe9GTAd9OqCx4aklx5xLQTLTwTxe/54Q8b9UP83WvWPW5/gtWXE1toQ7fTNuoS9mFJ+DPIs151d3b5Oj3dQl+PAN43u+2136dO5oLet+UVNbauB5p+0tUexCc2XSFlc05T2ukiRVXhiDDJK9MhT6DcAn1GFRsqOE/1JsMPvkR2iTLwOsAFkEXuVOfRGkn1363d+sJR636fwz5KsxvK0n2NsJHlYP33u++RwGNWJcFxtVAvmLcW+z010f3frd36g1P++T17Kwn2fvFw1yL5PqW+/+z6xLXnfJ4axvO8TbWKjwkfqNqLQX0xYG5Vy0m5J/EaVchcRRibodTlyf73Ce5zovw4u6ftbovWwPojWg/xeocjJ+pZ8l/za80wlrQsT/tmg1zZ8uLBNJA/rp08XxjNEgf8kwQkN0mL6JIiE9Dxj4Ga/TSnHSVTJq4GS55KYwyVUZnfrd36gVEg9ogn/bODTPDvmcAnJw/rhp5ieVs3b8mxW5Nms6IdX2bnt3D9Z7YtamdwMdUR6vJbyeO97Lbdl+RVjF839Wrabn/Stvw9Ptn+7dT0d9PY/XkXQ3PlGhXdOKS90Gp9VA/JZpfDRNsfKpjKeZWt5uFLAT5bWQDnepTMNeR+lPFxR5tn52hjMdQqma7vPr+7guX/XAp3mivnJ6naQB8vi73GidenesDtPaP8M7Oofkl3hMMTtfXGC3HHtzU8E0U64TbE/c5uin2D9a/1Re/LGbbotBvMqBdPp7ROru+lQ7zy2XAv3DUON2bRji/DPBr325GNs0ewb9cNjy04/+pnJED7Ks1PRj7TlLiVPsK5v/caxBel3Qh2RHq+lPN77tzS27AJaHlt2KfXBezi2/Hm2u27sP7S/gsv3uH+jbqKevLqEu77+Q7a7LlIO9YnjURPykf4VOPPjP8f4MG6/7VTHJN+7SaljWj9+C2Ftj5FrZwLWJwgLy+8krF0JWLcSFpbfRVjXJ2DtJywsfz1h3ZCAdYCwsPwNhHVjAtZ9hIXlbySsmxKw7icsLH8TYeUTsB4gLCyfJ6zbE7AeJCwsfzth3ZGA9RBhYfk7COvOBKyHCQvL8xci9iRgPUJYWJ6/BnFXAtYewsLydxHW3gSszxAWlt9LWHcnYN1MWFj+bsK6JwbLXcsunmmlvJTVlsfEz2tfTrgQ82HhnyVZbeXpxCz3Br16Rf3wk8Z9iqw5JY/nZvsUPvsUPhrWdkOsaw2xdhpi7TLEut4Q6wZDrBsNsW4yxMobYt1uiHWHIdadhlh7DLHuMsTaa4jF409c/OyuZadoXPws5dAH8XonzxuRHjGi4nN8THFtgsyXk8yLjdPd9ZWEtdg43V3vIKzFxunu+mrCGiROlx0fg8bp7voakmuxcbq7LhDWYuN0d10krEHi9EfDbqxB4vQvEtZi43R3XQq6sRYbp7vrMmEtNk531zOEtdg43V3PEtZi43R3XSGsuDj93gSsOcLC8vzVsn0JWPOEheX3Edb+BKwfICwsv5+wDiRg/SBhYfkDhHVfAtYPERaWv4+w7k/A+mHCwvL3E9YDCVg/QlhY/gHCejAB6z2EheUfJKyHErB2ExaWf4iwHk7Aei9hYfmHCeuRBKwfJSws/whhHUzAeh9hYfmDhPVoAtaPERaWf5SwDiVg/ThhYflDhBUmYP0EYWH5kLAOJ2C9n7Cw/GHCOpKA9ZOEheWPENbRBKwPEBaWP0pYx2KwXPrpsBsLyx8jrMcSsD5IWFj+McI6HsTX8YNBNxaWP05YjydgfYiwsPzjhHUiBsulO8NuLCx/grCeSJDrZpILyz9BWCcTsD5MWFj+JGGdisFy6cNhNxaWP0VYpxPk+gjJheVPE9aTCVg/RVhY/knCeioB66OEheWfIqynE7A+RlhY/mnCOhOD5dIdYTcWlj9DWM8kyPVxkgvLP0NYzyZg3UJYWP5ZwnouAetWwsLyzxHW8wlYnyAsLP88YZ1NwPokYWH5s4T1QgLWpwgLy79AWC8mYH2asLD8i4T1UgLWZwgLy79EWOcSsD5LWFj+HGG9nID104SF5V8mrFcSsH6GsLD8K4T1lQSszxEWlv8KYb2agPV5wsLyrxLWawlYXyAsLP8aYb2egPVFwsLyrxPWGwlYVcLC8m8Q1lcTsBYIC8t/lbC+loBVIyws/zXC+noCVp2wsLyUnVKwMq2/8szoZ+G+3TOaciFD/KQeeA/5Z0lWW3k6z4x+NujVK+qHnxl9Q5E1p+TxmuM3FD7fUPhoWDsNsXYZYl1viHWDIdaNhlg3GWLlDbFuN8S6wxDrTkOsPYZYdxli7TXEutsQ615DrH2GWPsNsQ4YYt1niHW/IdYDhlgPGmI9ZIj1sCHWI4ZYBw2xHjXEOmSIFRpiHTbEOmKIddQQ65gh1mOGWMcNsR43xDphiPWEIdZJQ6xThlinDbGeNMR6yhDraUOsM4ZYzxhiPWuI9Zwh1vOGWGcNsV4wxHrREOslQ6xzhlgvG2K9Yoj1FUOsVw2xXjPEet0Q6w1DrK8aYn2NsJL2yTVa13H75KRc1PtYo0Cj7Y1DjKh9eKMgc9J+vCbJrPHU3m+8J+zOw/cbeU8+vvPM7z7iO8z8vhW+3/h1ytsGefyu21WQJ/XR3m+cjKkPnrrD7/Xi+7n8Djeelsanu05DHp/umoM8PtEUTy3dRnl4KuJVUFd5P3ec6lpt3fd86o36Fca496MzEX+DoHdd3CXut3iCEp8wttGQD2K9P+zmc7EhH8T6XNjNZ5MhH9xrzHrbrPARu+FTUXe3fucHS6nfpRH+2aDXx/h4LqKdfbBZ0WvKo0b4eAdUJ8JxtVEtmDdK93yclrSN7u9u/c4PlPo/LYld7t2Qxy53kNOSpL79npaEbcmnJeGQxqcloU1sUfjwER9Iv5WwtKNBOLyI4jeqlOOjZDJ0fxzur1d4jxP9Y61hyOn2d+kgRY0XdjWxXe47UYfIsQxC/wTI8L0tOuZYRL0uicD8yuqOLKdX65iBgqnVayvVi2XYQjII/Rmo1xt0EtVWpXwQcc/9xpOosCz/1myGDyTellAfbiehfyGmnTYrMuBxN6xTloFptkbI8LIiA7r62t67H2y5+oBS0reoWOV8KtRmBScqiRpc9cQURwkXzTeIuMdNL2UdpLjAemNPY38jotI8fo1FMBsJ9MTTCinnkt/jm9KHIMI/G+h+a7eNPLHHSaF+eGuGNgbklDw+qHtDSj6rg86hvO77bVG2kDY2ySjycPmAsDLKPZeW7Wfx9pMyhGWzQXUiHFc7qsmSzERmW5IWE8LykLW79Ts/UOo/hOVDPTGE5fB2kBBW6ttvCIttySEsug4OYdEmNit80O0z/RbCigs/k/hpIS4fGsruJiqE5VBP6H8PQoLvb+muJ4/hX4Lri1rXF26WXUi9+/AdOsvOEZzQIC2mHIiE9HEHerokh6D046L8HBy2NLNsd93vF+Klvq4b/UEfn4DC7pzGRWkzcF6o3gZ591LeVZC3j/Lw5fr9lIeL9LJZi13JP6FFWU+RgLooK7ymg1694kI32/eoco8XF7H8hhg+uQH55BQ+nnVZ8Ntf86U0URvy534h+dpfweI8jkh9H0Gv1S2unaNCgiiszX1ieZ4ZtNv0kph6a/5Vk1WrB68IyUOsRqsjOt/8n2IegnH44eer9aXUh3wK/yzJ6sse4z7N4RLPsKcUWdn3ufRY2KHjvFHl3kgM1llDrJcNsZ43xDpliHXIEMuyjpbtaFnHk4ZYlnV8zhDrBUOsZw2xThtinTPEOmOIZWkTlv3Rsg9Z2oSlvp4yxHrJEMtS908aYlnq/kVDLEt9WfrCE4ZYlvoaVl9oqS9Ln/NuiJksbcJy3LbSvbvmT+QOi91b6v5pQyxLu7eso6WfsIwBLPX1miHW64SVdl4v9NMKvbYuJWuZuOlXysoaCq5NWj9ljtITbjQW/s4XyOdD642FA7fdvPe2gNIo6UH0NkN08uh1JOj1OWsisAL6PUP3RgEPk1uzOttqrKlWftwjMz/rsaXUT/WF/1I9MtNeStDWPUV32oddckredXCNechH+0BLTsnjcXsQrOcMsV4wxHrWEOu0IdY5Q6wzhliWNvG8IdYhQyxLm7DU11OGWJb6etIQy1JfLxtiWdrqKUOsd0M7vmiIZakvy3HohCGWpb6GdRyy1Jelv7e0L0ufY9kfLW3CMmay0r275jWYYbF7S90/bYhlafeWdbT0E8Maf71miCVrMNqL5bx1PO5jphofLL8zBZY2Hxb6GxT6uLUe7cMwsvaABy36WOvR2uMG4Cn8F7PWI3orEB2v9aBvuz4CK6DfBboXtdbD+5b+cWthSfTraT+aui+S9yviXqirqH7a+iLeY/vF8tkYPlMD8plS+Ewp5aTenvVczxA/qQfeQ/5ZRSc+1tA2pNSr5/2BtUzQ669GFZ78+kicb5X+iq83ID2/VYz9G/3NON379y3jygW9fpc/7pzWv7u13n891V23xe5nRVxt3EjTHxbLB7HkQ9HSv7Ed2Y/0u4cVy2+OwJJ2d0k+Yuvy+cOb0h5jCqZL8kH7caL/q1Z7ufHmutbmetEp7nPFD2b/9VS8rFgWZR0n+oO5DubftDA1PUu7a3bAb0ZmFb4aJvvmfttuSpEhDgvbaw3R4yE3Gj2/Wd1+56IFhG+KZ4JenWv2szlCBrQf/LBilP2sBhnS2s+aNfGysv2sCbp5C/0XwH7Wtoi0Z3px9rOG8tB+REfa2J4LuuvQ79iO5eNiiIspD2XfRHkXK/XKUB7Kd3GMfGsUGWT85I9a7m79zg+U+n/HKUd5d0PeWsrDd5zWUR4eNM3jCh4czeM2HgTNhz4dgLxtlIcHNa+hPDx4mV/JxTRKv7FdXF+8Hvoi0wXEE+2G38XCfoj6RV3hKRtan+d5wU2tSrt+OzXdzS8ursWDtAztrpQmTkD+SxXXriV5onyK6G6dImuO8lw6GnboOG9UuTcSg3XIEOsFQ6wThlgvGmKdM8Q6Y4hlqa9nDbEs7et5Q6yzhliWNnHaCMtdrwxssFx6yUgulyxt4qQhlqVNPGeIZelXLfu2la26NKx+1dImLP2XZR+ytAlLfT1liGWpr1OGWJa2ainX8rh94fRlGa9a+mjLGOBlQyxL/zWsNmHpJ4Z1HLKcw1jW8VVDrGW/+s7wX5bt+IQhlqW+htXnDGtc+KQhlmV/tBxrLdtxWOPV0BDLUi5Lv/q0IZalnxhWH20pl6Xuh9VPWMbk74Z5reW4/YohlqVclvNay3a07I+Wc5gXhhTL0ia4D8lzTzzbVfauuCQfihon+tWt59CTxCMTmD5rLsfti/P8pZZyhvgFgf6cW/hPKfLw3k7MGxtA1vlGZaZUbNQL1drcQmOhvZdyG8nK93g/+HaFPm4vqKfzeouy72I07ODjB9JcGoO8bZQ3Dnl4xu6a7d3ye9qLU0yjf+SfU+h5H2natlwXdNsa9kdtzwjuk+C+5Kcfl1LvGRH+WZLVVp7OnhHNl65VdDwVo2Ntn9wVcM3+a1S5F7V31yWO9wfBeskQ66Qh1llDrFcMsU4bYr04pHKdMsQ6ZIj1miHWYUOs1w2xLPX1vCGWZX88Z4hlafeWvtCyHZ80xLJsR0v/ZamvFwyxThhiWerLsg9ZxhOW+nrWEGvZr144v2qle3fN5wkMi91b6v5pQyxLu7eso6WfeMoQa1jj1SOGWBKv8lqhu8b3T/yup+WLS/UNGW1NC+tk+Q0Z4bVU35DR6hZnB7jehTqIwtreJ5bfdbVOm26LqTfyn4qRVavHOkOdbCGstGtL/bbtdNDbnlLWcx9rr3NuidET8l/M2RyityLR3RJ29MD63haBFdDvIt0bBTxMomNcf9xEWJpPXgP35CyR6aDX1jYQ1qYErFsIa0OMXFsSsD5BWFiebXhbAtathKW1SZx9I9Z+wtLsW7B2JmAdICzNNgVrVwLWfYSF5XcR1vUJWPcTlna+jGDdkID1AGFpZ/UI1o0JWA8SlnbOjmDdlID1EGFh+ZsIK5+A9TBhYfk8lctDHp4poL0ri+/Xf3u6WybtfAZ8d5U/kSr0/3G6g/md6W65sbycxT1Nv931RpIZdSE+Snw8nntt7eORXxDosY/wz5KsxvK0Yx/tnHLUj4yPKT+XykdaoDoRjquNasG8UbrHr2ZPUrnFfNHZ0yvdfR8lMEV5d0Mev6I/yBedpb79ftEZ25Jf0c9B3t3Am21iWuEjdRtR6HOENa2Uk3ZL4jeqlJsijAzdj/qiMx8HIvT/Q4uh0+3v0nEoGi8ttOG+I0eyMA3LIPR/H2T43hYdcyyiXlMRmP8c3PAfT+uYgYKp1StH9WIZpkkGof9HUK836GvZuaD7N/qFe8Nu2dYqvIKIe2zbayPy4vgmlXXXF8E152l2u57ocWtCGnsV+j+LsZU1igxYX25XloFpchEy/J+KDDjc1Pbe/WBruAko8dezeXjgpuQmWKPgRCVRg6veP5/WceR3nPmhC9Pc7lSEjFh2NdDVG3sa+xsRCuLxNhvBbCTQ01SgC+XSZOA1REkdMgn/bKD72d028hS4X4g8rB/e3pJTZM0peWgY/fBZHXSW9Pft33tvlC2kjaW0/s/lAyqbUe65hJ9eWarj6zQ+awbksyYlHx9Huml8cgPyySl8GEubqrl0R9jJR/r/F/z4q1t0zJEITFk+Efo7lPpoR4UJ/Z0K/R1KHUWXt0PenUEyb9Qlj3t7+pT1LoV+D9DcQbKifHf1KestSyzrZkXWKYU3jyFYrwsxhgj/rFJHH2NInF5d6nPajabO6kQ4rjaqBfN4qFhLdD8Zdv9ezLT7brq/u/U7P1CqFLQpsiTttL07KA9P29tDefsBq99pt9S332k3tuW9lIfLB/uAN9vEXQofqduIQr+XsO5Sykm7JfGLcxuCoZVzv7+slJkKel0fu5O9hL+79Ts/UCrMpHUnwj8bUd/dJvJ03MneoFffqB8OSe9WZM0peThVxjzkc7fCR8Paaoh1uyHWOkOsDYZYmwyxthhibTPE2m6ItdMQa5ch1vWGWDcYYt1oiHWTIVbeEOtOQ6zNhljThljXEpY2FdTGgsUuG/Aa2l0R/Ncr5QMqm6F76yOwBMfdwzCZp2IyLkwEetzBp5gL/cdzb/3FpeVRomF50nxJ1tO4n3paI/yX6kuySdNRjkPuVGTNKXk83t+eko+Fjbsk852MIg+XDwgro9zDPM3GcWlEbJyfuGNZfOKu7c6QuETbbZElebSdG0h/CdFfDzJo9Pj1EKRvKH1O23UxFcEP5cN7cUtq10dgRZ36f2mE7HeC7LzUpe0w0ZZthV7bRYLjvMij6YbH8BuU+mB7ys6PcaK/R6lP3NvDslQ8BnmG/qTu5Pg6yMF6HQ+76x2nQ5dY59puG9Sl6CxH9Kh/3hWMPCUP+xbHp9rOLdw5zP1e+5oJfski7qslw9Tvj6bs91dF8EP54vo9lu+n37sku61Y9if67PdXKfINU79/OmW/F5ta7veD93ttvE/b73G85y8gsT9BLJfP6wkiF9oMxgy3QT7Svx7TBzQfEvd4QevTOPfmryehLq+nPJRd5kQXbgybmdVsuetraGF6XbjEutP8DfoIae9c0OtbdlIeziF57UMbp3BnNdsr2hmOU/+h1Sm0HZrjQTfG8naD/rcbpHxUxMM+P+Uf9FERb6V5f9j9ezGPinJ0f3frd36g1P8OTf4wEy7D8O7NQXZoSn37fVSEbck7NHHJ6W7gzTaxRuGDu4SYfpqw4nZXJvEbVcrxB44ydB+Hr0mFN3/46Y9g+Pr+lmg98M5izS19SZGT20Lyg8D3JvNCIa0Le5tvMmcXJvA5ghMapMWEm4uRnncVcte7Oewtx4ldmJ93GG1dWNQmc3c9AdecNBcm9XXd7A9oZhEoWDzyp3Vh2ia7eygPn2LyE3R8+reP8nBT7n7Kw5XqA61r3gz+L1pCiQ14+lab+u1pbufliOodE1F9JOz+vZiIaiPd3936nR8oDW9EJfW1jKjQpVtGVBsIy3dEpZVzv1cqZfghhOS75PnT76mPOxT+S/WJTO2V5bhPZG5UZM0pefgZZMxDPhsVPhoWP3CeTinzYh+gcQi1JoL/iFI+oLLcx3khJKvUBfs2PyQWWSaC+P4xzvStOEJ7SKyVD4J0/WXYhl/f/UXzT3H9RXvnL6fk8YPCqZR8LGzcJRmXM4o8XD4grIxyD/M0G8cZ6ocieE8E+uyYbVzo1ys2LroeV8o7/A/Q+x0PAR1/vvNh+D1K9Fo9HqF6MM1DVA+h3wL1+B7VA2USeaaovOS7JP30IMm+u/U7P1hK3U+Ff5Zk9dVPD5I8rJ8+w2Q0C1YnwnG1o7pGUnd8X9j9ezFh8iG6v7v1Oz9QmsuLuYWKDJJ3GHg/RHlHIO8RyjsKWP2GyVLffsNkbMvDlPco5B0B3mwTBxU+UrcRhf5RwjqolJN2S+I3qpR7iDAyQa/LkfsPK7zHib4MLokXHpHXw0G0HuT3WkVO1rfku+TXnmfm0row4Z8Nem3Dhws7RPKwfvp0YWhiCP8pghMapMX0KRAJ6Tlq5mbfqpTjJKocJ5k/3LIZN5L+SOt6Oug1e17NQBniRgHt0bfQaXxWDchnlcJHusA4lJMPb0jehFJX7fWeu6ncAcj7KOXdF/TWS/Luj8F8IAbzQSXPyf6b6zq8otwYmjgfmIVtEGXPUVh8YBaWP0RYYQIWH5iF5UPCOpyAdSthYfnDhHUkAWs/YWH5I4R1NAGLD8zC8kcJ61gCFh+YheWPEdZjCVh8YBaWf4ywjidg8YFZWP44YT2egMUHZmH5xwnrRAIWH5iF5U8Q1hMJWHxgFpZ/grBOJmA9QlhY/iRhnUrA2kNYWP4UYZ1OwPoMYWH504T1ZALWzYSF5Z8krKdisNy1bMGdVso/RVhPJ2BdRlhYXspOKViZ1l8Jo87AfcPnt6lXOIV/lmS1lacTRp0JevWK+uEVm2cUWXNKHo5FmId8nlH4aFgHDbEOGWKFhliHDbGOGGIdNcQ6Zoj1mCHWcUOsxw2xThhiPWGIddIQ65Qh1mlDrCcNsXgsi4vr3fXlreu4uF7KoT+LWhrRYnnEiJo34NLIoQSZrySZFzt/cNc7CGux8wd3fTVhYXn2uUnzh4NhNxaW72f+4K6vIbkWO39w1wXCWuz8wV0XCWuQ+cOjYTfWIPOHLxLWYucP7roUdGMtdv7grsuEtdj5g7ueIazFzh/c9SxhLXb+4K4rhLXY+YO7nmtdW8wf5gkrbv5wJgHrBwgLy58hrGcSsH6QsLD8M4T1bALWDxEWln+WsJ5LwPphwsLyzxHW8wlYP0JYWP55wjqbgPUewsLyZwnrhQSs3YSF5V8grBcTsN5LWFj+RcJ6KQHrRwkLy79EWOcSsN5HWFj+HGG9nID1Y4SF5V8mrFcSsH6csLD8K4T1lQSsnyAsLP8Vwno1Aev9hIXlXyWs1xKwfpKwsPxrhPV6AtYHCAvLv05Yb8RgufTTYTcWln+DsL6agPVBwsLyXyWsrwXxdfxg0I2F5b9GWF9PwPoQYWH5rxPWz8ZguXRn2I2F5X+WsL6RINfNJBeW/wZhfTMB68OEheW/SVjfisFy6cNhNxaW/xZh/VyCXB8hubD8zxHWtxOwfoqwsPy3CevnE7A+SlhY/ucJ6xcSsD5GWFj+FwjrOzFYLslJmtNK+e8Q1i8myPVxkgvL/yJh/VIC1i2EheV/ibB+OQHrVsLC8r9MWL+SgPUJwsLyv0JYv5qA9UnCwvK/SljfTcD6FGFh+e8S1q8lYH2asLD8rxHWrydgfYawsPyvE9ZvJGB9lrCw/G8Q1t9KwPppwsLyf4uw/nYC1s8QFpb/24T1mwlYnyMsLP+bhPW9BKzPExaW/x5h/VYC1hcIC8v/FmH9dgLWFwkLy/82YX0/AatKWFj++4T1OwlYC4SF5X+HsP5OAlaNsLD83yGs303AqhMWlv9dwvq9BKwGYWF5KTulYGVaf+X50+/DfbvnPeXU7w8K/yzJaitP5/nT7we9ev09uMfPn/5AkTWn5PGa4x8ofP5A4aNhhYZYhw2xjhhiHTXEOmaI9Zgh1nFDrMcNsU4YYj1hiHXSEOuUIdZpQ6wnDbGeMsQ6Y4j1jCHWs4ZYzxliPW+IddYQ6wVDrBcNsV4yxDpniPWyIdYrhlhfMcR61RDrNUOs1w2x3jDE+qoh1tcMsb5uiPWzhljfMMT6piHWtwyxfs4Q69uGWD9viPULhljfMcT6RUOsXzLE+mVDrF8xxPpVQ6zvGmL9miHWrxti/YYh1t8yxPrbhli/aYj1PUOs3zLE+m1DrO8bYv2OIdbfMcTiNcdQwcI1x2brOm6fnJQ7DHn8quAolUF6xIjahzcKMh9OkPk2klnjKVhHErC2EhaWl7Lae2P3hN15+N7Y01RuP+Txu2gHIO8g5eF7Y79HefdD3iHKewDyQsp7EPKkrvje2DjV9bdb9z2/5a4eUsX6QP1nIv4GQe+atEvcZ/C0gjHic9CQD2J9Luzm86ghn0dj6nPIkA9iySv0Wj/k0zZC4sP3mA+WFzqNz8SAfCYUPowlr3K7JO9oYr8eJ/r/uWXM7lXuS7Z3Yx4OeuWbgHv8PmYIMklZ6YtHIM/yuYrgH/ODXxJdHFV0gXUS/nzkgeRrfwWL84RXNuj18z6eSWl1Q/nZDvHZCeogCuton1iTSp6PNj0SU2/kPxUjq1aPkHQSKny0Q/qE/liMXEgft/9ddIjPkwx1WIzTobaH3h1LIKfV1BsLB267ee9tAaVR0kPY+r2F6MTvjAS9Nng0Aiug31vo3ijgYVoqP67xWTMgnzUKH+24ln78k8YnVGTWTiGS8cjV/y/o3X+xbzyKBN/T4c/XCP3RzR3M/9bC1N4jCoNufvhb+OGZCXx6k/CLOr1pf4R8fwXj6/foEwP7lTpfGiOzYOJpeiiznA/BMvwNxcWexmI1LhZe0yRvJujEtdP0210fpLyoI3EwLwg6esR7bK9x50bI76g4KoR8pJ9onbCbNo7CfsFxlHYEkTbnYz1ofLRxQ9NDHJ/pAflMK3wGjZM0PprMPOd1Cf3QRRd1yqC9Yp/EsnIewDjR3wN+aGMLU/NDKCP/1nw6+yHhF+WHwkCXbwvYJ/uhkOqM9dRkFkz0Q4LhEvshob+iJYPn+E71Q8JLG2dzga6PIEg3zuYUPfgeZ3PE54ghH8SSvqLFmux/+o39sTzH2lH99caLdJ5af0XbHSf6eeivBeqvaO9h0J0XQh6PbUcUvtxngqB3/uhSnC87EoGVdowS+vmYMSpuLuRS3Fw/Sr6xQO9Te8NOnaOwAuWe0OP4yOtfR4n2SAxt1NzVXd/euva7vjA3I/aO7ylLkrzjisySh+8Rfyzs0HEapd9YJ2cPW7d3cJmO5UE9HY/A1HzCvWE3rdR5RME9RrjYz1lfcqYY9/FPt+zd9fEPX6TjsZ24JGuffufQc7Pcvpi4fVk/nLT2Fbld+36oj/bFNnyc8tAv83l06M8Fw9Ev0Lg/bH1pMf3lQwP2F02f/JxGGx9Rn+OE8RjYe53sXWh4THBJ+o/0WdHfmFLeJY7vhP5LML68uF3nH9ffgkD3C6gHPkfyeKDLotVZaI+QPWIfs7PHckHa8QTJjLyf8MQ7Q/yCQF9rFv5Tijwid1bJGxtA1plCpVKcLddnmguzczMzjQzhi6x8j9dJtfMl1iv0outTXnRdqosPwE8zngS9ujQGeU9Q3jjkiYyuD63Z3i3/SU/yp9E/8s8p9PvCDl0/bZlT+PC8YhCsI4vEWhd09wFtLMTYhsdCjF/wzNOvRvjlNL5OfBv7fawn+8HXyNfh+GdoQ2UtHmVfd8IT77S+TvhPBdFtm1XyBvF19Zlyodycn1moN0uNeqWZCXrHhFHlHvs6zW4vUug9+4q85uvYn41B3gnKQ18nMmq+zs+4WMqn0T/yzyn07OvStmVO4cO+bhCsI4vEEl+HcRDHqejrOE49ptQHfR3Py36WfJKnrz+o64DsU1Fel3AOfQz0xPplHLyHcTOWCYNufQj9dyBu//ZFunxSh48q8mn7urBev3RRNN0xhc49q5X189sa+2/5UvXeRv2WRu3exv7RQBePqxhQ9Xk6FRCdS2N070H6zcs3E4QjQ/BYkJzQJBBLazrE5qH3uzDleZlcGH8VZHfrb37ApE0deaj184ivmHpaIfyzQa/J+djCoi1fon54ePTz6KGYXxv0Lm+79OWwVzcsB28h1D7gk0b/WF9tqZ3tpv0Is/UXXWDrsudx5z8Al/V7tCQfkmzMM+5xZxhEY2UU+jspDx+PZWLweRnkf4B+/AZ94xVDHanHZOvvGORZ9jMnx9dBDvZ/GEZF2T/Si875EQ/qJO7xuKv3P6DHJNojee2RJw7DbNfa43C23XUKH999ZB3VJ4Q83jIQBr31CWP4aPaY9NjrzyL6WNRjr1nIR/qd8Njrn1J7auHDBewDxX77QAh53AfctRzrmVPoPxt252l9QNMT28KEIoM2Dmm2MBHBx6Xbw8Xz4fJClyaO8BOap/+8u/BfqjjikZR6Ff2EfvSTT+NbNH+oTVEES3tUro0D2uM4nP7xdO6vWn4kbvtA3DilPQZ3Ov+vNG3xHQ/F9YfF8kEs+VSNbHOTOcVoa836zZhlfXR5+TzNBJTRth5wfULAwDFlYn2nDJZD+wgBl5cYhf4vLulgTpJcaWME9qP9xghx2wNDBQvHEf7sT5pto6sCfZvqva1raWNZKlkPbbyudZ005l9M7YO+UGsf4Z20HCC4LOMWkPESkjFqG++lEXTuel/QS8e+KAj0+IXbEJcpNHreHiD021p8k+J6sQe/MU1Bjeux/TmmSRqPxHbjtlRxO1egna+j/qr5xcX2yah4MsqXe35tbz5tzDEMH6fVYo6ovuOSxHca/TEFX2s3t3bBfhu3Ngpf/OjwMbrHY05cjOIS+pIfWK9jYP20OEeO2EeMNL68X3sOlToNQ79JY9can7gYyMdrpdhunl/bK4vuHwM5tZiXt6sdhzqMEoZGz+uIjH+c6KX8WKBvkZX+wOPYQfDZH6axNK6OLt0a6nUUmZnmKMksj4UmImS+lWQW+o/D2MtbzrW5CG7b4m32Qv8JwHx1iy5nEKTzo9rjMXwEJvJoW59PUDl8DMdtrmHzo3ANh49c5HqOwL0NCrb2KNj92936nR8wCZ48KsXtvicVecaJvkZ2fJp0Gqcz9++UwhePStxAfE8R3zdtiLZBi2wY32O7c5tw3Mly7qF8ob8d+vNtNO7heI3j496IGBrnA0/EyHpCkRX7zKGwO1/ov4wx9HZdVpQHZb1w64d6rN21jhF260fzH0i/WP+hPao/Rnla3J4Jen1YmjEG20Gj522RQv+wMleKW6d0fw/GrENEvVqXNE5p81d8DnF4vY4b9cqWfFqWn2H9OaxbHEs5Jz/eJ+9bIni/DLyfSLFmYhn/aW11cdBdr7TrdDmlPL+icMRA5lyMzNr4HAbd9dHWG47G8MHyR6k+R5X6eI5nU89dhX9W0YmPuas2t9RevRV67XN8YQz9cYVeazecu6JvDYgvzl2P071BXkt7o0+/gGvBSH8X+IWvx8xlpR9oPmNToMsSBPFtlFPK854EX/PCTVSfMIiuTxj01idMWZ+Q6oPlBq1PqMicZDffJbvBNXbNbqJeP/4psJvfiLGbuNfqQ8rD+qRZU8d7cWsNcXwOD8jncEo+72Sb+kMjm/phsKm/FxPntYq/Y/V81JCPttbD4xbrF/OED9+Li5OitomiDO7en67Xeaa1G6HfAXbzZynsRmuDI5R3VOG7VHtzlsofxmFpsbfQa7FtXAyW9nmA9jql2Lbf10nS7w8R/lmS1VaeTryrrRE8puhuddBZ+6g29hWKcz/WqN374N37uTEEMBd0K/k4AQp9QL+5nBNqjGhChYdLeMYHGhKfh8EBNeOnkSmJNilf64SPRdQzCNJ1QiwfRmBFnbFwHPKR/r/AIkqaMxbQeNKcsaAt6CDdqFKHbEQ5XDTGPKzzh2LqLPR/FVPnowl1voXqrG2O1hZij0TUWe6vDPRNEoKh6fiSoFv2MOiVHe+xPWF5ofMdrFxCfKIG9/ENnTKoh6gNpHdBPtKvg8F9ZQsz7twU3/VHnvgb63UX0HBgJfUaUzBd4hc/hH5tq+6eF37Ud5iiAjqsn7t30YZk3cS1udCPQZtvTNHmcf0HdfuOD2QKjXwaG0f+b/tA5p9lupWcNpDhcnGBDNNGdepBAxlNpijafgMZnAFwINPvjhEsL3R+d1MVe3Yo41Md7Ew8IzsMddAG6KidoJkI/MNEL+XHInTHOyyEfmfLsb351LAVxGhttTlCviBI11ZYfql292wmPr4OjecVjRDKL0WwHmWD8jZMUpA03+eAGUI+0v/6pg7mD9GAGUL5NDui07wl1+8Kf6jw6bf/sI7GFEyXog6l/TQFUBzQ7279zg+UZvIX7qndTOrBnwM6bVdFVskbG0DWmUqzkJ+drZSaxepcY2aWx0iRle+leaJ3lULvd8WorB7C8xjo1aUxyDtGeeOQh08G+WAKP4FZuZ5G/8g/p9DfC3Xopy01rA8tEksOk9Am6xfKl0Ut4jwC+Uj/eYgF0hzmHMK9NIc582SI68g+0aXdrb9JltRMSMJP2meFIssR0ovQNkAv39zeXZeonT9jEfXFugUKRpTumMeIUnZv0C3b0RSyaQtPiHEwQk6HsVQ7UDQ+2wbks03h4/PJF/JMisfup3gs6YnUI2EnH+m/BvHYQxSPaW8RCb8QfmuxEPtIKS8775iG/Y3QH4J+xTulH6E6Yz3j7AzjMZQ5akHr2BAsaHGdx4LO7l70jz8W6nVOOhBZ6LWYBe2Ifbg2/jJW1KJ5CPlYt3ta29cc31Nk5/LGVlT9fzzsxhT6727sYD7VJ+ZPRGB+e0MH8xnqO0LjrrcEOj+XRpV77B+wvNCJLfp661vwD/jBb39oaL+iC6yT8B/043HIKxv0tpGPhUStbnHtjB8A4TelNKz9fWJNKnk+2nQipt7IfypGVq0eHANpfLYoOhH6+2LkQnrpw2j7UlZ0iB9uNNRhMa698UOSwn8xH48SvV1MdPzxKNT9gQisgH5fTPdGA/3jUU6Gv24RTyv1u4lwtbbDe2z/WF7oND6TA/KZVPjEYd2kYPHYjvSTCr3UAz8QujRr2x37vF+RVVujW4x9it62Ep3ELSNBbx98IAIroN9b6V6UfY4qPA5Tubh+6dK0gsF+/f4YnlJXl7Q3YIWOD7b9hxSv+vFVcxX+UK3wQN6PeOKddsyPeo6Acmtvsw+yflisNsu1WilfmC/MNKul+bj+rT0PEXptvSev0IuuD/vRdTnuVAht/ZBPyBqHPJFRWz/047Pmymn0j/y1Uwp5/bDfZ1txc+O0WLJ+iH5f+vZS+Zo4rDCIrqPIPBHozzbZlwn9/wbzf3nzbjSI1kOg3BsJev3Ux8O3/mpj6YpAl13jLfgu5ZTyQnfhfGV+pl9fmVV04mN+9EhKvfKzWSyrPWvlj3b0u24+7Fho2/whecnX/gofvsd8sK+vID6+nsOn6SeL5YNYEkP6ft4va4mex+ai9iapJF6r1uwG1+84VsL1PG4fbR8Lf+jAXd8N15xG6TfHB9/e3sFlOknaZjse9w4TT74XN+4dprrhegGux49u1HniejyugYSQj/QvwzrlxMbuOmL5qL1DuLaNskbtNVjV4nEhP4A7qdTPsI8UtA+qStJOTeI+gv2H+wj2H+4j2H/4xHNMWj8QXbh+8Od99INxpR5xH8jVNpdLPbTxYJzy0IcfpjyMH45QHvpKOX0tQ/xc0vorP4OIq7PveHhSqeuFtF0+reqoore0Nih1cja4eUcHl+lYHtR51Jqt6Al9IcuIMkQ9N5SyPG+4fmNHdn5u+ACUEcyHATPqlDL0rRhTsG8V+gL5Vk9rcqpvTXNi/lKsFSK/INDnHcNwqqA233Zrl6ta13v2Vuvvq96978CexgipEru+5uqZHmkDJW+U7u0nug+E3b+lO3AXZmyXP2zhKA+ZacJRl94IO3ScksLKVzZ3cJmOZcW25C0gIeQdA95sEwcVPlK3EYU+JKyoA3xHU/DTlrl4qNLKud/3RJRhl60NnTxEa/UTrMMJWPweHJY/TFhHErA+QVhYPupViSisWwlL2yYlWMcSsPYTFpbnLSCPJWAdIKy4LRrHE7DuIywsf5ywHk/Aup+wsHzUgWxRWHwwddxheE8kYD1IWNq3zgTrZALWQ4SlfSNSsE4lYD1MWFj+VEQ5d42PxdN8yMDPtz8LpQzxE3nxHvJfqg8ZaHrXDsMU3Z1WZM0pefi4HPOQz2mFj4Z1nyHWA4ZYoSHWYUOsI4ZYRw2xjhliPWaIddwQ63FDrBOGWE8YYp00xLrfEGvcEOuAIdaDhKVtedR87urWP5f27d97b6M15wooxc2R3O+DEfzXKeUDKpuhe+sisATH3Yt7vIuHgmrxuOCNE/3TsITBjz4nlPIuxW2T9LylM/V0X/gv1TbMAyQP64fH+/sUWXNKHi8TTaTkY2HjLsk6QEaRh8sHhJVR7gWBvi1PW17MUJ7w43txS6j8Ks3h1u/Xwe6jXjHSHqu4xK85CP3XAJMPR9fqoPkmoT8aU2eUR5tjSlm/j1vmStryryRtrYUfeWivzWuP/nj9BmMBXoLEsR11wklbvxE9pX0syPYiuGwv4qvZb2JZfLynbQ3eRTw1f4P3uE9geaHT+EwOyGdS4ROHtUvBEnptS0zcVlVtq6bnbS/traraNlxt6+xitqqK3q4iOt6qqm0RZayAfl9F90YDfauqZisTEXIK3yRb0V7BYCx8fCJrdC4/hHyk/1N6HHIf1W1363d+oDRfitsS4/dx3XzqNY+o7S4ot7YNa6BtqXOlQmEuX2g08uV8tZ6P68vaNiyh17ZtXa/Q+328NJ/XtqXy1tMxyHuA8sYhT2TUtqX68U/zqfSP/LXtTLwttd+tiph3yyKxZFsq+nh+5cK3b+JXNv8PJYZcalkkhvoXMfGsNjZpH0mIeyVJe62F69Xvay0TKfncOCCfGxU+U0q5TMRf4cP3mI8mc9KWrv9IW7pwi7IWS8ra/zjRfx5eZ/2LmC1dvOabtFWC+6uUx60SceOy0P9fMVsl7qM6Yz01O5M6jyn1com3Sgj9X1Ns4GnrsbpVgsfipY8b0q+d8Csrnl5DLMSNAdoWqZRbJdjEUZ0Ix9VGtWBe0hLJ+8Pu34vZKuHprZQZbVuDJG2qze4Rp9o8fcfHp/1ulcBQqJ+tEtiWxykPQ6jHgTfbxAMKH36LA+kfISwtjJZ2S+KnPUrlKYpWzv3+UkQZlBF5aEsQ0zH1E6yDCVgcLmhvNwlWmIDFWyXiTiY6koDFWyWwfJptF4jFWyXitl08loDFWyWwfJqtEog16FYJxBp0qwRiDbpVArEG3SqhhUtxWyW4HIYcLqXZ3oCP7gy3N6Q+h1/4L9X2Bk3vcdsbTimy5pQ8XgbStlGcUvhoWMcMsQ4bYt1niPWIIdZBQ6zQEOuIIdZRQ6zHDLGOG2I9boh1whDrCUOscUOsC72N4IEI/jmlfEBlM3QvF4ElOO6etoVW6LVtBNqbObyN4JbW8sPyNoLBxtV36jYCmSNnFHm4fEBYGeVeEHRvIxA67W0rbe4i9PyWDmPwo36hXwB7fzXixECUIe5Rf9JWen7bTNuGrz0Cxbn8m9hhL6bfb0Dna9o3oFE/42F6XbjEutPmhBjH8JuEcW8gxs2Jk+wq7hG/lMXlXm2+u5149vvmPpaPO718ckA+kwqfOKztCpbQa3PUuEf82hxVxgqMVazHiihb0+a5i3nEL3rbQnT8iB/t93gEVkC/t9C9pEf82Kb3RcgpfJNsBcvH2eTEgHwmFD78iOylls/2vOZa0l5P47jmuCfeaeMaXjtFeUTurJI3yNaA5lwxXys1G/mZ0sJCLd8+cV1b88J7aXzGtQq9X78wp24NeBz06tIY5B2nPBz7REZta8DjnuRPo3/kn1PoeWtA2rbUsD60SCzZGoC+8UL5mqOt369CfMhbA3zL4nnbZ9/PlPi0AOy/2OactOdGuEWzn9MCUOe81tLvaQEiQ9rTAoT+O2AT/Agcywhm3GkBgomPwAXDJX4ELvS/SmMgrof5fgQuvJbqu8F+67g0z1bdNW8dwHW0ccrD5xB8ArK2Nq69fniY8p6EPN5u/RTk8Zwek9aXpV1cf7h+aweX6QLiGUIexzHo80S/2jaYnXCNeSIr32N7w/LjEeVQHpc8n+pc8HvsQufk7aTn2Ww/i91ihbyyhGWtu7i6xW0ti9oLEIWVZpskYnneEtRu0/tj6q35IE1WrR68Tq/1s52KToT+cIxcSK+tjUlZz2Nd7GnV2BeF/2LWB0Rvu4iOT1NfzGnVu+he1PqA0GvbLw8qMqXZfnh/AhbvNdFecYjrb4jFe000XcXZHWLxXhPN7gTraAIW7zXRbEawHkvAGnSvCWINutcEsQbda4JYg+41QaxB95og1qDHciBWP8dyaPNJl7T1dtx6/H/TsxMpi89CcB38COQj/Q9v6mD+P7ANmV/xRD/waNCdh7HjIZIfn4mJT/L7ek/654PCP0uyGstTiPO92qsDKbfK8mkiqE6E42qjWjCPHwPyo90JKreYrbJ+QqFKTesukrRlBJ5ePQp5/EGhQ4DV71ZZPCCxn62y2tK7dnjio8CbbeI+hY/UbUShv5+wtMfT0m5J/EaVcvxRoQzdR9f1sMJ7nOg3tFyX0+3v0pKMxgu7Gi8LaW9GIA3LIPSXgAxRb0aMRdRrfwTmTeCSt27SMQMFU6vX/VQvluE+kkHor4B6vQHPoJBGfqNfkCVlnjJF2SNPL7WwjvPkt8Y3qay7fgiuOU+z24eJXrYcRemUbUXor4uxlQOKDHFbfVgGprk/QoYbFBlwuKntvfvBiF0iY3CtDQ/clNwEBxScqCRqcNWT7sA48jvO/NCF7Vd47I+QEcs69YjLrjf2NPZHbaPh8XY8gtlIoCf+2JmUc2lYt1R5+lBc7JYq7aN22tjIW6qiXtvoh89it1RFxVJa/+fyAZXNKPeCFuYfr+ymi5sWuHRH2MlH+t3gJ3iLlNCMRGDKVF3otVOiQrjHy0ZPKvS4xC38ZfqBS+NPBsm80WGwX32qT1mfVuhxWf00yYryPd2nrLcssawTiqxTCm/2UVivC+GjhH9WqaMPHxWnV5f6nNahqbM6EY6rHeUW2BXxOPiTYffvxUzrnqH7u1u/8wOl+fZh0c8qMkjec8D7NOU9D3lPUd5ZwOp3Wif17Xdah235HOWdgbzngTfbxNMKH6nbiEJ/hrCeVspJuyXxi3MbgqGVc7+/rJThJ5iS79Jk0KsXO9sqpP7mlfDPRtR3t4k8HXdyJujVt3aooujuGUXWnJLHy0XPKHyeUfhoWMcMsU4ZYo0bYt1niHW/IdYDhliHDbGOGmI9Zoh13BDrcUOsE4ZYTxhinTTEOmiI9aQh1oQh1gFDLH6bTXvTRxsLrN5mezqC/3qlfEBlM3RvfQSW4Lh7GCbzVEzGhYlAjztwaov0Z5Wly1GiYXnSvCXuadxPPa0R/kv1lnjSdJTjkCcVWXNKHo/3aQ/bt3qbTeY7GUUeLh8QVka5h3majWsHP2unnuDbm/x0V/s4SNwyhoyfuOyDGHvCTj7SfzNm2UfbcRDCvTQ7/XEsFnm0HQq8+w/LSZyh7eAXOs9vxjW0N+OwvuNhty60XRFIz7rTdj5gvCBtnyN61GOO9IU82d9he7h792/opjsC8mQi/oqsfI/HO8SS791qhxEPygex7iI+hyEPd1V8nx63iU6wHx0G3rOQj/T/GB7h/W7rOm6HEB9G/QfQDz+2I7q86FI76Ya/34h2wHGZVk/UH/sLof97IOettKMf+6XI5blfNrV+iX6P+6Xmo5Ce+2VcP0ad5YLePnuYsA4rWKjzpDcXuE0Fj98a+BMlHtK+zXmMZD/Yp+zaeKT5mcNQj/mWn0nzISptDNTaKqeUPxaBNaLIj/2a231U4a3Ri03go3/Nf48T/T/H8Xe7jhlEyHA4QuaJCPrHSQah/5eKvcT5CbT/44Qp9P8GMPmA0yTMuyIw/11MrKL1U9x92e94y/EI6vEJykPZedw8Afy5TX8m7OaPOGjnzDeIkVd7cz5OXh6P2nmXvPXX2dJftvQ+SXjGvrwU15Y3KPVJ25aHY+rPWFJuLOi117g+hPr675t0zPE+Mf8/JSbQYh35VvIEyBHnQw/DPfbb6FMwPvw+xTQ4DoUkv2CsuKQj/6swRr8pS9gpL1heY4VCI6/FCqiLceCbRnfsU7Td3tjOHMMj/d6wOy+EcoeJz2GFz2LG4os2dOMejcF115eSHHExpLu+A/KRfqNiF3E6jNO5NkfFOEDk0fz4ccrTbHrY7BX1w/YapwuX+p2vs71q45NmrxzHxdmVS3H2KmXdvfGY2LEFoa4t8HOKJJvhteLHQQaNnmMgod8Fdv5GingFY4fFrg/0M8Zhv0Wd3Bx210foCyn9ubSL37lfoaD1D9Qr9484HbrEOtfeIEFdis5yRI/61/rHCcpD+0wzB0rbd3D8/tP13bhHUuJyH0abwRiTfb3QvzfG11uPr7w2ouk1zncMmy0Pi6/nNY4Q8oSnZn+4fvGHZH/amBB3cphmK0cV+bV1MV531tbFLtg4H9H2cWtYcf3ApX5jJG577XQhbY2I11iSfMrNVI8kn8JrrUL/hT59SpxdWfoUlD1sXV+4tdHhtqs4n9KvXcWNgeiDvtvyQdqJJnyCoGZHIdxb7Nwvzo5GFbnQT04quC7tbv3ND5jinslMBr3ta7j2k3pvnvDPKno0lKcQ166onxHSz3E/8pTXBr19xaUvh726YTm4P4Ugu+j4VsDhE6DwTWd8dvZoxFoT+nPtLXxeDzgGa2eHCVM7YStt35ey7t4b63VZETdUyrIdTETQY92R/kTMHFDzn5ptCX1SDMenqKV9vn4kgo+2l0Abl4X+6ZTzw6V5Zl8sXOhn9rxGEvfMHtuA9xxqtqqd4KG99oxzwEcj+pb2TMwl9Akoo8jh0h6g4XUTLb7TTpng+O71PuO7jXCv33GZ+0y/c3GtHeJ8htY2PXtyYnxG0j4f1qnQfztGp5ofitOpxT6ftDrlV6CET1qdCv2vpPDDaXUq9L8Wo1NNR3E6TdpnwDpFffO+4iSd8ut62vpmnE6F/rdidIonbabRqdD/zgXUKdb5BJVDn8ExJ/u7bES5DTGYj0VgxsWfjBHVlppP47b8o5i21Or1WMp6HTeq1/E+6yX0f+ypXgcj6nWwz3o9llCvqNOx/0SplzaGRc1rtTUXl3jtX+j/dJie5Q7B2gavi2lxeNyeqzh7Wcz85jitbaB9sg3gyVBx63S8r+xfp7QBPNnYpTHI820DaMtsA9qac9wzt7RrzjmFXubJmg3wfMvKBg6v76bT1nH4r/Dke3F7a6VurCecR4RAz/OI48BX64tML/1uLNDjTeHFPvKv0F63v3WtvfeBaxp/fYnOO6qv8JqG0K/Z3MH8mxam9pq96HWxvjsEWaJ89+hm0MOy727rTPPd3KfjfPeEwieEe9xvQ4WP+zuxPll+bS1Z6LWYT4vBOOZbB3bxRkSsre0RcNeVCMyLwe43bO6uv7bfydFdvtmG92bFzgUz6ZTKftd2eO+Qtt+C681tJfWOe+eFdYKxKtJzrIp5/cwttL29rMOJCHqOwYX+asXO0ux90ORLOy5iXM0+XXueFGcLcXED8tWeK7F/197XuHDPCItFzRdjfdkXx8VELlntidT8NPpi7h+hwietrUhZd+/PLnrrWlu7eiRF3bQ9GJr83FekPj8CfYX3zWvrqXFxu9C/N8YvanWIe16e9pmvFs8cjymHNjSp8Nrd+pvPNwdKwk/81gpFlqjx8gOgx29u12XN9Mg7WNLGzgzpyc8Xh4r5DPELgt65Ao9N2niz20SezjNZbR1Q63d+vyhVaOIzWbRffCYbddq12IsW/+J85BaKjTQfgP50BvKR/jMQl30yAjMI+vedUtbdu/Gibtw4X+HSoM8V0LfEPd8MKU97X4djHNQv0vM+R6Gvgm+Iey9ySZ59FpoXfG8s73/FvbE8dmv2F/XVKdRhVByKfQTp98TEoSGU5/25R/qU/ZgiO/dz7jvcz633514K+Uh/ICY2uJB76bDc4db18v7cdPtzD0Ne2v25F5HvPqzIo51rwfaK9odyXAb5SP94jP0ljUv9rteKPP3uEQ5b1xdwzax4odfMpO3T7BEOIU94auefSHu4Nv2L1ifofOqxMpdvx7TShmKvnMYgH+lfbtlrFuohf8cGkLNZqRaapWqzOlOt18u1Kn+RzyVpM3ekqLOHs5s7MmaA9qsQ671Ga3BjgMdnZIxDnpzT8ea+2RaGxNPYB3cvsr7dqdCQuq4IuuuE8w1e91wJcojNjsA9/rIRll9JfITvL4LuvrW5g4XYLJtLb4TdeUL7C6S7FYBnODdSv+AovKR9MQ/Xn3958+Lo0JbkHWS2JcRDW9J4jZG86KMEj22faQPAFJ2jDRnqvJwhfkGgz4/lXlapl4/58SjJw/oZIT2PKbLmgt42Fp+QUfJGlXsjS4w1FfTWn22B67q79Ts/WEq9f134ZwOvtlmI0+uoolet30rZXBA9PmSUvFHl3sjbDAt9k+arWG/cpzEP9S1rO3HjMfs4bfwaIznF1+P9CQWbx7t/QuPTSqrH7tbv/IBJG5+El1a/0Zj6aXOBT0TU77/BeP5PNyfzmw56x+kM5aGORihvEvK4jSRmHE9ZB6H/lymf34vMns/cKmtzEZH1TfnD7nqvgrxRhZ7nIqsV+lVAw3Ph1ZDH/Vfr/3HrKKLDCYUe8djO/lPM2hLafJZkx7qvpLxRhS+Pf2hzTs5VLd6TgW7ju1u/84OlyhTVH9NU0NtP2JdiP2FfmiWZMQ/tAHXAied0qAsn16d2dHCZTpLmJ9gXrFDqofkJjG3flC/sletC9Fvh6RL3W+yjowq99J1c0NtubK/YByYpD/vACsobjeGH7S+6xj4QNY5qMY7IKG0xptTFJR5HhX4d9bsLMc+bVOpnyHtW2zsnaSqIHjc1f8B9fpJkxjy0q377vOii3z6vxYGaP+A+z+3uktYHuH9gH+DxDccB7h/aHDxDmEEQP/ZNB73y4VqT9VpXvlivzTaK55fjKrOF4ny9n7WuTNBbb22O+xDpQvQ9odAj3jjR39Dq19oeOYwFpI0Ohr2YLHNa3yJ0BZDhabBh1oPoz7MfqGWIXxDoc13hn1X04WOuq8V62hqC59hogccSlEeLJTXfyf4H1ytHFfoJqCP7WlwnHad776FYFeM5nkuvUOqD90S/TpZ5ijOwbTIRfwWX78XN0XnNUJtrO3l+jPou9ndtXUT8B/fFD2zpYL6f3rvRbH9VEO+zsL48D8K1V42efZbQfzjGZ00o9Ua5DoY65kcBk5/TaXahtR/bMtKvUOoVt24/HfT6FOxPb2KHvZieY+yaFmOjfsbD9LpwiXU3qdDzmo1LOaLX4grsRxy3Ja0b8r4GzS6x32ljuLZOnVF4SFtra2xx8iLWLYSlycvrg0yn9RmkRwwNX2jjxiuU+RMks8YzbqxBrFsJC8tPULmocUhbt4rq/xo+1z/Jb+wPu2XWeGp9YCJCZqyX1u80fJZ5ZYLMB8JumTWePJfW+Gn10vq+hs8yTybIfF/YLbPGk9ftNH5avbQ1BA2fZc4myHw/yazx1NYOJyNkxnpp65UaPsu8KkHmB8JumTWeUm51DD+tXtqaqYbPMq9OkPnBsFtmjaeUm4rgNxZRrymFt4YvGJmYcijzQySzxlOTGekyCnYUby4XkKx8fzHPjkQHmBcV++Bv9GvaHjDeI6D5E239ZpLytP6hrd+sojytvX2sOdRmZhdq5ZlqvlFwP4tJaw7W/M+zrtSqlUJhvlxolAszSfynW9cTYScf41mXVrR+S/9ietyvgvTfgjnMt+l50rjCz9H9ZgxdJuLvmxjKvbGw+95k2Es/GvbSC+9s2Cuj5K2CvHHis7r1G/WFWCLHONH/BszzXFoJZaR8TuG/kvh3ya3cQz/AWKPKPZxv/1JLxvYzRuBtvdbyJk/Cx3ss22/Cerx1vyrOzc3OFxfy5Uq91qyXS0vdr2sLswvlxkJttlCeLZXz9aXmX6zXG4VyoTI/1yiX6/Mzg+wb/N/BL/whzWERr91vA3382r3IurBq0/gT5J8NesdaH+uM2rq6pm/P+88WMoSP8mjrStqYG/XsPSrOHIU6cuyDseQ43fsTWmfEWJnXGbU4Gu+hb/ljstN+97dqz7Q4b0VMXppn3C7xvp+sgulk2La1G09r27g9rmz7iLUqAStujWQVYa1OwOK1i6i4PiqmRixeu9DiecFak4DFawpYfg1hTSdg8Vwfy08TVi4Bi+fgWD5HWGsTsHhujOXXEta6BCyes2L5dYR1UQIWzyWx/EWEtT4Bi+d4WJ6/Q7whAethwsLyGwhrYwLWI4SF5TcS1sUJWHsIC8tL2SkFi8fnTXD/QozPwj9LsvoanzcFvXpF/fB4eIkia07JY791icLnEoWPhjVliLXGEGvaECtniLXWEGudIdZFhljrDbE2GGKx30oarz8TvvU3zfob2i7SjQb6Gp02vkfFAxibJ8UFN5PMGs/FvveirbvxOh+uu/EaGcaY7Pdx3W015eFcU+qDMWaad3BwjTFurTBLedq7O5qOeI0Rx4+4dUupt4859UJ9tpafLxXq1WolX5md62dOzXMsLCfjMdv57kXK2Z1qhYwipzYeC/8syWorT2c8jtvPjboU/Uz50U8+zn9pzwFEnjVe5MmXxFZyCm+RVcY9nI8j/RToEOnxWsrjvfeSD9DmGznKc4nn6tocCe+NXCAsbb6FepM2dT5llnSB9pqJ+Cu4fI9lxPaMevZhwQexZK1B60/u3+7W7/xAqVSUeqxR6iG80a7s+s5MJa2vE/7ZwGtfLsTZMOqH5x45RdZc0GvDR8MOXZJ9Ix8N69yQYp02xHrOEOsFQyxLfZ0xxHreEOspQ6xDhliWdTxriGUp10lDLMv+aNmOpwyxLPvQS4ZYlu1oaauvGGJZ2teLhlivGmJZ2v2w+hzLOr5miHXYEOt1QyxLfVnGJpb2NaxxoaXdD2ssd8IQ61lDrHdDLDesdm8ZmyyPaf1hDWssN6y+0DKWs/SFlu1oqa9hjb+OGGINa/z1pCGWZd+27EOW+rIchyz70LDq3tJ/Wa7LDevakKV9Wca+wxpjDuPY4a75mZXF2DEdgY3Xcc+GNT4ZRWbtmTLuNZkMeutr+VxZ8Nd5wpd6a/tQsU7Cn58xS772V7A4T3hlCcu4boW4usU9i8bn7qiDKKy1fWJNKnk+2jQXU2/kPxUjq1aPKUOdjBti8dluWv/Xnt8KvbZ/WrOTuP3T0ra4l9CwbYtxbavtwXZ7FmRfVr2xcOC2m/feFlAaJT2I3j5JdPIewEjQ2zfWRmAF9PuTdG8U8DAtlX+fUsoJnec9Q8W0/lL4ZxWd+PCXa1LqVdtvtIZ0jv1nX9i5Rlo+f9MlfjdHG2/8jr2zpbTtI/yXajyL8+sucfuk8esuHQs7dIP4Ype+Yoj1giHWaUOsk4ZY5wyxLOt4yhDrkCGWpU2cMMSytIlnDLHeDTbxvCHWWUOsYe3blrq31NeThliWdXzWEMuyHS3t/ilDLEu7f9oQy9ImXjPEsrSJ5fjrneGjLcfaxw2x3g2+8HVDLEuf84Qh1suGWJZ9yFJflmPasMaFwzqmDevcylL3ln3IUl+WPnp57HhnjB2WcytLX/iiIdbymsKF60OWures46uGWMM6H7LU/RlDrGFdL7SMc5b9xIWLJ5b9xIXT/bD6iTTxF57/z2cvansbBGtdAhafvYjl05yzh1ifICxtj4eUWx/BB88b0c7Wc2kq6K1bpvV3UsG33q+E/KROeA/5Z5U6+njOrp1biPrh5+wbFFlzSh7aFuYhnw0KHw1rLcmAdr5E7VdcbPut9SNPbPtp/qPf9os6y0rygyHWuafvpMXqfGJAnbt0b/jWX+1cT973p8mwXpEhp5QXOo3PugH5rEvJZ+2AfNam5ONDb/xb29slbSl9BNt5d+tvfrBUFvvaSHIhX09nl6bum8I/S7L66pvaGbWoH+6bmxRZc0reBtKrh/YsXcCzcVO35zvlbFxpv2lFr3x+qCbDJkWGnFJ+Uwyfiwfkc7HCZ1Ipt7v1Nz9QKpVZx8Ib+W6G+xfCPoV/Nuhtcx/2uZnkYf2wfW5RZM0pef7bM9+cUurA7bnFj/5St6fwzwZe7avdnltIHtYPt+dWRdackreI9izWmoXSTKMyk5+tlmfqs6VivVjJ18szzUJhrlCcL8+VSs1aea4+Vyw1i5VibUqpA7fnVj/6K6dtT+GfDbzaV7s9t5I8rB9uz0sVWXOU55LEdxklb1S5NxKBxWPCIFguyTdEPI4DM2z7IjvyxfpdCL8h/LOBV7svxLUZ6oft7DJF1pySt4nKYXsujc5LC4vVuadYNVbnWrzUj85deizs0HHeqHJvJAbrhCHWGUOsZw2xThtinTLEOmSIdc4Q66whlmUdTxpiWdbxOUOsFwyxXjbEsrQvy/5oaV+WvtBSrucNsSzt/t1gE08bYlna10uGWJZ1tNT9k4ZYlnb/oiHWsp94Z/gJyzq+aohlGU8Mq+5fM8Ra7kP9YT1uiLXchy6c7i3n7pZzZD5rDNeQ+DlYv+uSWF7oND4XD8jn4pR81g3IZ11KPmsH5LM2JZ+JAflMpOSzrLduPmn19k7rP++0+lwyIJ9LUvLZPCCfzSn5bBmQz5aUfLYOyGerwmdSKbe79bdQKhXy+Xql0Kw3SzOV+eJCYbY0O9ssNyuzc+V6c6ZcrVcahXK1VJxvVPLNwlzj/FPTUq0y25yv12ab2jfs5Ztzri//9WXd9ZFviOKeYvxm5wjkI/2Dl3cw/6aFyd8sDeB6kvAygeVzkmLq710L/yzJaitP57nNCMnD+uHnNqOKrDnKc+mxsEPHeaPKvTiss4ZYLxtiPW+IdcoQ65Ah1iuGWCcMsZ41xDpjiDWs7Whpq5b90VKuk4ZYpw2xXjLEsrSJJw2xLG3iRUMsS31Z+i9Luc4ZYlm2o6Vcwzp2WLajpe4t+7ZlHV8zxDpsiPW6Ida7Ydy27Ns+xlqZK+N8Tr6nPk3l3PUqyhuDPMTAPJRvLEY+LD8WUY7rIfNRX+/PCf5KP/jtbwKsUHSFdRL+Mr8cB/pMxF/B4jzhlSUsa93F1Q3lZztYAfLwuqeGtaJPrEklz0ebTsTUG/lPxciq1WOMdKL1s4yiE7m/MkYupJ9WeEtZ0eEk5BnqsBinQ+yLwn8x31MQve0iOjlzYCTotcEVEVgB/d5F90YBD9M0YWh+lPtzVPvmIsq7NBXDZ0opJ/VbBTJeAfkriccVQa+MV8TIiOWFTuOTGZBPRuHDWNqaqUt3hJ18pD/SWjN1dXh1SzfmNkU+ra3k/pUK/TagEXk03VyZopxLUwovkUn68VVw39oXIj+RF+8h/yzJ6mtMuorkYf1w39iuyJpT8tgvbFf4bFf4aFjSntNBb/vy91c0u9sWw2dK4ePXFopl1iUmyduh1FHyroY8tA9Oo/Qb6+T67LM7OrhMx/KgzkW2YdPTNsq7GujlnBrJuwby5L2rxejwm33oENtK5BafKt+aOdmqhBtrv3F5N42cWfAL8KzqW5d389im1Gsq6O3r/P2a7Uqewz/eApS+h7bHYx/qe1S5Fzf2XR2BNQZYk4AlZxiNE/3fa+lDbPMawLWzzdmK6O1akInHkus88U47lgj/KUUekTur5I0NIGuzNpcv5Wdn643Z8sJMuZkhfJGV73E8sFOh174hJLreFXjRdbH9ncWwg78T9OrSGORdR3njkCcyOrtfs71b/p2e5E+jf+SfU/LwDJx+2jKn5N0S2mChP7DAWrFIrHVBd39Cn6P5TN6P1a/PxPJXx/BZOyCftQofvz61OKf5VEmaD+Nvfu6MqD8nbUyXOrm++V/7GNNR5yLbdNCrJ16/uYbk4Xtx+9aETtoDbc+wPeZZ54FS/51KHSUPfTLqiZPWHlIn1x4rru7gMh3LgzoX2YZNT9dQHq6R3Bp2510Pef3GqajDUh86xLZiHfqJaYpV1lOgyLVL0QXryV33OyeSOjk9hYu0tV2Uh7Ymsk0H0T5ssWPYOqUeGp+1A/JZq/DxG7sUF7R2l6S1O48HN0TUn5NmE1KnfscD1Dm3u+YrM0Gv3Y8q9+LGA+6jfmLhzhk16JO4/jcodZS8GyEP9cRJaw+MnfsZD1DnItuw6Wkn5d0I9Dwe3AR5/Y4HqMN+xgNsK5QbZR8L9NjmU+Fbf8eJfvMVb/11NrLpim5+uKYjvB3dZ4lupyK337ZNv44r/LOBTx/ZWcfdRfJE+Q/Nb0rZnJLH3z+/XuFzvcJHw4obn/j9hH7Hp40Kn2Hr5xspD/0h2genpL787CLHp2H1h7xuhf6Q13Gt/GE/67jamMJ2m9YfCv0PXvHWX8/+K7+O6oW8tHnMsPtVP/OReL+q+aF+/SrODwb1q2KPWpzJ72P1G2derPAZNn9xMeVZxZnPDugT3k5x5jD4VW1sShsTpo1HPx2+9Zfj0S9c0cH83BXRcu0A3q8T3XI8+vaKR6Utp4NeG+N4dIfCZ0cMn40Kn+V4tFce1Pmw+s0dlPd2ikdF9rT+UOjDK976Owzx6A6l/n6fRaX3q8I/G/Tasw+/qj030vyQ9gxGyuaUPI5HNf+9S+GjYXE8im3E8Wi/z8EuVurj+flOX88mUEZtbEP74JT0DKcfv6o9mxg2PfFzMPTH7FdvgLxBnoN9c5FjU9QcOSkmvEbh4bcd8o20vov3AHnypW3fdS3JE9XX3R52Oefotsb+jx5Y2HN77UONB/e99676R6v37r+9uue99fq9jX37sDbIYUqpLVsL08h1TrmPGDsTasFf6sNW3klYuxKw+Et9WH4XYV2fgMVf6sPyWBZ/jwe9csruwJEUONxzNbluJbnQW3I0c2MC1n7CwvI3EtZNCVgHCAvLY1n8PR70ysn6isNx/woJct0XdsuVh/IFwiomYN1PWFi+SFilBKwHCAvLY1n8PR70ysn6isNx/8oJcj0YdstVgvJlwppJwHqIsLD8DGHNJmA9TFhYHsvi7/GgV07WVxyO+1dJkOuRsFuuWShfiSgX5cvQN2h9twL5mq1i22Odp5R7PLrOwX3D0ayednQV/tmgt118jK5zQa/+UD88M5hXZM0peTwzmFf4zCt8NKydhljXGGJdb4h1gyHWLkOsvCFWwRCrYohVMsQqG2KJH9NiLz7Jrt+ZN5bnmR62uZ3PKbXffsCxRJLkzSl11HwP+kVO2mxO6uRmcx+8poPLdCwP6lxkEz2hPV9IPfEsE+1LxmXJ+wHI63dGLPV1Ory/Dx2iPc1R3i6lrF/9pl+lE/7ZoNcWfIzFWgyv9WHRXVGRNafksQ+Pi5mQj4YlcZ02j+BTL/MKn3wMn82KzJ77WpF1iUnySkodJQ/9PdoHp6T+1M8qHepcZBs2PeUpD+dbvEqH8eYgPqmfVTpsqxLgsw6RDt901+bPmlwZBSdPtJI3opTlU1kxj09/1fwH3uP+tkWRd0opx34Z/cGF8MvCPxt4HScKcf5S06vWD4qkc62PZCgP+ZQUPhoWxwBx46qf+C79F0GF/1KNq9o4pH0RdCnsO6qdCzHylP3I037LU1u/0uIO9zbERNBrQ9paG8s9A/hyL03Mw+vi/a5bIhavi/e7bolYvC6u6YDXKT+07a2/Toc/uK2bRtZ03wM0P9y61sYs0YOj+wDR8fqwS5NBb/tciL4v/LMkq6++r7Uj6gdte0UQb2PYxlHPG25U6so2f0OCTGzzGi/NJoROswntqaSj+3AM3fUKHWOI/eLzLz6lQmg/2sJwsdrfvUbnKxgued5FktpmeRec790a2lpO3G6NC7l72AJrWHdk8A6updhp8Ed9rKtoz1HcU3DZSXL+Kfj559+frO65vV7df/veuz7euOdAY9/+MYLdESGO/OYNqsIKcYIYcV0aobxrKB8fR2kpzcYINKkLMS0R/ku1MSLp0T27iRsUWXNKHm5SiRqublD4aFhiK9rLW/xRkX5f3tqqyDxsm0C3Uh6GB2gfnCw3yy6/vNWhWexmWWwrDsG2Af09YXfeVVDuaiqHh9UJPh6eJXR4YOk2wrgM8q6ivMshbzvgn20RTisy8uFckufSqHIv7nCuqyKwog7nknYeJ/pvtSo9GfTqzc5mO4dzxYWiV3vinXaMYRtCeUTurJLn43CutIcDCb22aTfucC4/YaB+OBduKnVpDPKuprxxyMPQjQ/n8nSIXDGN/pF/Tsnjw7n6PehJOyRxUCz0BxZYKxaJJYdz4TRPfI7mM/kwln59Jpa/KobP2gH5rFX4+PWpxRnNp0rSfBgfxnJNRP05aWO91Knfw1i0MXs66NUTH8bS72G1E4qs0h5+lhiKs6zzQKm/dgCZ5KFPRj1x0tpD6tTvYSxanOR3PC5WtPlmEKOL7ZSH8xY+jAXn0/3Gr1Lffg9jQXu6lvKuVsoO64tSfto7/kUpbYzQbIDHW8xD/WMe8rlW4aNhXdS61l5AZZ/U7wuoE4rMw3aAI/skXIrs98BAPMBxsS+g8trDsOiJly/R7/CcWjskbzE67GdOrR2COUyHLqIuWE/u+kq45pS0zBsu0nfzYQzaErD2ChHHqP36n3VKPTQ+awfkszYln6sG5HNVDB/MY3/ab8w9ocis8dk+IB/tAwvD1Je0GGnYDjDF9uB+tl0p6/mFzNQxEr+Q6WcuF/9CpjbP0cYkKasdps19epCDuTlG8t2n306HKqN9cErqT88uch49rIcq85q5tsXH2if1EyNhW/Ejd1xPl3sY2/OhcUJ/XStwcTZyzZXd/LYBD3xmcDvRXaXIPaz+8Co/8sT6Q81/9OsPx+F6UH/I65doV3xoUb/rWBsVPsPWz/nQIvSH/a5jLdYfan357RSjDYM/1MYUttu0/lDoP9jybZ79l3poEa/FLceZ/uNMfgV4EL8aN6fjQ4v6jTMvVvgMm7/gQ4uW48x3TpyZNiZM63/50Dihvwvi0T0RcSbK4eh+6UpdfqF1adlv2vpNy3hU2lL7OCfHo9sUPtti+GxU+Lyd4tGl8puo82H1m9so7+00PxfZ0/pDoX96iOLRbUr9/e5RSO9Xeb/bNj/yFLS2i/ND2rNhKas9z+V4dJBnw3HzfI5H+53nX6zw8bxfpe99GByPamNOWp+A+1UWO88X2YZNT3H7VdivDrJfBXX4zUWOTeyTLGJCT74r9SGa7Lt8x4Sa79L6+uIP0cTdBlxbthamkeukQzSvSagFvziJrZzGyyIWvyyM5flFuusSsPhlYSzPn02R3+NBr5x8aF8cDvdcTS4+RBO9ZZpDRxGLD9Hs99BRxOJDNJfq0NEbE+TiQzRvgPJpDgpFLD5EUzvgU7DyCVh8iCaW58NG5De/eO4S6ysOx/0rJMjFh2j2+/I+YvEhmv2+vI9YfIjmhTx0FOXiQzS1wxS4XJQvQ9+g9V08nEGzVWx7rPOUco9HV0+HVqY+RFP4Z4PedvExumoHaGgHaonuZhVZc0oe7xrVDoedVfhoWNcYYm03xLrOEGunIda1hlg3GGLdaIhVNsTKG2IVDLHEj2mxFx+i2e/MG8vzTA/b3M7nlMriQ3AskSR5M0odNd+DfpGTNpuTOrnZXD+HaKLORTbRE9rzhdQTzzLRvvgQTTyYs98ZsdS330M00Z5mKO9apaxf/aZfpRP+2aDXFnyMxVoMr/Vh0d1Niqw5JY99eFzMhHw0LInrtHkEH6J5g8Lnhhg+mxWZ/dpCscm6xCR52kGhkof+Hu2DU1J/6meVDnXOh40Oi55uoDycb/EqHcabg/ikflbpsK3ygM86RDo8RFObP2tyZRScG4hW8kaUsnyIJubxIZqa/8B73N+2KPJOKeXYL3s6+Cy1Xxb+2cDrOFGI85eaXrV+cBPpXOsjGcpDPnGHDiMWxwBx46qf+C79oWTCf6nGVW0cijtE06d9R7XzjTHyeDoktn0ag7Z+pcUdeIgm2pC21sZyFwFf7qWJeXhdvN91S8TidfF+1y0Ri9fFNR3wOuVnr3rrr9PhB6/qppE13Y8Azc2ta23MEj04uk8THa8PuzSsB+h6Ovks9gBd7XA/PEQzysawjaOeN2gHnbLN70yQiW1e46XZBH4mmm1iG9BdC3Q/E0N3nULHGNohmtsoT2i/0MJwsRoforkt6MZ3yfMuktQ2y7vgtvmRJ3YXHOpnsbvgeE12kF1wljuRh3VHxjbKW4qdBv0coqk9R1nEIZrbIsSR33xwpbAa5BDN7ZSf9hDNuI0RaFIXYloi/JdqY0TSo3t2EzsVWXNK3lVwHTVcaV+217DiXlDnQzSvUvhcFcNnqyLzsG0C5UM0l18yeOe9ZIB+kA/RxEMu+QDEpEMuxwn/51v3pe22QXnDxw91thvhgby3e+Kd1tfyJkDtEAnNDw9ymGSxsVCbrVabpVozX6s2G5mg1+fG+WGh1za0bVLo/R4UVqqK3eNhkrwVbgzytlPeOOTh4V58mKSfcK5UTaN/5J9T6O8NO3T9tGVO4cOHNqbFkkMb0U9L39Z8DPdFP34gfdwj/LMkq6+4Z1vQq9cxRa9xm261w3T4JaF+4xHEEr+/1C8JoQyG43lZi78lSd4OpY6Sxwf6yjUnbcyWOg3ykhAfCDcseuJ+rh1Oq01b+417UIf9xD3YVnwo2zalrF/9pvdJHAN48pGFOF+h9eG4eEUbU66E60HHJ2nL6aC3bfkFmzGFz1gMn4sVPsPW1/gFG/RJaB+cLH2S1p+GTU9jlDdsPknz6yz7uEJ7BeUJ7b+BRy6rWkrS+sjqoDvvCshbBdfIF7cMCL1Ld4S6nP8elshv3aFjjkRgYtu4hHE99kmXxiDPztZqBSf317d05GDfOB5210nzZ1qMJfRxLwOhjnJBr12zL9V83Da4J49hNH3iepNLY5DnW58oI+vzyoQ6sT41/aOeREfaeHIZYV2mYKGO4/QpMl4IfaKMafSpjYNxcQDqU3SkzRkuJyxNn1fAvQ+RrFJ+QqFHvHGiX9lqVKebN7Z0y7cayrMtrFKw0YfG9bOsUo8pysOyDvevL+vcd2lF2I375l+4Nw64b9YP6SlvEvLGwm4+2dbvMeCDWCLHONFvgrHkzTpAGSmfU/hPEP8uuZV7aIOMNarcE3qn07UtGV1bZglH9L+79TvfZ2oslOcrC/O1mXw9P1+YL/FL+yiL4+/s72xrf2XcukdGwRmNwc4pWLLuI7EXHoxpOD8oCv4Kks8IvyB6Gg969SS8V3qpW7OZph2Qf5ZkNdZ1ey62kuRh/fD66qQf/TTclhKxPeyjE4puWI4VJGPWk4zaWCwyaWvAIoejWX9tt4wjnmT020eb7ecdOEe5O3zrr+NZoPFM2gZje7T7EchH+tntHcwyzTPY57q0CvJXKPnyW9prRKHlNekVpENNr0gvNjkRUdcJqqvQ/xDEFN/bomOi/lCukQjM9wDmq4SJ8URcnxf6VQo99jGRZzro7ZurqBzKPhl0J7yntU+GaHkMxucTK4h2RQQf1ocmw0oFh8dJxmSebA8ucSw3qvDBPoVj/qTC33B8mNHGSkmSxwdsYx7W/fNhh46TttYhdXL13bq9g8t0LI/W1yxjI7k/DveZ7yjRThAtPzdBGccNZMwpfCYId0WM/BnCGVPKTQV6f9T+ppU3o8irjTWD8kGsL4TdfLCdcUxr0JiGfnxUKfto2MlH+jtgTPtSyjGNfQnW4Yth5x77bI5juU/yfJjHLqbBcRzp9ypjF/sHxHL37kkRI2hxH8cIz4A+95M+tRhgOujVDdvwJPHC+FjGF9bBIyDHg9ujeYlep2Lq6O49ul2nQxmQjjG0sVMwtH4t5aYVubjvse+YiOGhjWcaj3HKG7R9tHEbYw0thtHycTxHPnxvRKFPij+yEdga7oSCo/n5lZSXUfLYh2F90YdxbKLNydA3av0uqu3iYm9N9jRx1USM7Jr+0A9Zr+Xk5/KFfK0y02wW6rPVhXLSWo41/+LM/Fx1fiFfKDaLxdLc7FLzny3PFubmqnO12VpzvlxbWGr+tfnZ5nyptFAozdcb84Ulr3+jXFpoFprn1/NKzXxprrDU/Geq+WKjXFhYmCk0qvPzzX7WEjX/jGMF9iG8j/1Pnm3yeP3LtNfNz1qbfuBpmjFOq5/mXz4RUb+/D3HAr21P5hfnM7WxcITy0C9yG4lNaTGVVgeh/y1l3UBb98I1N5fGwu767W7dzw+WytozKJyvj4fd9Y5bq3CJ4+TVCj0+q+GYBp/x8FxuXMHSxiW2s4lAj3sFj+3sD2OeQaHNZ0l2rDvHCqMK37g1Difnv6D+7Om5QEVbU5A0FejxDeZhP+G9RbxWjHloB/3uwxNdOLn+PMUahuYn2Bdo636an8A9KW/KF/bKdSH6LcbY3G+1NUmkl76TC3rbje1Vix21PsAx52gMP22+hH0g6pkc+gRcU/hXKdYUsCz7a6H/7zDm/Fsac9A/sb1ofoZlCQLdj6VZa9LmrtIu2nM+y7XLDPGTeuA95J8NvPqvAvt71GvcszZP8VFZ5NHmvFo7u2dza4LeNtPm17jOysfOamufmm/j+EjzbVpfZz+gzVnj1ibi+jo+X0oTO2r9mPt5l03seOuPy794R3f9kV/UOl8QxLdhXJujfnktRnteE7dOE+fPV8bIlfSMieXSnjEFCu+kOsTZnRZfX8AxdUYbU7HuPKbGxbYucRtMKfRavJsjetR53NqT1i9XUV7afolx6MW091Mbv9DP8vqQ1j9xjMZxPUOyIA9cP5OjhzPEY0KhR7xxor98R0eGN7bomOJrXHok7MVkmfE+6oXn7UJ3FchwzbVvXad518rT3pXU7z2295gp+vAxvmvzP23/o+f5Ui2uH2hxH8+vuO2wD0ftQ+DnnDg2oN/ndftCy7ZyhOmSnHOQUfK0Z1q4V2/Xju66+Xq2yvv/o/bFzJKPwv6u7Q0Q/8F98QchTpinOEGz/VVBvM/S9uKw/UTtZ2GfJfTvifFZ2jwH5Xok1DF/FDB5P4tmF1r7sS27pNkyPy/UntNp7zxgf3oTO+zF9Bwj1LUYAfXDMUKcLlzqN34U+8gRPepR60e8Bhpnqy7F7Z3BfdDS78zX+AuFQnO2vDA3Wyvmm/XaUq/xl5uV6myzkp8p1suNYr26mP3CUWsTn42Ip/pdm7gHfNXnyFctr0101wPvIf/ltYnltQnMuxBrEwegH59eXpvowtDkWl6b6K07xx3vlrWJ057WJj7rKa5plouNxsxceWHh/FWhXugnrsgE3brAOmaUOoota7FbHNZIDFYmBms8AYuPvI2K7bkcxw6e1j1SH8HJ6x5+3jWJX/dA/fAzVy2+ywXJ41e/sZ/2LNUCi+f8iB3VN7TxFnUUEB/eL+7Sx8O3/vp9zym/oPnvgOq8WpE5o9CPKnXE96J+A+YkTMc8UXerKQ/HyinKw1hgDeXhODpNedr8IE0fdCnOfsYj6mXBR5tTa+sAg/LRYm3WtwUfLY7XYiDu33H7eTU+GYWPtsaN8+S/u0PnGbW2xfNkof9nEF//0Y5uGtHR/wg0/2vrelKR3dAPzGv7NgLSDfognl/j/hm2efQfbKcYu7FtrQEZ8H0vTprfETqH+Scp/I6ma09j6VDpOq0+RReu3GraKxgoWNp4KXXCdeq4foR8uR/9OfSR/0x9U5vzaX5H7ifN+XiNWJvzDes4rbU928wayGObmYY87p94tD3qhFNSXJC2f/7nCB8sPNgH8/wqat72d+F5g8/5zXgCVpo5SRxW2rnS8vymJ72t5jdjhlgZqg/qPmnun2TPbINxc2wst0Q2mHp9nm0w40eeQlq9LtYGLe1m2LEs3wXPRciJfKL2Amy9uruMlIvaC8DzBqHfdnUH8/LWddr3ibmezJPfVdD0r/lAoY97Rw95ac9f4t4VjXoXCXWHdZPnPPxM47qWvpLec7mQ6+dL+dxedKY9t2f/EXcmwKiCiTa/vCa2vCa2vCam/03LZ5jXxD52tc4zak2M/bPQ74Gx7daru2lER58EmmrrenlNrEPHyWpNjHW9vCbWoRm2NbG90EcOUt9cXhN7Z66JHYzwwcKDfXDaNbGPKTGc0OG7CGiPLsk+bp6/vOeaDvYx8vGC9wTY7/Gru+XEen8q7M7T9iW5ez/U4qn5Lvdvd+t3fqBUqcbFMX73GJZraeIK5L9UZ42m3WOoxai83wbjqeNhh47zRpV7IzFYZw2xzhlinTbEOmSI9bQh1glDrJcMsSz1ZVlHK7k0PzgstvqiIZZl37a0iecNsZb917L/8llHS92fNMSytPuXDbEs+/aw9kdLHz2sY61lO54yxHo3jEPvhjpaymXpV4d13A4NsSzlstTXVwyxzhhiWcYmwzqmLffHC1fHYR233w3zNEubeMIQa1jt/gVDrGFd63jFEMunjxZafLYhZxq5dE/rmp9RzNMzAU/r8vW4vQB+v69VTn1mEj/n187Azyp5g7xzulBolhr5hYVycaE+Mzs7myF8kZXv8Zpl2u8aia5X+dH1graPLAt6dWkM8iYpbxzyREan+zXbu+X38wy1vJBG/8g/p9Dz2U1p23Jd0G1r2B+15357w+68CUUGfO4Xt09Ne/6J71y//5qOrFiO7Uzb78h79Ucj7uN1hu4jX+T36bC7HD9zZFm4vqOKnJouRhRdaPsXRgkD+ynuRXVt/A7bP95I62eHdf+457Pp6myPKE/cfsALcTbdT7dsXNvfF7UPOVBkEN5BS5ZPUN+50PvRv3hNdxkpF7Ufnc+mE/oG7Oeota6X96N3143PtxP6L7f05WxvCPajN5wc7+T96F8EfS/vR++t4/J+dL1eFnyW96NH+wDr/ehnr9F5Ru1HZ/8s9L8CY9tL13TTiI5eBppv0JoCym7oB5b3owe9ul7ej96hGbb96L8GfeT3qW8u70d/Z+5H//0IHyw82Aen3Y8uvt36DLxKsTZTLc3M52uNmUp1ttLPGXjLMWSHZjmG1OtlwWc5hoz2JdYx5L/qM4aMOucruLaD+W8jYsh/B+PjXy7HkG+mpYgh/3I5hnwzvR1iyFHoR2uv7dAjnyBYjiHfSTEkt7NVDPmvoN+/eS/s0Bm2YVHqMx52ZBbdjIUduSdAbpdWQp7QiayTfmTNi6zZFr70T+SJdRkher4ep3tXQ1tiHaUeeA/xhX4V5An9KNwTGcV+JyBvVdgf1krCWjEAlsiVU+hXLFIuDWuCsCYVLLyHz6Y2tdrGxzdLqpXGfHm2VKyVmvPVufxc0rzq/wfvokIWvmcGAA==",
      "debug_symbols": "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DWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENsPmkygXFrCCDeyggAoaOEBsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGltjZ6OLYwA76TTgnDbKgETQvGuedTKcSVINaUA+SIA2yoBEUjhKOEo4SjrOtzbGDAvomnI4GHpvQb8n77MkLva0vLGAFG9hBARU0EFvF1rA1bN7WPkPAZ08u7KCAChroNt863tYneltf6MO4TjWoBfUgCdIgr3gcLv5iyu6zFnxaZPdJCT4tcqGACvqS+l7wJr1wBnqTXlhAv9Hl1IIOl99S8EmRCxU8XD5m5JMiF85Ab9HzSPIWvfBYs1PhLXphB33NnDTIgkbQXOTdeZJX9M3mP97ndvUf7zYcBzgD/cf7wmNJffKET3Fc2MAOCnjYfPH9t/uk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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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r4JeBb0KehXst0dxfelV0KugV8H9YLB/FfQq6FXSq6RXSa+SXiW9StZXyfoq6VXSq6RXyfoqWV8lvUp6lfQq6VXSq6RXSa+S/fbk+8GkV0mvkl4l94PJ/lXSq6RXSa+SXiW9SnqV9CrZb0++H0x6lfQq6VVyP5jsXyW9SnqV9CrpVdKrpFdJr5L1VbK+SnqV9CrpVbK+StZXSa+SXiW9SnqV9CrpVdKrZL89+X4w6VXSq6RXyf1gsn+V9CrpVdKrpFdJr5JeJb1K9tuT7weTXiW9SnqV3A8m+1dJr5JeJb1KepX0KulV0qtkvz35fjDpVdKrpFfJ/WCyf5X0KulV0qukV4teLXq16NXifnDx/eCiV4teLXq1uB9c3A8uerXo1aJXi14terXo1aJXi/32xfeDi14terXo1WL/arF/tejVoleLXi16tejVoleLXi322xffDy56tejVoleL/avF/tWiV4teLXq16NWiV4teLXq12G9ffD+46NWiV4teLe4HF/eDi14terXo1aJXi14terXo1WK/ffH94KJXi14terW4H1zsXy16tejVoleLXi16tejVoleL/fbF94OLXi16tejV4n5wsX+16NWiV4teLXq16NWiV4teLfbbF98PLnq16NWiV4v7wcX+1aJXi14terXo1aJXi15terXZv9rsX216tenVpleb+8HNfvumV5tebXq16dWmV5tebXq12W/ffD+46dWmV5tebe4HN/vtm15terXp1aZXm15terXp1Wa/ffP94KZXm15terW5H9zst296tenVplebXm16tenVpleb/fbN94ObXm16tenV5n5w06vN+mqzvtr0anM/uNlv3+xfbXq16dWmV5v11b7XV/3wu1+3s8MDnnDACS94w+8+4X6PhLa98C68C+/Cu/AuvAvvwrvwbrwb78a78W68G+/Gu/FuvBtv4S28hbfwFl7uBzf7V5v9q02vNr0qelWsr4r1VdGroldFr4peFb0qelX0quhV0auiV8X3g8X3g0Wvil4VvSruB4v9q6JXRa+KXhW9KnpV9KroVfH9YPH9YNGroldFr4r7wWL/quhV0auiV0Wvil4VvSp6VXw/WHw/WPSq6FXRq+J+sNi/KnpVfD9YrK+K9VXRq2J9Vayvil4V++3FfntxnqFYXxX3g8X+VbF/Vey3F+urYn1VrK+K9VWxvir224vvB4vvB4vzDMX6qrgfLPaviv2rYr+9WF8V66tifVWsr4r1VbHfXnw/WHw/WJxnKNZXxf1gsX9V7F8V++3F+qpYXxXrq2J9Vayvil4V3w9yvr1zvr1zvr1zvr1zvr1zvr1zvr1zvr1/3l71z9ur/nl71Tnf3j8N73ueoX/eXvXP26v+eXvVOd/ePw1vw9vwdrxvrzrn2zvn2zvn2/un433PM/TP26v+eXvVP515HngH3oF34B14B/M8GO9gvIPxDryT6zuZ58k8T+Z54p14J96Jd+KdzHMw3mC8wXgDb3B9g3kO5jmY58AbeBNv4k28yTwn403Gm4w38SbXN5nnxTwv5nnhXXgX3oV34V3M82K8i/Fuxrvxbq7vZp4387yZ54134914N97CW8xzMd5ivMV4C29xfYt5LuaZXnG+vbd3fdUbvWr0qtGrRq8439453945397bB+/7/WBv9KrRq0avON/eW8NLrxq9avSq0SvOt3fOt3fOt/fW8b7fD/ZGrxq9avSK8+29dbz0qtGrRq8aveJ8e+d8e+d8e28D7/v9YG/0qtGrRq/axDvx0qtGrxq9avSK8+2d8+2d8+29Bd7g+tKrRq8aveJ8e2+Bl141etXoVaNXnG/vnG/vnG/vLfEm15deNXrV6BXn23tbeOlVo1eNXjV6xfn2zvn2zvn23hbezfWlV41eNXrF+fbeNl561ehVo1eNXnG+vXO+vXO+vbfCW1xfetXoVaNXnG/v7b0f7J1edXrV6VWnV5xv75xv75xv7/3db+/9/X6wd3rV6VWnV5xv773hpVedXnV61ekV59s759s759t773jf7wd7p1edXnV6xfn23jteetXpVadXnV5xvr1zvr1zvr33gff9frB3etXpVadXnG/vfeKlV51edXrV6RXn2zvn2zvn23ufeIPrS686ver0ivPtvQdeetXpVadXnV5xvr1zvr1zvr33xJtcX3rV6VWnV5xv7z3x0qtOrzq96vSK8+2d8+2d8+29L7yL60uvOr3q9Irz7b1vvPSq06tOrzq94nx753x753x774W3uL70qtOrTq84394539453945394HveJ8ex/vfnsf7/5V53x753x753x753x7f86398PXeOPL9/3gPny88zz/6tU8z796Na/nH+/3f5XX7/PtNx/v9/8O0+/z7Tcfb1yvXy9fvcrz+lev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p1edXnV61elVp1edXvWNd3N96VWnV51e9cJbeOlVp1edXnV61elVp1eDXo3P6x2fDg94wgEnr7PgDeOlV4NeDXo16NWgV6PhbQkveMPvPI+Ot+OlV4NeDXo16NWgV4NeDXo1Ot7xgZlnejXo1Rh4B156NejVoFeDXg16NejVoFdj4p1cX3o16NWgV2PinXjp1aBXg14NejXo1aBXg14N1leD9dWgV4NeDXo1WF8N1leDXg16NejVoFeDXg16NejVWHgX15deDXo16NVYeBdeejXo1aBXg14NejXo1aBXY+PdXF96NejVoFej8BZeejXo1aBXg14NejXo1aBXo17v/HzgBnd4wK93fgJOeMEbfud50qtJrya9mg1vm3DACS8Yb8NLrya9mvRq0qtJrya9mvRqdrx9w8wzvZr0ag68Ay+9mvRq0qtJrya9mvRq0qs58U6uL72a9GrSqznxTrz0atKrSa8mvZr0atKrSa9m4A2uL72a9GrSq8n94OR+cNKrSa8mvZr0atKrSa8mvZqJd3F96dWkV5NeTe4H58JLrya9mvRq0qtJrya9mvRqbryb60uvJr2a9GpyPzg3Xno16dWkV5NeTXo16dWkV7PwFteXXgW9CnoV3A/GZ8ATDjjhBW/4HW/Qq2h4W4cHPOGA8Ta89CroVdCroFdBr4JeBb2KjrcnvOANM8/cD8bAS6+CXgW9CnoV9CroVdCrGHgn15deBb0KehXcD8bES6+CXgW9CnoV9CroVdCrCLzB9aVXQa+CXgX3g0GvgvVVsL4KehXcD0biZf8q6FXQq6BXwfoq7l7F4eP9/nnqeZ1vf/h4x3n9q1c3B5zwgjdcL1+9urnBHca78W68G+/Gu/FuvIW38Bbewlt4C2/hLbyFt17vdb794QZ3eMATDjjhBV/edbhevnp1c4M7POAJB5zwgo93nvdw9eriq1ffc3fzOt/+cOc5A548J+DkOQu+vPMw3qtXN+O9enUz3qtXN+O9enUz3sF4r15d72HivXp1M96rVzfjvXp1M96rVzfjnYz36tX1HgJvMM+BN5jnwBvMc+C9enUz3mS8V6+u95B4k3lOvMk8J95knhPv1auLF97FeK9eXe9h4V3M88K7mOeFdzHPC+/m87zxbsZ79ep6DxvvZp433s08b7ybeS68xee58BbjvXp1vYfCW8xz4S3muV7vdb794dd7nW9/ePCcCcfv93Cdb3/48u7DG66Xr17d3OAOD/h4v2cL53W+/eGEF7zhevnq1c0N7vCA8V69ijic8IIvbx6+vN/v06/z7Q83uMMDPt4883z1Ks/cXr26ecEbrpevXt3c4A4fb555vnp18/GuM/arV+dMyHW+vdY6vOF6+erVzQ3u8IAnHHDCeANv4E28iTfxJt7Em3gTb+JNvIl34V14F96Fd+FdeBfehXfhXXg33o134914N96Nd+PdeDfejbfwFt7CW3gL79Wrc67mOt9e+3yurl7dvOH6zdf59ocb3OEBTzjghBe8YbwNb8Pb8Da8DW/D2/A2vA1vw9vxdrxXr855oet8+8MTDjjhBW+4Xr56dXOD8Q68A+/AO/AOvAPvwDvxTrwT78Q78U68E+/EO/FOvIE38AbewBt4A2/gDbyBN/Am3sSbeBNv4k28iTfxJt7Eu/AuvAvvwrvwLrwL78K78C68G+/Gu/FuvBvvxrvxbrwb78ZbeAtv4S28hbfwFt7CW3jr9V7n2x9ucIcHPOGAE17whvE2vA1vw9vwNrwNb8Pb8Da8DW/H2/HSq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9qrdX8Xl7FZ+3V/F5exWft1fxeXsVn7dX8Xl7FZ+3V/F5exWfD96Gt+FteBvehrfhbXgb3oa34e14O96Ot+PteDvejrfj7Xg73oF34B14B96Bd+AdeAfegXfgnXgn3ol34p14J96Jd+KdeCfewBt4A2/gDbyBN/AG3sAbeBNv4k28iTfxJt7Em3gTb+JdeBfehXfhXXgX3oV34V14F96Nd+PdeDfejXfj3Xg33o134y28hbfwFt7CW3gLb+EtvPSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0atGr+7z7d+/zznu8+3fP7cS53x7/3z/bHic8+2/Ob/8/TPdcc63/+Z9OA/Xy99e/eb25X6831798HnNb69+8/F+v2uLc779Nx9vj7//+sP//ue//fmf/+Uvf/pff/hv//nzr//jP/71j//+57/+6/2v//5//u35lX/525//8pc//89/+re//fWPf/rv//G3P/3TX/76x++v/eFz/+Mffu6r69fPjfPnH3/94efd/cPP2mr/+llI5c+/j/PrP9uRP0+K769/f+Dny5nx6+cf+/vA+Ymf/5z++vlH/OPfz0v85/m5ny+ZZn9+JtqvyO8v9+8vn4d6+9XPQ+P3Qz9z1Nv3ofm8SN+/xn5e5GdLeNb3l+P//Yl8X3f+6udZ631o/Rr9+9B+f7B+9fl9qJ556OPnByPuUf9sW67f4v7V/Hju8faf7z57X2e0v6exr/HjnfeP/+zy5uf3j/9MYL/+9fx4fkc+zo+358d/Pv2/fj4F94///N7/9fP78HmBn9+GP//6e75/PiE/zz1z1/p/9QXG7wHMn0Hm+j3Z61f09y3vX319zg/Mdw7XzzScx+L/f9Hbe3XyZ2Liedm9fu2fS/X3v//j3/8v",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgACgAMuAgANgAQuAgAMgAUlAAAIiy0KCwIoAgADBIB4JwIMBCAtCAELJwINBCEACAENAScDCwQBACILAg0uAgADgAMuAgANgAQuAgAMgAUlAAAIiy0KCwMuCICYAAQuCICZAAUuCICaAAYoAgAHBICbJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAHgAMuAgANgAQuAgAMgAUlAAAIiy0KCwcoAgAIBIC5JwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAIgAMuAgANgAQuAgAMgAUlAAAIiy0KCwgoAgAJBIDXJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAJgAMuAgANgAQuAgAMgAUlAAAIiy0KCwkoAgAKBID1JwIMBFotCAELJwINBFsACAENAScDCwQBACILAg0uAgAKgAMuAgANgAQuAgAMgAUlAAAIiy0KCwolAAAI0SUAAAleKAIAAQSBTycCAgQAOw4AAgABAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAjQLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAifJigAgEMAAQAoAIBEBAADKACARQEAACgAgEYEAAAoAIBHBgAAKACASAAAACgAgEkBAAEoAIBKBAABKACASwAAASgAgEwEAAIoAIBNBAAEKACATgQABigAgE8EAAcoAIBQBAAIKACAUQQACSgAgFIEAAooAIBTBAALKACAVAQAFygAgFUEAB4oAIBWBAAgJiUAACHQHgIADAAeAgANADMqAAwADQAOJAIADgAACYIlAAAh+R4CAAwBHgIADQAKKgwNDiQCAA4AAAmeJQAAIgsnAgwAAi0IAQ0nAg4EAwAIAQ4BJwMNBAEAIg0CDi0KDg8tDgwPACIPAg8tDgEPJwIPBBAtCAAQLQoNES4IgEwAEi4IgEUAEwAIAA8AJQAAIh0tAgAALQoRDgsiAA6ASAAPCyIAD4BFABAkAgAQAAAKFCUAACPrHgIADwYnAhEEEi0IABIuCIBFABMuCIBIABQtCgwVLQoOFgAIABEAJQAAI/0tAgAALQoTEC0IAQ4AAAECAS0OEA4tCAEQAAABAgEuDIBGABAtCAERJwISBBgACAESAScDEQQBACIRAhInAhMEFwAqExITLQoSFAwq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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZSc13Ue+FdXN4AuoNGFHeAmAlxFilRtvcmWBe0LKXHfSRHVXVUUFxEkAXCVhJJEUeJOgCC4b5JIZzxxxnaOk4wdHWeyjSYe5zhW4hzHTmacHGdyTjJzknGW8Rw7CR5Zt+qrr+7//r+67uuuBvudQ6L6f+9997777rvvvuW/fyZ6P11z4r9M6/do69+1rX/d801Rd5Kye1v/FgZLRUOsQigeMyuAx5EVwGN2BfA4ugJ4HFsBPK5ZATyuXQE8rlsBPI6vAB5zK4DH9SuAxw0rgMeJFcDjxhXA4+QK4DEfgMcQfG5aIXxuNuQT/eZQ/G6Jhl9Ht64AHretAB63rwAed6wAHneuAB53rQAeT1kBPJ66Ang8bQXwePoK4PGMFcDjh1YAj2euAB53rwAe96wAHs9aATyevQJ4PGcF8HjuCuDxvBXA4/krgMcPrwAeL1gBPF64Anj8yArg8aIVwOPFK4DHj64AHgsrgMfiCuCxtAJ4LK8AHisrgMepFcDj9ArgcWYF8Di7AnicWwE8fmwF8PhzK4DHn18BPH58BfD4CyuAx0+sAB73rgAeP7kCePzUCuDx0yuAx8+sAB4/uwJ4/NwK4PHzK4DHL6wAHr+4Anj80grg8ZIVwOOlK4DHL68AHr+yAni8bAXwePkK4PGKFcDjlQF4DMHnVSuEz6tXCJ/XBOIzupaYHjnxn3spyr105F7qcS/NuJdS3Esf7qUK99KCeynAXbp3l9rdpXF3KTsfvf9inrus6y7Augum7gKnuyDpLiC6C37uAp27oOYugLkLVu4Ck7sg5C7gnHniv90n/nMXNNwFCHfBwB3guwNydwDtDnjdAao7oHQHgO6AzR1guQMidwDjWuUOENwGvdsAdxvMbgPXbZC6DUi3wec20NwGldsAchssbgPDbRDIAtwtIN0CzS2A3ALDOfDOQXYOqHPwnAPlHBTnALgJ1k1gboJwBtgZOGdA3AB1yu8U65ooPomCXHzu+/+Ot/4egXzDl9OK40TXEn+20GiMK+0z5L883sJcFwR/alrwx8PwX5AXWP+HZgcf2yJ0s61/f6PZkeVvNLt5kjJ/DmX+nMpIe8L0d3UurLyK770wgzKKoC1COxeGdilD9LBfME/o56KQuvn+y75IT/hh+YjtmJAyzQ4/Gcobbfa2Q/LGIE/619G5AMqxbq2jPOHFJdHfCZCNpN9s5UmfjgKmnb7OL4TV10ph+fS1UjwZ9XWU8kabve3oV19Rt1hfx6JOElsqeWsg7y8oby3k/ddmh/YU8PErrd9hbfL7czCOPes5bIvCP9JyaW2zIw/RwSw8GwP5vScfLE9545A32uymk2v9PQp0EEv4GKPyldbfk61/10AdqZ9X6K8h+l18K89YLuNK+XGlvNO1i1q/nZ8t+vzpZgfPMiCA4H8mDH7b7/xsGPyS4H+u2ZFlB7tRmSnXZqrTC/OztfnyQqU6O1OpzlSn5qaLxVq1UJubK8yXFgrVmcbs1OxUvVGcr9eLC3PVRmF2qloW7M+r2OX6/EyhPFWdnp0vNqrTjcJ8ZWa2XG3MzNSqtblKfWaqUCsuTBcXSsXG7Gx1aqq6MDVXLDbqc1ON2WnB/oKKXZ+dXZibn2kUGtXGXKlaKBVK8wu1xlRh+gSNRn1hqtEoV+YKU+XZWnWhNrNQnFsoz5YaC/W5RmGuzfcXVexaaaraWKjV5iuFxlx5pjoze0I2czPzJwBmi+XpYnVh7oTMGsV6dWFmYb5aP2FYyvVitTZTrM2UpwT7S81Of9rZmA7+JUHwO/p4aRD8Yns8fTmMfOYF/yvNSOnb2WL1hI7XapXibG2hVi7Uy40T2j1brdSmi7NOPcuz87Xy1Ez9xKAozlZnSlP1qelq9YSeVheKbdlcpmLXSzOVSnmuOFMpzkzXytP1WmF2oTFbKxerxeJ8sVZrNE6MrfkTit+YnpmbPqGb9YX6TH12fvrEAGjr5OUq9mBJsK9QsIuz5VJppjw3U5ibrRWKldpCabZUcsp/QjALpfpcpTjXqJQq5YXaCSNRma0W3aBbmGvMdmNfOTjfxTi+r2qG0JWObbw6DH5F8K8Jg9/WmWsBPxPZ24LrwuC3+b8+DH67f28II//2ns6NQfgvt+fAm4LwX27r580t/MhONu156pZ47EWbHsH+qoJdqpYXCidm+erUCfNdn506YZdPuC/1+dl6Y7pUnV+oFEq1YrFYr5z4X6leq8zNnzD989P1E6Z+/gS5ts25NYjMiwuCv88Yf7pamKtPT88IftUYf35+eqZ6Qp6CP2+MX16YrjfKM+0xu2CMX52qNBpT5arg14zxp4qF+lRppq2bdWP8ufkTm7AnvF7Bbxjjn/DBy7W5att/us1aPvP1wkKtOCdr16+18IWGS0L7dmParTSXZh8I6eeI1xD7QEgP+UH58D7QHc1eXvNKHtoYzssqz4SOhlU1xJo3xFowxKoZYtUNsRqGWDKuw461SnsevSMIfnlW8O8Mgl+oC/5dIfCLnbXN1wE/suO/jX834GcC4O8PI/82/j1h5NNe29zbwg+BfZ89dts/OhBG7m3/7mAY/Paa5lAY/Lb/e38Y/LbdeSAM/pzgPxgGv+3/PhQGv+0/PhwGv+3/PhIGvyb43wiC39lD/GYY/Lb8vxUGv72+OQz4dvNKqW33m0H47+B/Owx+u3+/Ewa/bf+/G0b+bf1/NAh+uS3/74XBb8v/sSD4lTb+98Pgt/dEfxAGv73n93gY/Lb/8EQY/Lb/8GQY/Lbf/1QQ/Km2/j8dBr9tn58Jgj/d1v9nw+C37dtzYfDb4+tIGPz2+DoaBr89vp4Pg98eX8fC4Lf98xfC4Lf98+Nh8Nv++Yth8Nv+20th8Nv+88th8Nv+wyth8Nv2+dUw+G37+VoQ/Jm2/X89DH7bfr4RBr9tP98Mg9+2n2+FwW/bz7fD4Lft5w/D4Lft54/C4Lft54/D4Lft5zth8Nv2890w+G379ost/Cgyu/PW7tu/pGIPdOet4u5Kuru2f9o61HLvJ21sYd9WP/ipu/Yv3PmVQ1+fr9+HJ2GZqPsWND7HW+qSNrT+a6FeffvX6wcOVr9+D9cdj8EcjcHc3MH89P67D95XXTj4yVrtvvqBA4yQU5CjGNRcB/Xa+n0Hbt9/N6OtXxzap79Wvf3uL9YYbUNKNLk7PUH1tX9d0s4w8QwIsVBGQmejQkfuSk/Cc8N9pFqadiD9HPFqy0/nTv4k8cPyGSHZ5RVe85TnEq8n8wqdvEJHwzpqiPW6IdbzhlivGmJZtvFlQ6zjhlivGGIdM8Q6bIhlKXvLMfTGkGI9Y4hlqROWsrfUryOGWJZj21InnjPEsrTRbxtiDev8+OMW1njU6ztY351wmJvD4JdFFps8skD64iuhb5WJ+VewOE9o5QjLuG1FX9uQf+7nTcAPyiAOa1OfWONKXog+zXvazfTjymv+spTf4sHH8pNRrw5vIVlsDSOLkq/ftgBNoe/WdbJKrtXnD9126f7bIkpZkoPI7TQqJ/epRqJeeW+OwYro79PoWRbwMDm+RfaN+sGFr11dve22eu0E9weoZE/VzzX1576hHtjspQ5LIPSXypT4hpRLovKuO2TD4a791dqnq/ccOHRXfYREiStgFifCcbO5qzLAEj7LUTnpakny5qG2/4M42chvAScVTBn12KZNMfXY0vCzEaV8nrDySj3hPeupjxhYj1Vp0JlP2hFFndlBa3+anZwww65YXuywC72Tk3ZmCjuzFktpvADkV/pys5LHs+gYYGH5TdBGnrVwBh6jZ+e1OixPmC7Jm6kZJS+rPBP5ujf2d2e624Z9w3oaph/SRwFhTzPQdOX1NLUVRVivvlJI06/Ir/TlFiVPsMRDQj3F8puhjVgef0t9fDZFeoo6zXqqeZz4DPX0o6Sn2Desp2H6obiQVk+Ffi4KOW46eqrphbaK0fRC6mr9xTvjaftLw3rdEOtVQ6znDLGOGmK9MaRYxw2xXjHEOmaIddgQ6yVDLEu9H1Z5/dAQy1JX3zTEesEQy1L2lm18xhBrWHX1HUOsRw2x5IYNr1cE36XxqNcXsF5bIT1pBz5D+rkopO/W8ZU0uWpro7A7mcU2P1sVfrYq8pG+3KbkCdb21t/o02P5rdBGLI+/pT4++1arw/KE6RL79NuU9uAz9OkfbOGyLrq0t/XvgJHQKmH7cWpmXJGz5TgaV/rKco9I8HeEwW/Lf2cY/CnB3xUGvx1d+ZQw+G39OTUM/qzgnxYGvx1N+fQw+FXBPyMMfk3wPxQGvy74ZwbBL7XH7+4w+O3xuycMfnv8nhUGvz1+zw6D3x6/54TBb4/fc8Pgt8fveWHw2+P3/DD484L/4TD47ejbF4TBb9ufC8Pgt+3PR8LgtyM3XxQEv9y+MXNxGPyi4H80DH7bfyuEwW/b/2IY/Lb9LIXBb9vPchj8tn2rhMFv27epMPht+zMdBr9tf2bC4Lftz2wY/Lb9mQuCX2nbh4+FwW/bh58Lg9+2Dz8fBr/tH348DH7bP/yFMPht+/aJMPht+7Y3DH7bP/xkGPy2/fxUGPy2/fx0GPy2f/iZMPht+/zZMPht+/y5MPht+/z5MPht+/yFIPhTbf/wi2Hw2/b/S2Hw2/b/kjD4bft/aRj8tv3/chj8tv3/Shj8abcP/ZutfWi544jv1eKdPvefvB8re+wuYaTFdZCP5X/SynD0fqtFL82Xl8aDtLuYKuIu0l+qLy+NEz8sH77Lsl7hNU95Lr3T7JTjvKzybMSD9a4h1mFDrNcMsY4aYr1iiHXEEOu4IZZlG48ZYg2rfj1jiPW6IdabhliW+mUpr5cMsSz1y3IMvWqIZakTlnZV7vVNKHnsR2CEC8N5O/U9D6Gfi3rn7RB+xIYonVxTvtqDbhiLE+G42SgWzMvSM3615/PN7r8X82oPvlKhiYBf7cE2bYyph7KIlGcjSvkNhLVBqSe8Zz31oyi4OhfDBlfpvMyp9Q22SehPRL0yz8T8K1icJ7RykS7zvUay87UN+WeThq8boQzisDb2iTWu5IXo0w2ediP9CQ+vWjvWk0y0KUNbIkn5SQ9fWH5SoS11A7/kXPLJUHvJeTEv9orcdlI5sYMjkd8OIlZEf++kZ9lIf7HXt+RPM56FT5fyCpZsRay6BO206hKc3C6BZmpZlcaj3rbubf1bGCQVOyf8G1Tsgb5rWnK7hee1FEkzz7gbh6YSbwBvVGQ7RuXrsDt5YYuea4+87Th/6K47r6wfvO/2+v11LQhBku7iN19dku+0+nTXJZ/7M6xmLLR75dN9l/o0Y6xCoc2YdL0kKzM2rmCmMWPYXesUuvJsRCnvM2O8UZ711HdpQnnGqh7Ig02t6rySCLUK8/UzymdAVUdxIhw3ezlnbM1536Bg+px3n3pGyrMkR9g3C2Vj6G300OOzMqw7RmW/0OqkwEOigO8hcRtWZ6V2Wp2VTu5ZKavUY1UadI9K2uFSPopv/3jUK4+9rX8LhXppplIpzxVnKsWZ6Vp5ul4rzC40ZmvlYrVYnC/Wao1GpTozX6nPNKZn5qanyrP1hfpMfXZ+ulRsVLRhm4nsXhNwjvVNHkeeF5PsyLuE1ww2Qj6Wv6dFw9G7FRx5eX3m/updt9eqB+ufvfveQ/VD9dpX9h+sH/jk3bXP3l+/+2Dfbv0Xmt1/f7HZW09L2kULCYMd9uJDoToR05Yo0i8VrKM8HB3yeXYOC46WSNvt40sMvNuMeRjkZpTycDdujPJwAltDefji6Fr4zYn7EfvFyeXPch1cLidpfdTp7ysUHJHVlfB3lsq7JNZTyl/Ver4m6vCJZaTuGJU/NNLh/xOttwY1qyP8TFB9yY+ijq5eTbzvbf1dGCylnuyFfo54DTXZX038sHz6nOxRLVicCMfNZpVdysn+GsjTRMCTPbbpmph6rPL8bEQpfzVhXa3U48leq48YWI9ViYcf7jRdqdDm4fcYDL9P7Yqne2XUKwcegusUejJcr6GyLslwvZbatLf1d2GgNDWTdrgK/RzxGmq4Xkv8sHz6HK6oYgh/LcFJGSyL6VpgCcvn6G/u9q8o9TiJKCeiXhGwOlxHdfa2/i4MlNKHwBD6uSikenbU4Trih+UzQvK5Pox82vxcr/BzvSIf6csblDzBurH1N5olLH89tBHL42+pj89eawklT5gucQiMG5T24DORr/Ncjo9005Ox9cvgx79B6wYcf6grceb8aoV2Xqkv5TQ6+QHp5BU6WmjUrze78yY9eej9XkuYGNKFz0QxzMjllIdhQjjs52UezMsVTNd3nxzt4Ln/vgrlNFPMbsMtwA/Wxb/HqKxL9za786TsT0Cvfo30Cqch7u9rEvj29beUE1mhnnCf4njmPkU7wfLXxqPk3ai0S/Ju8mDerGA6uc2OdpdDufPc8lV4buhqTKedW4R+LurVpxBzi6bfKB+eW24NI5+pDOEjP7cq8pG+3KfkCVa19TfOLVj+VmgjlsffUh+f/TbNLfugLM8t+5T24DOcW/7eSHfb2H5o/wouP+PxjbKR/tV8LRlTjp/fHelui9RDeeJ89GXIx/JXwmH1zzw2jPvvFmpjku29VmljWjt+FWHd4uHr1gSsawgL699KWPsSsK4mLKy/j7CqCVgHCAvrVwlrPgHrIGFh/XnCWkjAOkRYWH+BsGoJWPcTFtavEVY9AesBwsL6dcJqJGA9SFhYv0FYtyVgPURYWP82wvpaAtbDhIX1v0ZYtydgPUJYWP92wrojAetOwsL6dxDWnQlYNxAW1r+TsO5KwLqUsLD+XYT19QSsbxAW1pe6EwqW2HmZk++G58uxHhb6OeLVlp+Oz3J31CtXlA/v1u9XeM0rebw226/Q2a/Q0bBuMcT6qiHWrYZY+wyxqoZY84ZYC4ZYNUOsuiFWwxDrNkOsrxli3W6IdYch1p2GWDz/+Pxn91tCoE5GvfbvFqqHNoj3O3ndiOURI84/x2OKrybwvJ14Xqyf7n7vIKzF+unu907CWqyf7n7vIiysz3ZyPgHrFMLC+v346e73qYS1WD/d/T6NsBbrp7vfpxPWIH76N5vdWIP46bcS1mL9dPf7DGrjYv109/tDhDWIn/6tZjfWIH56k7AG8dO/TVg+P/3uBKzvEBbWv5uw9nuw3O8zo24srL+fsO5JwNpNWFj/HsK6NwFrD2Fh/XsJ674ErLMIC+vfR1gHErDOJiysf4CwDiZgnUNYWP8gYR1KwDqXsLD+IcK6PwHrPMLC+vcT1gMJWOcTFtZ/gLAeTMD6MGFh/QcJ66EErAsIC+s/RFgPJ2BdSFhY/2HCeiQB6yOEhfUfIaxvJGBdRFhY/xuE9c0ErIsJC+t/k7C+lYD1UcLC+t8irMMJWAXCwvqHCavpwXLppmY3FtZvEta3E7C+RFhY/9uE9Z3I38YitRHrf4ewvpuAVSIsrP9dwnrUg+XSHc1uLKz/KGF9L4GvMvGF9b9HWI8lYFUIC+s/Rljf92C59OVmNxbW/z5h/SCBryniC+v/gLAeT8CaJiys/zhhPZGANUNYWP8JwnoyAWuWsLD+k4T1lAfLpdub3VhY/ynCejqBrzniC+s/TVjPJGB9jLCw/jOE9WwC1s8RFtZ/lrCeS8D6ecLC+s8R1pEErI8TFtY/QlhHE7B+gbCw/lHCej4B6xOEhfWfJ6xjCVh7CQvrHyOsFxKwPklYWP8FwjqegPUpwsL6xwnrxQSsTxMW1n+RsF5KwPoMYWH9lwjr5QSszxIW1n+ZsF5JwPocYWH9Vwjr1QSszxMW1n+VsF5LwPoCYWH91wjr9QSsLxIW1n+dsN5IwPoSYWH9NwjrzQSsSwgL60vdCQUr0/pXzozegud2ZzTpPw0s9HPEqy0/nTOjt6JeuaJ8+MzobYXXvJLHe45vK3TeVuhoWLcaYu0zxKoaYs0bYi0YYtUMseqGWA1DrNsMsb5miHW7IdYdhli85zgI1l2GWHcbYu03xLrHEOteQ6z7DLEOGGIdNMQ6ZIh1vyHWA4ZYDxpiPWSI9bAh1iOGWN8wxPqmIda3DLEOG2I1DbG+bYj1HUOs7xpiPWqI9T1DrMcMsb5viPUDQ6zHDbGeMMR60hDrKUOspw2xnjHEetYQ6zlDrCOGWEcNsZ43xDpmiPWCIdZxQ6wXDbFeMsR62RDrFUOsVw2xXjPEet0Qi/cck+7JXdr67bsnJ/X2QR6/S5elOlgeMeLu4WWB530JPH+ZeNZoau833tPszsP3G/lOPr7zzO8+4jvM/L4Vvt/Ie7Y3QR6/63Yz5El7tPcbN3raMwkY/F4vvp/L73BjdJrrKQ+j09xAefh+7o2Udxnk3UR5l0PezdBWeT93jNr6mdbzwBFe1DBzvvejMzH/RlHvvrhLPG4xClGO6FxtSAexPt/spnONIR3E4mhM1xrSwbvGLLfrFTqiNzhuDfUm9bs0Qj8X9dqYEOciWuyD6xW5pgw1wuEdUJwIx81GsWBelp6FiAyEYSQ0EQimTCXYphtj6qEsIuXZiFL+BsKKC5uRjaGndSXWY1XK0PO4yEDXQT6W39cyue7t3s/u6pSPo4XyEJmynsQFB2MepHwNePjELh1zNKZd18dgPjDa4eW2UR0zUjC1dt1I7WIebiAepPyd0K4vUNSlG5X6UcyzTNQddQnr8t+azlxJ5W9KaA/3k5S/19NP1yk84JhkmTIPXObGGB4OKTygWVvYf89DLbMWURqF32yGNJFzBKTrFJy4JGJwzRNVzBIumyimI3+vU3hyTZb4f7X6XfWD9ZhGs63OxRAbifTELrTUcylsqKL0063Qz0W6Lu614ccbOgnlw9cQtFBIeSUPFYMV0EdnQ9QJkHng4P774nQh7TycUfjh+hFhZZRnLq3qz+L1J6W7xmqD4kQ4bnZclyWpiawsJC3GXfO5OYgp7prPxcLuukqhK89Gonh3SnPFOAijzx1DDKynTYs8xWpTMAZ6xPLPw/QngRy5jqRfbHbyOFDj0q+eiqlvlZ2kq6c8wUkZLIspDyxheV+gRpckuEWa4Rg2INR0gQM8YZK8KtDmDat5yOMNqwXIw9DRnLJK26W9bhhdsquDy+WYVxzaVcrDYTNPeeihL1AebhbWKA83C+uUhy9NNygPN1/lwhjHhP3LtNkWaNZTN9uE1mTUK1fcwIzzgrSwx3ml/lUeOlsHpLNVoRNYlsWw47XzUUWfh4L0eVxIvvavYHEee1+hw2j7pmyXuJ+13SAf1vV9YgX2gsvscmjt1uyrxqvWDt79kMOJ2VZsfLcE/tueww12PyaDyKGcOnij0M8Rr6H0cZL4YfnwanKTwivbPpeeaHbKcV5WeTbiwXrVEOstQ6xXDLGOGGIdNsSybKNlP1q28TlDLMs2vmyI9Zoh1kuGWEcNsd40xDpuiGWpE5bj0XIMWeqEpbyOGWK9YYhlKfvnDbEsZf+6IZalvCxt4TOGWJbyGlZbaCkvS5vzQfCZLHXCct62lP0PDbEs9d5S9i8YYlnK3rKNlnbC0gewlNc7hljvElbadb2U36KU1/alZC8T91Wlruyh4N6k9YlqnJzwAqnQd0cmcn2hVp8/dNul+zHeYrs+ykHkNkXl5EhwhHhAWTBWRH9P0bMs4GHCD4emOTILsx9bTn2CLfSX6shMu2yu7XtqH/iQunnKc+n7zU45zssqz0Y8WK8aYr1siPWaIdZLhlhHDbHeNMQ6bohlqROvGGIdNsSy1AlLeR0zxLKU1/OGWJbyessQy1JXjxhifRD68XVDLEt5Wc5DzxhiWcprWOchS3lZ2ntL/bK0OZbj0VInLH0mS9n/0BDLUu8tZf+CIZal7C3baGknhtX/eqdphyV7MNoLw3xN2veRSo0O1r81BZa2Hpby80p5315PFepLXdl7WIA8h7W39XdhsFTy9cc80BT6i9nrEbkVqRzv9eyDetUYrIj+LtKzbKTv9fC9pf+xdW9J5BvoPpp6L5LvK+JdqE3UPm1/EZ/F7VViOe2Dz8JP4PbXMkRP2hEnk5wiE0N+2ntbV6WUa+B7ewuZqNeOZBWawq/0pc/m7Wv9ja8dYHn+UPs+yNsHfIzRs7/ZGjP5qNce8sd009pdtwf718a627bYe6aIq9nzNONhsXQQSz7My307BlgPQxn+AKHIaRSeo37Ih73HqPzfb8nR2edfg/vursx1Cn9O9j8d8/OKdZFXfsN4Bj4c/NstTO21HukPrX/4rblJha6GyTaz3/u6mxQefFjYX5upPAbA0Mrzm8xS/p9A331hl44Zpz/Ms9BD/cEPrrP+SPk/WIT+/OGYn1fWn82R3v5doD//gvQHZezTn82Uh/ojMtLmXH5HoN85F+tPeuhcQ3nI+7WUd43SrgzlIX/XePjbrPAg8xq+e2I3r001eJ7CpJ0XbaW8KuRdRnnol15Oeegns73HwNE8n2IgaA5+g4GdOfgNBmreTHkYeJlf18SUpb+xX9yw+PU+3l1CvdlHeTgOUb4oK4zAoI159qP/HO7//7M13fR8/iYGFLLTu+lymvkb6S+Vv3kZ8RNnU7SgSlI3T3kuPdbslOO8rPJsxIN12BDrNUOsZwyxXjfEetMQ67ghlqW8XjLEstSvVwyxXjXEstSJo0ZY7veGyAbLpTeM+HLJUieeM8Sy1ImXDbEs7arl2LbSVZeG1a5a6oSl/bIcQ5Y6YSmvY4ZYlvI6YohlqauWfK3O28snL0t/1dJGW/oAbxliWdqvYdUJSzsxrPOQ5RrGso0/NsRatasnh/2y7MdnDbEs5TWsNueYIZZlPz5viGU5Hi3nWst+HFZ/9buGWJZ8WdrVFwyxLO3EsNpoS74sZT+sdsLSJ/8grGst5+23DbEs+bJc11r2o+V4tFzDWO77WmJZ6gSPITn3xFDscnfFJflgzhiV/4PWOfQ40chEpmfNFd99NaF9UyDaGaIXRfo5N99XQH74ziXmjQ7A61x9ZqpcqteK1YXZ+fp8+47jTcQrPxsB+u6/m5Xyvjuat4SRdUnuXWSbHfybQa4ujULeTZQ3BnnCo7vXcQHxH+YuznQpjfyRfl4pz/c70/bl5qhb13A8andG8J4Ej6Uw47ic+s6I0M8Rr7b8dO6MaLb0MkXGEx4Z56NeG/WDZqcc52WVZyMerOOGWG8YYj1niPWqIdbbhlhHDbFeH1K+jhhisZ84CNY7hliPGmK9a4hlKa9XDLEsx+ObhliWem9pCy378XlDLMt+tLRflvJ6zRDrGUMsS3lZjiFLf8JSXi8ZYq3a1eWzq5ay/6EhlqXeW8r+BUMsS9lbttHSThwzxBpWf/V7hljir/JeofuN75+E3U8rlMLuIXW+z6HtaWGb+APkKKtMzL+CxXlCa6m+uaK1zacHuN+FMojDurlPrLD7ap0+vcnTbqQ/4eFVa8flhjK5gbDS7i3127eTUW9/St3AY6y9z3mDR05IfzGxLERuJSp3VbMjB5b3TTFYEf1domdZwMMkMsb9x2sJS7PJm+EZf3oRde0qwro2AesqwrrKw9cNCVjXEBbWZx2+KQHrasLS+sSn34h1gLA0/RasWxKwDhKWppuCdWsC1iHCwvocv2ZfAtb9hIX19xFWNQHrAcLC+lXCmk/AepCwsP48YS0kYD1EWFh/gbBqCVgPExbWr1E9fPcYYwpo78ri+/X3r+3mSYvPgO+uxn0B/q+u7WA+tLabb6wvsasn6W/3+2riGWUhNkps/BZ4bm3jkV4U6b6P0M8Rr8b8tH2fLcQPy0fmx5SfF+WQFihOhONmo1gwL0vP+NXsjVRvMV/73Qp5aaYcbNPWmHooi0h5NqKU30JYW5R6wnvWUx8xtDDk3H4MbSHPr1Roj1H5J1vD0bkin6XQHxotlIfIlPVEwo9wGeZByj8LPHxil445GtOuzTGY74DJObpWx4wUTK1dW6ldzMMW4kHKH4d2fYG+pIz6ymPg3mY3b5cptKKYZ4iNdTnPRzeprvt9BfzmPE1vr6TyeAyfRl+l/JseXdmk8IDt5X5lHrjM1hgefqTwgKZ1Yf89D7VMa0QJbxNpppC7krtgk4ITl0QMrnkyHBhH/vapH5qwzQqNzTE8Yl0nHrmRUqvfVT9YjxEQzy2TMcRGIj3xJyylnkvjUdDpOLV7IPRzka63e234KbIdF35YPnyVY6vCa17JQ8Xoh86GqBMS4MDB/ffF6UJav0Gbr7h+RHUzyjOX8LMcWrgvDofUb7gvrM9hoUKHFdPobB2QzlaFDmNpywWXbm928rH8b4F9fXG3jjkSgylLeCnfUNqjhauS8rcp5RtKG0WWGLrptiiZNsqS56Ov9cnr7Up5DPvUIF6Rv9v75PWqJeb1eoXXCYU223Zs13LYdqGfU9oYwrb75OpSn0s/VHUWJ8Jxs1EsmMcm/DIq94Vm99+LWfrdAXmaCHjph226I6YeDwl+NqKUv52wblfqCe9ZT33EwHqsSlo9l/5Ss7dOmqFzB+Hvbf1dGCgVp9IOHaG/VEMnSW/YLbpT4TWv5OFyDfOQzp0KHQ3rRkOsuiHW5YZYVxliXWuIdYMh1k2GWDcbYt1iiHWrIdY+Q6yqIda8IdaCIVbNEOs2Q6zrDbG2GGJ9lbC0ZU+cG7WYpSvv49weQ3+rUj+iuhl6lmYJh74MLzuE+TWRf8kzRuU3tI6vcXszS2WYnzRfumRfaW/r78JgKbULL/SX6kuXSUsv9kNuU3jNK3k839dT0rHQcZfEt88o/HD9iLAyyjPM03QctwFEx/mEE+viCad2Gi5+iXa6PUn8aCflWP46Kr8PeNDKCx5/BeFDypjTTrk3xdBD/vCZb/toXwyWFmXdpW80dd7PAd55W6eq8KdtHUp57dS+CmWEH002PIdXlfZgfz5M7ZHyFyrt8b2tOd76dxTyDO1JzfHxCvDBch1rdrfbJ0OXWOYLSnmUJX91F/2bfZSHPn+V8rQvLwgP2k0Z1D0e9zju8OsIf5jiKxHaTRQe9/sUfrA8j/sq8KCVFzzWtY8r496nvygTuXXCmHs941HTDe22X1rd4PGIY5X94HmlPfsAn8ejlP9cyvEofb0c4xHlyuPRJ0OXWObaDSHfmMM1Ao85HI/zlIc6z2s8bR5OOx5xHuYvwfAtNsRy+bzOx/lSm0+/AvlY/lrPGNgX9bbNt8VdVcrvgzL8FRmUZZXykHdZq2i6LOXC6vLUtKbL+6JOYl32ycKlfudz6e98lDzv4NpuH9HRbkfiDVPWV9Qzqev09XfpiBCPIuVW7+pRdDv1fRSd8riCp2M+AR70uCJH5T7f7P57MccVvhteiKl9gGhLTD2URaQ8G1HKbyaszUo94T3rqY8YcR8TxPbjzR55vlGhPUbl7wdT/ald8XT5NiHL16VfbPbSW76LpcVi2uG6wi+W8nAV+DzBSRksiykPLGH5HP3N3X5ps7ceJxFl2G9TTrXjN12t8KB9T4nVFGcm/vYTelnr4TenrNJ2aa8bZpf08e0nHO7XUB4Om2spD3cvr6M8PEm7nvLwBOoGysPLifw9LbxkKKcybGqea5ka0YFA32dSv8/K/bzqPZw03sNXmt1/L8Z70F6tSus9XBVTD2URKc+GwXvQ6rm/Nyh10gydQK+jpg7nJfSXaugk6Q0fMlyt8JpX8nLwG/OQztUKHQ2LD/iSPOVBDyzYXdgcQ39EqR9RXbYJvMDdpLRFO7BgW7Qm8o8Pfp/jlz2Hclp9l1anmt7x0u+dae2SfF7J4zlnMiUdCx13SeagjMIP148IK6M807AExz3D1RjruLRzTdTfSvA3FR0XWa9T6jv882jD5iqlHNswnHuv8rTjGmoHl7mK2iHl/za04xPUDuSJX33ETUgep9cS73tbfxcGS6nHqdDPEa+hxqn2eri2SZvSJYx7+zxDcNzsuKGRNBw/1+z+ezEuIe63ayJglxDbdF1MPVZ5fjailL+WsK5V6gnvWU99xMB6rEo8/HBDSXNfePj9zLOhhHR5ha4NwS0KPe3r5Txcw9wtmZpNO1yFfo54DTVck86L+hyufAwk8NcRnJTBsphwGGB59hC525Oua0k5lz9GPP87+Oj8P2/9nox6VZ3fcur3A+wbFf41OvkB6eQVOjIE1kE9CaIueeNKWyVvPdTbT/U2QN7llHeZ0i7eONIwr/BgXqnkub67LtehFWfGtCNRrQ/i9DkOi4OfYH2+enlDAhYHP8H6fBX6xgQsX/ATvtJ+UwIWBz/B+mkCqSAWBz/pN5AKYnHwE18gla8mYHHwE+34V7BuTcDi4CdYP01QFsTi4Cf9BmXRrqEsNigLYnHwE6zP17sWErAeIax+g7Ig1p2EhfX5inY9AesGwsL6fLWzkYB1KWFhfX7l67YErG8QFtbnq+Nf82C539uibiys38+rS2He+ium3s0b1rf+RHZ3KLzmlTycizAP6dyh0NGwrjXEut4Q6wZDrBsNsW4yxLrZEOsWQ6yvGmLdaoi1zxCraog1b4i1YIhVM8SqG2I1DLF4LvP59e739tZvn18v9dCe8baGtn2irQPi1g24NXJ9As87iOfFrh/c752Etdj1g/u9i7AWu35wv08hrMWuH9zvUwlrsesH9/s0wlrs+sH9Pp2wBlk/fLPZjTXI+uFWwlrs+sH9PiPqxsL6bHPnE7A+RFhYv9/1w7ea3ViDrB+ahDXI+uHbhDXI+uE7hLXY9YP7fWbUjeVbP9yegLWbsHwRTu5IwNpDWFqYCMG6MwHrLMLC+ncS1l0JWGcTFta/i7C+noB1DmFh/a8T1t0JWOcSFta/m7D2J2CdR1hYfz9h3ZOAdT5hYf17COveBKwPExbWv5ew7kvAuoCwsP59hHUgAetCwsL6BwjrYALWRwgL6x8krEMJWBcRFtY/RFj3J2BdTFhY/37CeiAB66OEhfUfIKwHE7AKhIX1HySshzxYLt3U7MbC+g8R1sMJWF8iLKz/MGE9EvnbWIy6sbD+I4T1jQSsEmFh/W8Q1jc9WC7d0ezGwvrfJKxvJfBVJr6w/rcI63ACVoWwsP5hwmp6sFz6crMbC+s3CevbCXxNEV9Y/9uE9Z0ErGnCwvrfIazvJmDNEBbW/y5hPZqANUtYWP9RwvqeB8sliUg3qdT/HmE9lsDXHPGF9R8jrO8nYH2MsLD+9wnrBwlYP0dYWP8HhPV4AtbPExbWf5ywnkjA+jhhYf0nCOvJBKxfICys/yRhPZWA9QnCwvpPEdbTCVh7CQvrP01YzyRgfZKwsP4zhPVsAtanCAvrP0tYzyVgfZqwsP5zhHUkAeszhIX1jxDW0QSszxIW1j9KWM8nYH2OsLD+84R1LAHr84SF9Y8R1gsJWF8gLKz/AmEdT8D6ImFh/eOE9WIC1pcIC+u/SFgvJWBdQlhY/yXCejkB61LCwvpSd0LByrT+lfOnV+C53XlPJfV7YUI/R7za8tM5f3ol6pUryofPn15VeM0rebzn+KpC51WFjoZ1gyHWjYZYNxli3WyIdYsh1lcNsW41xNpniFU1xJo3xFowxKoZYtUNsRqGWLcZYt1uiHWHIdadhlh3GWJ93RDrbkOs/YZY9xhi3WuIdZ8h1gFDrIOGWIcMse43xHrAEOtBQ6yHDLEeNsR6xBDrG4ZY3zTE+pYh1mFDrKYh1rcNsb5jiPVdQ6xHDbG+Z4j1mCHW9w2xfmCI9bgh1hOGWE8aYj1liPW0IdYzhljPGmI9Z4h1xBDrqCHW84ZYxwyxXjDEOm6I9aIhFu85Jt2T+3Lrt++enNTDfSd+VTBLdbA8YsTdw8sCz0n38b5CPA9yH28rYWn38bT3xu5pdufhe2P8rgAGPeJ30TBiCAcjugzyeP/3csjjYEQYcIiDEWHAIWkrvjc2Rm29sfU88BvdavAhlgfKPxPzbxT17km7xGMG38zPEZ1rDekg1s3NbjrXGdK5ztOe6w3pIJa8Lq6NQw75rdmhGzx0sP4NMVjyirVL8u4kjrcxKn9XSzCu739ldzemZnPG4dklnrZKXRkjN0Ge5XmH4N8SBr8sstDuHWObhP6EIrt+9Atp5aJe+xvirEhrG/LPeohnGiiDOKyb+8QaV/JC9OlNnnYj/QkPr1o74sYm0vGFzr/FwxeW991LFxniOY+hDEs+GWp3292cLvNLrT5/6LZL9+M15HZ9lIPI7VQqJ3ZnJOrVwZtjsCL6+1R6lgU8TJpt2xzDp9BNsuNYn32RG4gv7V+hw8+YjsazFqFG5gnn8zxB78qL3mHoDqzLn5KQ8n+c62A+3fotskS/kMeKFkIEYwxg1B6sHxfZJ27eOwrzHn+lej21GdvJPCLmaNRL1yWJp8A8vEh+ZCA7r/qRQmuS+M1EnXE6SX+73+K7hfV9p+a08SBpQpHXesq7SWmPZsfHKQ9tF69L0JZuoDw8A7+M8vZB3uWUV4W8KyhvHvJwjcIpS39jv7i2/1mug8vlJGl9zZ+EwHHL66sNCq7oCK7ZrOcgbofmTwn9HPFqzE/bn7qM+GH5iJ1OGUIHhyaLE+G42awqGWAJn/EScpzqLSbiFYZw0UTASwds0+Ux9dis8rMRpfxlhHWZUk94z3rqIwbWY1XK0PO4iFc8LUn5/xmmpc/StKTR8k2NwnvaqVHK/8QzNUqZ0Zh2bYjB/Bm4A38rp2NGCqbWrsupXczDZcSDlP+70C4JShhFvfrKY+DeZjdvVyi0ophniI11Oc9HN6mu+81R8TBP09urqbxML3EyZV2R8r+Two1CHrC93K/MA5e5PIaHf6TwgKZ1Yf89D8XE4hyF35op5K7kLliv4MQlEYNrngwHxpG/feqHJmyDQmNDDI9Y15URb6BWv6t+MC5YKc8t62KIjUR60sKEsXsQaDpO7R4I/Vyk6+1eG36KbMeFH5YPX829XOE1r+ShYvRDZ7GBa+P8Bm2+4voR1c0oz1xyg+U3M93ltG1JLZqmlJelAM7FuHTYBvlY/k/ArvCXp7RtLhy0abZ0cBnCyzFta1Hb7sHtg/ewm528pfmqYbGkfXkK2zvW7JaFFioBy7PstHAIuBSTvs9TeZSjtiXCW7a4rMdjoCdgme7SaLNTzkqOM7OFQnuctPBx+wHTKORj+f+vxScGfJd/RwfgszFTLTbK1UZ1qlqrVRaqvJ3gkvSZsy9OH/6UtnzYpspvtkk+O5VX6q+PwYo7BhmF/C46rR/aMYhmR7FfeC2jrQ8mI32uS6KjLRs1OfB2hG85PkE87G39XRgopf9EktBfquX4REq5inw2hpFPIUP4yM9GRT7al5Gx79x/+dbfOLdh+Y3QRiyPv6U+PtvSUuI8YbokoVUzSl5WeSbydbZ0Yn1327BvMjH/Ci4/4/GAsuHxAP5213b3zvXdbdHW7VhXwjTyuv2iXR3MU1uYk1Rf6z9tTY+LCfZlpH7cGontm5Q/E+wbr9NGqc3YTuYRMXG7G3nm7W4pf06Lh7DjTN/u5rDFvPBDvoLYx2Jj0fZxNAQ/CfYR5bMk9rHYWFH2seyxj3c3u3noxz5etET2UfrXNx4WSwexxNaKLcR+5A8T+fpdo4P1pVxoHZ0ATG6j679P0Hwi/Yz6p/ltY1T+P+3sYH6K5hO0x9Knk1F8H09GvXaEbTr2mc8G5JX6ozFYcT74BORj+S95fPAkH459cOSJbQLOX1r7ZfyOeLAi5ZmUR/+f970mqeyEUnZcobW39W9hoFQsCq08yUSzoWG/rVgsah+1ksSfekWe+YNOLl3R7JTjxGtobJPTtb+6u4PL5Zgf7K/NMZiazvJevrRZ04NJwuXxgvISX5x9rTtayuTsx63rdTye81yS65jjRMu470vcv5i4f1k+nLT+Fb5d//7LPvoX+3AL5SEd/kQGzkWC4WR/kHzeYRtLixkv/chTGy+aPPnquLZm0uTJV2r3tv4uDJSmKtpH9ezwZ4pjJIOdGzptfJDGq5RhH9QlXouLzo4q9V3itZmU/wbMvRfv0en77EVEeFIW+5GvYG+Nuuu6JHLfRvT3tv4uDJTK9QzRiyJ9DSb0c8SrLT+dNdg24oflw2dC2xVe80oej4/tCp3tCp28kvdC0w7rqCHWYUMsyzYeN8R6xRDrTUMsS9m/Y4i12o/9Yb1riGWpE0cMsV41xLK0X28YYlnK3lJXLWU/rPbLUlct9etlQyzLfrTUL8sxZKlfrxtiPWOIZdnGYfXlLNto6U8Maz8Oqy/3I0OsYfVzLH3MVX/i5BhDlnbCki8r/XK/eX9tEL7eatphWcre0geQuVbwRH68n5eJevcNpey21l5j2L22SnFC4T8TddPeEYh2huiJrPEZ0p9Q+BG+c0reIPcpp4ozM6XpSm2qMT89OzVVzxC+8MrP+F7sTqW8tmcost4VhZB1uabdPd4JcnVpFPJ2UN4Y5AmPbh/6AuJ/ZyD+08gf6eeV8vc1O+X66cu8QofvRQyClV8k1uao11aLndDupvB5mHZf0J1tvAyH9mij0pwX4Hkv25Ew+/Pl1HZE6Oci3Q7vNeGnc16wlfhh+fB5wTaF17ySx+cF2rnENoVOXsnjNdMgWEcNsQ4bYj1niPWSIdYzhljHDbFeNsSy1IkjhlhPG2K9YYSF/p8FX68b8eXSm4ZYlmP7HUMsS1toOR5fMcSy7Md3DbEsdcJS9lZjOzJuo6VOvGqINax2wpKvD4LPtDqnLZ/sLcfj84ZYlm380ZDyZelPWLZR5lrB4z1FXO/mKU/KHqc9xUDr8cqEwn8m6qa9PRDtDNETWeMzpO+7q5dT8gbZU6xNVYqVxtzUfK1RrtdmGhnCF175Ge8pavtD2r5C4D25granyPuGo5C3nfLGIE941PYUw+w/lwtp5I/0tb1+3lMc5JyF9xQHwcovEkv2FHH+Fjuh7SnynfBJpT24p8jvQLxGNgllYLgnp75viu8MM78uXdHs5PneCWIcfBb3jhO/Ayzlfwx3zN+mfVjEculyhT++t4/1HOa7G+LLTSrlNsDz2+oHr/pa9b567ar6wn31g9lIZy+KdLG0zUUUn6RpjDVOf/MrW4wpW91pYz7Jv4gV90oZX8+X8r/UEpkzYcU97/8eJ36F1t7Wv4UBk/aaBk+1YUJJlBb9qnQ2CD/+V6VRPjw9hnndp1Rw2/RimlEP72r2yob54EipIV791fRG6GomUMYzh2X5X8Fk/Y0NnfI8TrW+4FdCcwov2hhy/+1t/V0YKM0WNL3JePiRPDSXWnl+JVDK/xbYCQlxqLlSWWi/S6OUt9ek/aWiFhoKbTe6aXF9iuWlT/NRr9yknZou4vQrOqXpRZrX4jWdMZRZ6rB1Qn+pwkRofeMLExFyboizxdrr1Jr7yOMNl7VZpXzcK7P4W+rjs99v6VqeMF0aJEzE75KrpYVXXKwNR9n4QgjwkqLfEAK+cYd2HMMr/IsNOk0tvIJLzWYnH8v/awiv8MdkD1BGqEPvtavZyVsiG6qG10O5sg1Fe6n1w7db5fNK+Rspz6cL2jIgE/X2gc9P8vkNk0q9rzUXT4frS7k0fm6YpWP6kGlCf6n83FxKuYadCzsh03whApFf7bVztlNaSBZt3hiJeucBtMfse/0F2XqcnzD8SdLcJbRdcvbpv5Ct57Wv9q/g8jOfDU4zHhZLB7Hub77/r4SvlDXv2pYAXJvHJuLrP9DslJM6WvgbtM88Ztx/e1t/FwZLs9ocjHPW+oluupr+aX4s69cvw5y1kdqtjQXfusc3zvGZzzfgcaXpNMpE+s0XFk/zHe36qjjLfbBeaTf3gUuyFXkK6OjO1m9tTsb+P536H225z9dkXKyLuMzjbuDxQ8RjXBjEs1vlwvnus+/9Pym8x9kkK/Stsx55SPnNgKWVjzu+Or9FN2ndjPsGLo02reX0np4WrX0+GXua3UeZuCR69AugRwWyN5rvvlibovWnb64L63MU5tL6ZLz+DnS80Pf6O27suCT+r1Z+s4Kv9Zvbe+R5R1sP45eENtMzn5+mXSFHW/XJCR0D26dhfEfBSBOitV991to0DOMmjV5rdHzr9FD7DtJvWhgmw7FVEdlvAT61OZmvGW2FNvAxuVY+T/wz/lYqL/XxMzs4nmU88Dz2PbDZV9Nc6mujS1c39TYKz1yGj4HlWHdNDM9XE89S/gaYezk0sbYvh9cROByzlL8ZMPnTDdpVGZ8d1Y638Qhb+JmMeuWynerhMTr3uYbNV1k0nG2Ew+0cIRqMrV3lcP/tbf1dGDAJnlx1wLCbOxV+xqj8HaTHp0TdMvXJzP23S6F7StQtV6S7i+g6Hars6cYU3nD9gP2+jWSbDyPbCstxLOrVWx5HWP5esBf7aV5FfwDn3wdifHRcz+xQZMF8Ia/albsxKn8I+mNmj84r8oO8ar68jPnl8OW7zgya3fLR7BOWX6x98r1+7VsXZKJeG5lmDsN+0MrzNRUp/11lLebbj3b43yN/znfWsx7a4JsHtfU3nmE/PqHj4lyFMruz2d1eKf8G7Os8RWPQ99msMHcL0q9/hP5SfTZLOx/zfTYrr/Caj3rHE5/DaXsO2vhbxRourGuNsER/XUra2/tRir1drHtVs5OP5a8FG/Buir1dy3WetlZmW8Oy2dv6uzBQSn/PC32MgLav6NMd7Sw+7Pq01Padtb2ZNKHRtXlc5mltTYW4I1HvvI6vnY/Rs79OZza4TuNxvkVpj3bN3I2HX6U5EftmsTqvjXnpX82H4D2htHc1tD0hvk7rG3eB9j1Sz/FCf6nGnabn2hzv06MJT3ktbILWb7jHiT5yRHRxj3MrPdN8au77uHnlp336lnimiuUvgHnltz17nmw/fH5nmHtdi/98XGi/M+lcc2nu/HbuQvhsD/Kr+cFsx/BVL20fg19NQHuEY5X3If8ZzQUWPp/T4X/s2fsfdC7w3R1c+nVY+vEwrOuwsL5jZzz49EezuZuVPJ5PcDxoftYIlcffUh+f/VsaDzh2eDz4fD2h7ZIbD39C40HzJRY7HtK+M4Dz1r/vc97i/Xspvx7mrT9NcVanrZXYn/PdCUt7Hyufggeks2FAOtqnvny2b1htUhifwW+TNLmu2qTOs/HWN/KsbVJ2Y3fbQtmkuHtSLqFN2rixuy14tyuNTZLyf7ajg7mphamN+X7Wd4H0cHVfxc/OitpXOZPGqdW+yik0TkPvq4S0By7xp0axH+PWPUInzp5pawP+jFmc3blwo04zrd2R8n8Mdudij93JE8/auk+Tm9BNc3bW776Xzx/TXudfLB1tj6Vf38Bno3x7UGnvzbENEQyXwoZNKQ5tGFPtrFuzVxuiTp9V6weKpdnP1Bfue+ieg9wZAsjGbCsBSvmI/uZ6jim+qDep0HAJv5nOAxKf84Yi46fhKalsUr5mQLZQ2X4XK3Hf68S/474JjJMnlv9cy+Bp3wTWBjYqD78Arjlpvg00ljVuPGr1cEDh39hm4Ulrs5T58gBtvoranE3Z5mykt1mer4t6dQAxlm1RWqwX0hq3D+SitFhr+Ca2YVuU3hpoUXrDEi9Kgx6WnOjTJOezTs6ndpFWC0LDl7H+ITifXyPnEzenWHc2Al+DyncjlOENtQ1Ku1jmWF74HFUwXeIAPFL+3hYTYRfueiwpXoRqL0u7/jmwMVk2vj6X8n8L+vx+T59jv3CfZ6Ne2bLvlfYgwWe/fI42f5/dJem/II5tH3OR0M9FvbYzxFykHXxrtjK1oy2A/0emW8hbCFDKR/Q319Mc7Y0xNOIGNTu/7IAnOdoanbiy/TrayDO/HZKF+lnlGRtEVhaXwkYqKPW8iZ+N9F0uXslvgDbwINfKa44o4vMEgMHwNNnxmzJS/glwsj+25/3fE0p9NhyB3vJrpDUcH8xIEIU66x/y47shuUHJY/uCEySW50gQOOHhZDdGz14iJxYnQQysyHm+SdNNxkfJiV3pkSBkbIaNwlYvCv6GIPjVguBvDIJfmtMW0Hb487Nh31Kan9Z2N+3wZ4vah+zs8KdmtcDShvg1LRixof7Mhn3Dr1zWPjBnOH7b/J8SBL/Sxj81CP58e/yeFgR/rq3/pwfBb0wJ/hlh+G/rz4fC8N+2z7sB39I3FvyzguAXyiKPlpv6XsoqbRL6Mm+fCeX7mbeRVo6wQvmZWtvOhGfsR+wBflAGcVh7+sQaV/JC9OluT7uR/oSHV26HS482bWTi0hFDrCcNsV43wtJ8z0H4+l7Tjq8NRnxp/ukgWJNGWC491bTDetwIKxP1+sODYG0dUqxthljbDbF2GGLtNMTaZYh1ihGWSz9u2vF1qiFfrzXt+DrNkK/vN+34spo73O/TDbHOMMT6kBGWS3yQOyxY8ga59jYB79n79iE1Olg/TUQKPCSXKNa8j+XS3ta/hUFSsROZMe5AeWSym2dt71SLlMF7o/fA4eJYC9P3prv21keW8rIK3QzlRVG6s5X1Ch3GwrMGLaJm2P3GylzYKKnlatj9zEot7H7mVDnsfmZlRrudboi/sHw3RSv1DNGLIn1/YNg/eK9FWssreTxGF/thNJf4w7mDYL1tiPWMIdZLhljHDbGOGGIdNsR62RDrqCHWG0OKZamrxwyxrGSvzdvDoquW4/FNQ6xhHY9vGWJZjqFhlf0LhliWdsJyrrW00Zayt5TXsOqXpW9i2Y+Wsv8g2Il3jLDcb17DDsLX44Z8TRrxZYnl0mNNO77yhnxZyd6lpw2xLHUiLlJyv1guPWXEl0tWOuHSk4ZYPzDEstQvS76sdHWYbeEmQ74sddWyHy3t6rDKy1JXeW91WMa2pf161xDL0v963hDLck/B0ie3XCtY7j2yfy9713FfVucXFqX83285hdrdaLv9+anChNKGTNRNe0cg2hmiF0X6WYXQn1D4Eb5zSt7oALxOzTSKhenpmXKjVJ2tT01nCF945WcjQN/9t1Mpr517aHewDc+FarJniV/Q2AlydWkU8nZQ3hjkCY/u3asLiP+dgfhPI3+kn1fK39vslOunLzWsSxaJtTnqnStlbC/XeXhcUI8c5GP5/71lm7QAF1oEK7xXwUE9kKctVI/PJCXxGapLe1v/JmlSIyEJPemTtQovHPhDyv4M5PLxPd1t0b7GJTYq66ERKc8yUbzs+Gu5KJtSpTY9Xy3MNGaq1dlGoTJfqp34Z7oxM9OYKlXnygvVysxsbb5enS8vzJUWaqVauT574jy+Xp6brtcrNZbNiKdtWru3xbQ7G9PuNLKbVLB5zGhRivCZb8xIuQmlHs+T24nPva2/C4Ol1Gf6PBeG8Rk6Z/rbU8o1rB9RSD03CL/Sl9rXywRL5ji8H4Xld0AbsTz+lvr47N+1bESeMF3id0s13wGfiXzdXax/PdndNs2fS6NHiOvb40q6b/Yf6L6Z1IuLnvdIs5OP5b8K983+I903Q5+a+4/nPZzPXOL5m79+yGV4LpTyfwY2n79+mKM2Yzt9dkr7MqhLvFaQ8v+V1gqB7JAa3ITlju/zyxf70KZ/urk0vIb1Rzvv/2g2B9uEPnbc/JHWvgutpbLvWtt886Zma9PY5rRYgeeRcpp5jelj+Tg/mse5ZtfRFrKPrK1vGCsuSJ3QFiycp/i8YpfCFz7jPsL6Ui7su8RTpbDvEk9Nh32XuNLgOCZ/3DKObt7Zke+mKfKOs6Wfab7/7xiV//XNHcxT+sT8bAxmI9/BPL31exxw7WU1NTVBPERAS2jzvpoN7eJsWpss9HPEayibrH3FE+XD92jHFF7zSh734ZhCZ0yhk1fy+B7tIFgvNt//d9j4etUQ64eGWJZtPGyI9bIh1huGWMcMsSzl9aYh1o8NsV4zxDpqiGUp++OGWEcMsSzb+I4h1qOGWHKmGnZ+L7RjrqwJg1/2yQLbJPQnQH4R5Gv/ChbnCa1c1Dunh/BFtLYhj3H9zDIYRGcQa1zJC9Gno552I/1+fbC48xmko/l6Un6Nhy8sP6nQlroiw7XE197W34XBUsknQxyLQt+93yVf5KzV5w/ddun+2yJKcXLbQeVkXTwS9ergWAxWRH/voGdZwMO0BhhIE5cyjB0q1tLaDqG/VHEpNV3VzjFFdmsVXvOU5xLfm1yr0Fmr0NGwXjfEetUQ6zlDrKOGWG8MKdZxQ6xXDLGOGWIdNsR6zRDLcgxZ9uPbhljPGGK9aYhlObYt9cuSL8t+tOTL0k5Y6oRlP75siGVp79mupvU1pLwWM1s79xI/Gr8iL3XDxnno+NGanDDWitBfjB8tcjuNysnZ1kjU65uti8GK6O/T6FmcH62tDfheGPcp9/mkgjEa01aNprTVpbxSn9fwa6htLoVdV81OZYietAOfIf2cIpMQfv7alHIV2a1TeM0reRz3Y51CZ51CJ6/ksa0eBOttQ6xnDLFeMsQ6boh1xBDrsCHWa4ZYrxtiWcp+WHX1TUOso4ZYlvplyZdlP1ryZWlXLXXCsh9fNsSylP0bQ4plaSeOGWJZyd795vhAw6Krw+pPWGKt+gCrPkBIu7rqA6z6AKs+wKoPkIRlKa9h1dW3DLEs5TWsduIFQyzLMTSsc8ew+r7Dql+WfrRlP1rK/oNgJ94xxHrKCMv95nd6BsGy2r93v08xwnLpsaYdX5sM+XrciC+XnjbEsuLLuh8t5fWkEZa1Tlj1o/u90Ygv93vSECtvhOWSpd5/3wjL/eZ3DU9GXV0dj8vXxmHUL5dW56FVvee8J4yw3G/LOyKW+rXZkK8fGPJlNW+7ZOmbWMprGMejS+8aYlmuRZ83xLI8t7Lcn7DcN7G8zyR7HRKLQWJ9/G7LeAe+UzgzofCUibpp5wLRzhA9kR8+Q/oTCj/Cd07JGyQ2aKnaqCwslAvFueJUo1qeyxC+8MrPRoA+zk9YXrsbqX0v0FDWFS026AaQq0ujkJejvDHIk2dO9hwbdEMg/tPIH+nnlfIcGzRtX2pYlywSS2KD4twnY3up7jD7sLQ4nhnic41SHvHGqPw/bdky1+Yv7Oqmp73zFynPRqi8S1c23/93QsljG4byttPLQiWtDWM7Fejd26JvTtLerfDZVE3vOX7hIGMoBNbyzWeF1PfzhX4uCqqbRZ9cNf9EZLdB4TVPeS5x/2lz3QaFzkrBQvvje+8jTb9rdLR34X22bLF0tHd3fONksXQQS94fYvtiQUeLlxnsu9uF8nxY36xQFxltjHqT5OG6nXUS989Zj3APiPse19zsY+P7VzgeOGXpb5STo7d3TweXy0maVOiw39PvGB5V+NdizWE824nNOk2MZ4v+PX8/Xcq/DrH58pu724j1czFtRN6RV44NK+W3tWgE1lM1NqzQGlfaZ0h7gecmTBNKu3mM4NkXjxEcWzxGcGxhf3HSxoHIwmE+1Mc4GFHaoY0RXjdMKO3Q5hrf/MDrJ/RNJigP7fA9zU45pOeSNl45/qmvzaHXQ4Hj4fStu6OUt1GRW1odlDa5fvzVFDrIfg7zxjJczLqRy7AdlfLTmzu8c9zttVBHMB8GTNYT0WN8jj4W21Yp/3NkWwOtHVTbynPyMqxpShmiF0Ura03jxpzo1137q7VPV+85cOiu+giJEoe+Zuq5PJaNlLwsPeNyX2x2/y3DgYcwY2cBD4ecJgI2sdim9TH1eFjwsxGlfI6wcko94T3rqY8Y2pJFMMaVentb/xYKtdJUtbFQq81XCo258kx1Zna2Nj83M1+eLc0Wy9PF6sJcuTbTKNarCzML89V6odEo14vV2kyxNlOeZvlESpuQnzj+cQriflgXg8tThIZ1FWFpW5+CNZGAdQ1hYX02+RsTsK4mLKzP144mE7AOEBbW5+PLfALWQcLC+nztaFMC1iHCwvp81L45Aet+wsL6fBS6JQHrAcLC+lsIa2sC1oOEpX2uSLC2JWA9RFhxnwly/21PwHqYsLD+9ph66Aa4pH3OhKfRMJ+qKJbTTqP8eZ9QoVF9ckf58Nag9smGvJKXod+DfBoia4i1zhArZ4i1wRBrwhBroyHWpCFW3hBrkyHWZkOsLYZYWw2xthlirTHEGjHEGjPEGiesEQVLs7kboo5dOHBw/3311tolouRba7jf62Pob1bqRx4srONrC64feCtAaK2JdF9f8PhzlEdhK4CPkLNKfZeW79Mi6ZfNJ8unRXiOzqakY6HjLsl6OqPww/WjBCz5G8M7a+sa3mLS1lv4zLcV2b5mE3X7Az8EvefPsPqOJ1ziz+1J+XcA88XdyW3QbJOU3+hpM/KjrTGl7urxWuc3J4vjNdYXwWV9EVvNdhPr4jFZmpDnYcL0l1Jfu+HPJWSD8OP/XALKh+3rGoVXPrJx6almpxznpTn2wLzXDbFeNcR6zhDrqCHWG0OKddwQ6xVDrGOGWIcNsV4zxHrGEMtyPL5piGWpX5byeskQy1K/LMeQpV211AlLuzqsY9tyPFqOobcNsSzH4wdBv142xLL0AXiuTet/SnntmrgvDL52LrsUVxDi5KSdpS4mDL7I7Swqx2Hw0V9fG4MV0d9n0bMs4GGajLr7y/3mPQZtX0XrX22PIW6PBq/QyPmyy5d9Q94LknyXwn7aaq6YIXpRpK/zhH6OeDXWRe+nrbRP2fXzaSv3m8+BhuXzJMP6KZ2XDLEsPz10xBBr9bNPJ4eufhA++2Rpcyw/p/dBkL3lp5o+CJ8MtBzbxwyxrGTvfvNdkGHR1WH1ASyxhnXetpS9pQ9gaaMt/Ylh1dXVeXv55rRVn7w/rFWffPn0a9UvXD79Gka/0CVLeQ2rrr5liGUpr2H91O8LhliWY2hYP/88rOuhYdUvS9/Xsh8tZf9BsBPvGGI9ZYj1mBGW+82fQRgEa5MhluX5kKW8Nhvy9bQRXy49aYTlfnOI7WHQCZc43O2wyN5qbFuPR6sx5H6fYoTlkuV4PNn1y/3mdxMHwZo0xMobYblkOR6/b4RlaQtdsrTRw6r3w9rGk32uteTLpVXfZOXPHS49YYRl6U+4ZCUv99vSJ/+BIV9Wc61Llv6EpbyGce5w6V1DLMs9hecNsSzPrSz3mSz3vyzvF/InKLKt559pBY0IfMe3vHzh2+dSx+WJC5uMfGuh7wb6BMVsuVicLRTr9UKlUK0VMoQvvPKzEaCfifT4ZNpd5bCfcJgraJ+g4M9MjELeOsobgzzhUfsERZj3EOZSyR/p55Xy/AmKQT4dc9UiseQTFDj3ydheqncQxNZIDKkvtmwNxjlYal7k0ztfUXgRetr7NRgfgePzIe9Sd5L+1tql0RlL2S4pt3zvbRQW0trVYX1vI3BI4Pk08zbyq807HDtJ7A7GA9HmqZGo107iHDFGz6qt8aDZIP7UQlob5Hi/aWt327BvMjH/Ci4/4/GgxVVICv/e2NrdFqkXF19F4huOUfl/uLWDeXvrty/MtdBLCqvM9l7oSSwlLsNhlaX83WDfOKwytxnbqdkpaYNmf1zisMpS/gD5loHGmRpWWWj59C4wX6njQ7FvGcheF332SHsXNWVYZQ6jhuJEOG42igXzsvSMy32+2f33YsIqayZsjYLpeyWW6/Gw4GcjSvm1hLVWqSe8Zz31EQPrsSpp9Vz6xaZeJ05W2KcsK6yfJowyYrFr5QujvD4Bi0Mfa6GxBSspbNLVhIX104RkRiwOfdxvSGbEOkhY/YZkRiwOfdxvSGbE4tDH/YZkRiwOfYz104RkRiwOfewLybw1AYtDH2P9rTH1cHp1KU24YgzraTcdFFO/di30lypcsSZ3X7jibQqveSUP24Z5SEcLi6Bh7TDE2mKItcYQa50hVs4Qa70h1gZDrAlDrI2GWJOGWHlDrE2GWJsNsUYMsZY7LPDaGPp5pX7kwcI6vrag/5smLDD6qoLHRxR/B5ayq2GBFz+vnqxhgWU9mFH44fpRApb8/d48uqO7nLZdq61dpLyMPdxaQgwO3Svlfw/0nUP3amsxX+he3xeUkB9tnZujPG1dqR33SDmxfaOQZ7n97Nrxyu4OHyyfsWZ6WbjEstPWhOjHsN3XvtqnbVWyX5WkV76Qvbg92KCtVu1rrIHXFKmPBHhNESismHdNoX11WmR3msJrnvJc4uvPpyl0TlPoaFivG2K9aoj1nCHWUUOsN4YU67gh1iuGWMcMsQ4bYr1miGU5hiz78W1DrGcMsd40xLIc25b6ZTmGLO3qB0H2LxtiWdposYVpPlun+Q5bPXS0/ch+/RApf4ZS3he69XSoL3XF5/sQ5Fmvd+P64wygKfQXE7pV5HYqlePQrei3nR6DFdHfp9KzLOBh0s6R4q5nCN24/tXWBTkPndEB6YwqdJZvnTC76LOHYVsnpD17sNpndonns0Gw3jbEesYQ6yVDrOOGWEcMsQ4bYr1miPW6IZal7IdVV980xDpqiGWpX5Y251VDrA+C7F82xLJs4xtDimU5to8ZYlnJ3v22Omt2yVJXh9UHsMRanbdX5+2VMnesztur8/bqvH1yyn5YdfUtQyxLeVnaHEvZv2CIZTmGLOftYbXRw+pPWLbR0ve17EdL2X8Q7MQ7hlhPGWG53xy2bxAsy/vYpxhhufRY044vq3vPLj1uxJdLTxtiPWmE5X5z2KtV2fvbeLK/O+CSpa5+3wjLUlddshxDw6r3w9rGk90WWvLl0urcsfLnDpeeMMJyvy3vPFjJy/22elfMpR8Y8mU117pk6U9YymsY5w6X3jXEslzzPW+IZXmmY7kPYLk/ccQQi0MmSuiwz7bimYUNpTfbDpmI8SQyUTftjYFoZ4ieyA+fIf0JhR/hO6fkDRIysTFbKiyUG/XCVHl+fqFQyxC+8MrPRoA+2lssr931E1nnw8haDZk4CXJ1aRTyNlLeGOQJj1rIxMlA/KeRP9LPK+XvbXbK9dOXGtYli8SSkIl4t0LG9lLdyeWQiV9q/dBCJobmJax9K86KzdgZ9SbJ26W0UfJOgfLY55yy9De2ycn1V/d0cLkc84My533PpNBurJfCA4Z2wzIc2k3K3wA6waHdsI5gPgyYrCeCic+RZw7tJuW/SnPgBLV9b+vvwoBJC+0mtLRYTGliROEzHgdajKiwbex/HHC4SNzn5rB3uP7l8Mb4rsQI5eF7JBnKw3c6dlAevmOyhfLOhDx+B2E35KEuctLGsvSLa9+v7+rgcrmIaKLe7KI8tHmnUN6Ighs21Gpp0aFWR4Lw4w+1ivJhvdLCnuYpzyWrTxG4ZBkq3vLTf88ZYll+jntYP8Vp+dlrS76OGGIN6yccHzXEetcQy1JerxhiWY7HYf18+bB+XtryMyOWNsdSJyw/oT2snzi25Os1QyxLnbD0TSzn7WH9VPWwftrbcjwOq422xLLUr2OGWCJ7qYfrOYwHFvaTRYVi2P39QllkpcWqxjbx/j7KKhPzr2BxHp8HrA0kO1/bfHqA+zsco03DmugTK/BeWbtP13najfQnPLxq7eBYF2nX/lJ+o4cvLO+LZR72LKMTy0SToXaWsZhYJiK3C6mc7P2ORL06OBGDFdHfF9KzLOBFSnmtD3MKT2k+bbI2AYtj+2vfMfDJH7E4tj/WTzN2EetqwtLk7tNhxOLY/v3G40esg4TVbzx+xOLY/v3G40csju2P9dPE40csju3vi8e/JQGLY/tjfY6xnhTnhWP7Y32O6bQtAethwtJiTXE991v7TgDuf+Nnjf58ezdPUhdjz6Lt2AD5WD6zo4P537Z3fstG//qUNFy6vanTGG1hafFtpcxIDKaMeym/HfJ85ztSfqdSfjuUEfrSV3gPameUTBv7jM/7dvXJ6ylKeTwH2k68In+n9MnrVUvM66jC64RCW+atcaVd1vM+0pN24DOkn1PaGMKH9cnVJemHlJ9qQlVncSIcNxvFgnlZesblvtDs/nsxn2rC8GyaCNhFwTadGlOPhwQ/G1HKn0JYpyj1hPespz5iYD1WJa2eS3+p2VsnzdA5lfD3tv4uDJSKU2mHjtBfqqGTpDd8NHmawmteyeNxsdgwlO73DkOsbYZYI4ZYawyx1hpirTPEmjDE2miINWmIlTfE2mSItdkQa4sh1lZDrJwh1k5DrFFDrDFDLP7sjvbpkzg3yuKzO6fE0N+q1I88WFjH1xb0ZXjZIfPCmsi/5Bmj8lfAMo0/u7NNqe9Sms/Zsa+0t/V3YbCU2oUX+kv1ObukpRf7ITsVXvNKHs/321LSsfrsjvj2GYUfrh8lYGUoT9NxxONPomA/S11tWyRJRjx2xD/DLQ7EuLPZycfy854tDm0Lwre01pbimh5MEg9YV9siEN3SXj+QcoE/4VPXPuGD7R1rdssi7XJYymtrALTN/FkrXCPtoDxtrcb2ju3tf5jsLodbvpmYf4VXfsbzHWLJF9qFTt6QDmJ9nejgdjhuRz5In86SOQzHEdZtNjv5WP4YbEc+0vqtbYfno+76kvctGIf/Zk98fZGltj3OYdn5NaCkdqL87oxp56PA57+l1xFwXApfgcdlQxuXuGXO41Kb47RPJLBdxfI4vkRm+ajXpvH6SDuSQZmzTRcZrlHKI94YlX9W8Ye01wY4DHy2T961+UizMxuhHSMtJrUjhjSfNfZ9zkL7rDFjjcTwL+Oa+z0bQ5vLi06MQnnUBfZdpfxr0FeVPTpmpPCg9ZHQWxNTfjvxIOXfUvTFZydQ/7cQppT/EWD+yu7+MCdiMN/1+CraOMUjvTTHK9hffAyActxJecg7z5s7gD6X3UD0MQ91jelGHn55zk3il+cjyfsJzGe/2vo9TnjGtrzs68szlfak7cuNnvYzltQbjXr11TeGUF5/Y4eOOdYn5m8qPoHm69zT7ND+SYw/45Lmz7DdRpsiddFP0vwOnodEr/+OMl6XzVco1guar4BX5dhX0K4qYHm2KdoVApyv2YfH8nc3u/OwHzg8ifa5z7RzMb7KeWBjlNhexP1GM1Lbq/mQml5I+d/z2HHt6oRP5pp+496o8KNdtdhKecg7v9aO+irllkNfUT6srz5ZuMSy0/YY0C6xvmqhVrT5hvemk/TKp69S1+lrvaVQWl9yPyMPfLaQpDO8V6ztS2rXbHhf8v/y+FWab6dd0/TNiWmvg/DZHc43mm97abO7PVL+/05pz6Vfwq79ikVtfKBceXz4ZOhSvz4ir5+0vS6er5FmmrGjzSlpx47UdXp7Idn6iZS4PIZRZ7Qrg2NU/i88tl5rm8/Wa3MD2gB+3R5lvoXysJ7P1i+nLg+Lrec9Dk1fNf0TeTr925jC1/B9XjKtb6WFWthMeXmFx2Wb52P6HtvLfe8bBy716yNx36NerKc8HPO8X6OFsECbcim1Q7MpiMF7rVL+1JahTWtTfHqVZFOEnzQ2BXXOZ1MwXIdLo5D3QdErn03pV698c6DUdTbo37c6Q7vyzvcWND3y+WdJesT2SbOh2ryK+0njCq5Le1v/FgZMvrOf8ai3fw33flLfzRP6OUWOIc7EtX5F+YyQfMJ8hrZQcfeQ2Aa7dFezVzbMB4+nCeBdZHw14HD4Khx/eHb2sZ3duNp+ANYVGrwfsHdnB/PjhGk19n86ofOKuBNKXdaDNTHlse1Y/jMwV8XtrSMPmm5J+SQfjucq1Ac+e9dsMdPBfkR58bws5S9R5mVt/hPaYee/kjr/oQx5/tPW5FoITimftCbnPRJcO26hPOwDvi+j6aoWrk0LF4VrQB6vk9AubWyhTUAehQ+X7oQyozF8ox6hfsvrWWwPbvL4d5o99t1JSfJR+Dzdd4aYNBfwmhn3z7k84vE513wKmzEW6es+lqmUr3tkqtkVn0x94wT50WwNv9eRJFN+3Ufbi/PJVMrf5ZGpZu98MpXy+z0y7fd1ryRbwjL17e8lyTTu1bS0MpXy93tkOgl10shUyj+0jDLFNu+gemgz0EZko157l4upl/Vgbo3B1OyX73VRrS81m8Z9+V1PX2rtYn7j2rXNqF3b+myXlH88ULsmY9o12We7tia0a5LaJeWfVdqlzWG8rsWxzPtoLvHev5R/PqVv90HZL+X9C+3zCNqdK+5/TV/Srm/wftiPaG/DF2pWs83aPh3b5h+m1IHl3N9CebIOaHvOvvXWIOf5sk7WdIDPI63WuI9PdJcLdbdW2sZywnWEtu7nsYh36zZ7ysuYwbt12rqXbdavg75W4K4q9zvuafz1nTrtuDUM72lI+X8Aexq/0frtC2mh7S/H7UnG7a/wuJXyv5Vy3H5Qzjv4TAN1yWe7eR9Ns91p1+Vou9dPJPOv+QQ8V/XrG/3DPtdEyNe3mzrmz0Dv/9HO7vZjP8p9J1fuD3fa0P79PtcO2jtHUj5p7cB3h7T1GLeb++oPyS6k2ZNL66tiHq9BfONqm9JGluGayL/u57XFv1T0TNv3Yt8o7X4L23Ssq9n0pDBLrAvaOOfQaFGkhwzh/SVtj1mzxfIs8B5pabl9KJGddoef/SvNfmai3rGcJWyX0r6H9y9aF1Ckv/D9b56PtfBT+Ix9KKwv5djH/v9hrPC9ec1vxzbG+e1/4bGLSSG00vQnyojHgnauq9XznXO6tLf1b6HQGCgJPbEPaxVe4s5yxlq2y8nx43t0XjM9/A6WJqLefsqQnMKcyZYKGaIXRb1rBaSfi3R92GvCj/9MVht3Yc9kiw08k0X97edMVlur4XpkMsW+Ktb9VrOTj+W37epgbo7BjKL+bSf6sZ9Y343rsxUu9XuHgtdK2nyv7YHxvUDfXV/f+Yr7zfccpfzpYBt870Uuyf5YsVHs971I336XS4s9A9LeSea5W9M/1AU+V8MzTd/eLK+Dz4c+Yj8U/TK+1zvaJ+/aO508znns8DjX3vHQwp1KedTLrIIh727we8dFkMmLMf4G8oB2gXXC5xsiP5PEQ9LY9t3RXJJ3h2L2LLC9PJ40vwrL9+tXSd9rfvJGykNdFpoThIP94fRvZ8t2Y778O8gnMEuzs9NzpflCZaa20KhVyuwnoSzWB6C/MD89X6nPL0wXK9PlSqG21PRLtVq9WCnOzM3WK5Xa3NRS069MVWcWqjPF4lylWK8UE+k7Pf/TFhP4vqJLNfAhvgKfL8sQnvwW/wt13dAfTP2pMaGfI16N+Wn7pyPETyZG3uNRt0015mc+E/Xa7KxCk+P6rFfyeF7S9qARd4TK83zE74reTPMx7qNKzJCMkqftuwrPTk+vJT3FfQKOETKm0JS8NZ68tZ48jt2HeeNQbz/VyymYjodfIj9B61vUP/ETJiNd9xFrfQIWh0XH+nxfckMCFodFx/r8vutEAtbVhIX104RFR6xBw6Ij1kHC6jcsOmINGhYdsQYNi45Yg4ZFR6xBw6Ij1qBh0RErTVh0wdqegPUIYWF9vhu3IwHrTsLC+nwGgVg8PweK55B6fhb6OeI11Pzse68zinrnw10Kr3klj+2WFg9NiwGmYU0YYm00xJo0xMobYm0yxNpsiLXFEGurIdY2Qyy2W0nz9Q3N9//1zddSLy4OBt4d0eZoxIjzB9A3T/ILLiWeNZqajymxWdjHFLqYx59kxjyMJ72e8tDHZLuP8WU3UB6uNfFd3V+KWdth27S7SGs9PPNntHFdMUZ5KCP+FDjOH/x5cZSftDvEmnq+Nr1QmCsXa9XqTGFmerafNbX2ThXPx6znexfJZ3daKGYUPrX5WOjniFdbfjrzsbZW0NZzYT9LtlDw2a8JRT6hP32n7Rmzj4HnyNr5Or7rh+Xxt9THZ/+AbIC23tDOvnitrq2RtPsCS42lrbe02EXOpvwWyQL1NRPzr+DyM+YR+5Pt+npDOto7nNp4cv/tbf1dGCiVSxxTDHkM+3m8qZm0tk7o56KgY7no02GUD689tPMi7U7uY81OuST9Rjoa1ptDinXUEOtlQ6zXDLEs5XXcEOsVQ6xjhliHDbEs2/jqkPL1nCGW5Xi07McjhliWY+gNQyzLfrTU1bcNsSz163VDrB8bYlnq/bDaHMs2vmOI9agh1ruGWJbysvRNLPVrWP1CS70fVl/uGUOslwyxPgi+3LDqvaVvsjqn9Yc1rL7csNpCS1/O0hZa9qOlvIbV//qeIdaw+l/PG2JZjm3LMWQpL8t5yHIMDavsLe3XMUOsYd0bstQvS993WH3MYZw73G8+s7KYOyZjsPG372xYo5NReNbOlPGuyXjU217Lc2XtnVVLfGm37x0YpK+9d56J+VewOE9oLVVcYK1tvrNoPHdHGcRhbeoTa1zJC9GneU+7kf6Eh1etHROGMhkzxFpDWNr4185vpbx2f1rTE9/96cCxt0u+vtXuYLs7C3Ivq1afP3TbpftviyhlSQ4it2upnLwHMBL1jo1NMVgR/X0tPcsCHqalsu8TSj0pF/jOUOpviwv9nCKTEPZyY0q5aveN+P1GHD/3NTu/sazcZ/K9m6PNN2Hn3uly2v4R+ks1n/nsukvcP2nsukuPNzvlBrHFLv3IEOs1Q6yjhljPGWK9aYhl2cYjhliHDbEsdeIZQyxLnXjREOuDoBOvGGK9aog1rGPbUvaW8nreEMuyjS8ZYln2o6XeHzPEstT7FwyxLHXiHUMsS51Y9b9ODhttOdc+bYj1QbCF7xpiWdqcZw2x3jLEshxDlvKynNOG1S8c1jltWNdWlrK3HEOW8rK00atzx8kxd1iurSxt4euGWKt7Css3hixlb9nGHxtiDet6yFL2xw2xhnW/0NLPWbUTy+dPrNqJ5ZP9sNqJNP7XOnjGsRe1uw2CtTkBi2MvYv00cfYQ6xrC0u54SL2474jHxUfHuHzat50yrX8Dfy899Tm70M8pbQxxzu77tpNLfM6ufY8nr+TxnTItpqH2LWsNaxPxgHq+RP1XWmz/bQrDj7f/NPvRb//FxbKS/GiIZb5mGWS+ZkCZu3Rv8/1/tbiefO9P40H7PkJeqc/fCouzqYuhszklnU0D0tmUkk4IufHf2t0u6UsZI9jPe1v/FgZLFdGv7cQX0g0UuzT12BT6OeI11Nj0fSfPJR6bOxVe80reNpJrgP4sL2Ns3NT9ebLExpX+m1TkyvFDNR52Kjzklfo7PXR2DEhnh0JnXKm3t/VvYaBUrrCMhTbSPQWeL4d+Cv1c1NvnIfTzFOKH5cP6earCa17JC9+fhcaE0gbuz1PDyC91fwr9XBRUv9r9eSrxw/Lh/jxN4TWv5C2iP0sLjWJ5qj4zVZiuVqZq0+VSrTRTqFWmGsXibLE0V5ktlxsLldnabKncKM2UFiaUNnB/nhZGfpW0/Sn0c1FQ/Wr352nED8uH+/N0hdc85bkk/l1Gycsqz0ZisHhOGATLJfmGSMB5YIp1X3hHuti+5bAbQj8XBdX7oq/PUD6sZ2covOaVvJ1UD/tzaWRenl+szAP5ql6Za/5SPzJ36YlmpxznZZVnIx6sZwyxjhtivWSIddQQ64gh1mFDrDcNsV41xLJs43OGWJZtfNkQ6zVDrLcMsSz1y3I8WuqXpS205OsVQyxLvf8g6MQLhliW+vWGIZZlGy1l/7whlqXev26ItWonTg47YdnGHxtiWfoTwyr7dwyxVsdQf1hPG2KtjqHlk73l2t1yjSx3yOR8CveQ+Bys331JrC/lNDo7BqSzIyWdzQPS2ZySzqYB6WxKSWfNgHTWpKSzKrduOmnldrKNn5OtPbsGpLMrJZ1TBqRzSko6pw5I59SUdE4bkM5pCp1xpd7e1r/FcrlYKNRmio1aozw1M1eaL06Xp6cblcbM9Gyl1piqVGsz9WKlWi7N1WcKjeJs/cSpaXlhZroxV1uYbmjfsJdvzrmx/Ohp3e2Rb4jinWL8ZucI5GP5kdM7mN9vYfI3SyP4PU54mcjynKSU+nvXQj9HvNry0zm3GSF+WD58bpNVeM1Tnkt8bpNV6GQVOhrWq4ZYbxlivWKIdcQQ67Ah1tuGWM8YYr1kiHXcEGtY+9FSVy3HoyVfzxliHTXEesMQy1InnjfEstSJ1w2xLOVlab8s+XrTEMuyHy35Gta5w7IfLWVvObYt2/iOIdajhljvGmJ9EOZty7EdYq6VtTKu5+R76pNUz/1eT3mjkIcYmIf8jXr4w/qjMfW4HbIeDfX+nOCvC4Pf/ibAWkVW2CahL+vLMSififlXsDhPaOUIy1p2vrYh/6wHa4Ef3vfUsNb2iTWu5IXo0zWediP9CQ+vWjtGSSbaOMsoMpHn6zx8YflJhbbUFRmOQ56hDEs+GeJYFPqL+Z6CyO1CKicxB0aiXh1cG4MV0d8X0rMs4GGaJAzNjvJ4juvffEx9lyY8dCaUetK+9cDjmZC/jmicGfXyeKaHR6wv5TQ6mQHpZBQ6jKXtmbp0e7OTj+XXt/ZMXRte3N2NuVvhT+sreb5HKb8bygg/mmz2pKjn0oRCS3iScXwWPLe2hUhP+MVnSD9HvIaak84iflg+PDbOVnjNK3lsF85W6Jyt0NGwpD8no97+5e+vaHq320NnQqETVhdKFZYlJsk7R2mj5J0LeagfnLL0N7bJjdn/Z08Hl8sxPyhz4W3Y5LSb8s6F8hKnRvLOgzx572oxMhw5q4PL5ZhX7CvhW2yqfGtmy4fe/9fNtRef3l1GYhZU4KyqcHo3jd1Kuyai3rHO3685W8lz+JMtfmTsoe7x3IfyzirPfHPfuTFYo4A1DlgSw2iMyl/Rkofo5nmAa6eb0zMit/OBJ55LPhyIdtq5ROhPKPwI3zklb3QAXhsLs4VyYXq6Vp+uzE9VGhnCF175GfsDFyjltW8IiawvjILIutT+zmKzg38ByNWlUcj7MOWNQZ7wuA4wxgnTmv808kf6eSUPY+D005d5Je+qpg0W2gMLrLWLxNocdY8ntDmazeT7WP3aTKx/rofOpgHpbFLohLWppVnNpkrSbBh/8/OCmPZz0uZ0aZMbm5f1MaejzIW3yahXTrx/cx7xw89899aknPQH6p5hf8yxzCOl/RcobZQ8tMkoJ05af0ibXH8s9NEfKHO2scMip/MoD/dIrm52530E8vr1U1GGzy5Sp1mGYXyaUpXlFCl8XajIguXkfve7JpI2OTn90SJ17ULKQ10T3iajeBu22Dlss9IOjc6mAelsUuiE9V1K81q/S9L6neeDi2Laz0nTCWlTv/MBypz7XbOVmahX77PKM998wGM0jC/ciVGDNonbf5HSRsm7GPJQTpy0/kDfuZ/5AGUuvA2bnC6gvIuhPM8HH4W8fucDlOGzi9Rp5Bt5H4103+a65vv/jlH5H8Eextu0h4F7OkLblftXVO4Che+wfZt+H1fo56KQNrKzj3sh8RNnPzS7KXXzSh5///wjCp2PKHQ0LN/8xO8n9Ds/bVfoDNs43055aA9RPzgljeV+9nG1sTxscuJ9K7SHvI9rZQ9HBpxTWG/T2kMp/3dp3zKQ/SpspnYhLW0dM+x2Ncx6xG9XNTvUr13F9cGgdlX0UfMz+X2sfv3MHQqdYbMXOyjPys/sx66udD9zGOyqNjel9QnT+qPXN9//l/3RfwP+6L8+PZ6vc4D2+Wd0l1v1R1eWPyp9ORn16hj7o+codM7x0Nmu0Fn1R3v5QZkPq908h/JWkj8qvKe1h21dbdm2YfBHz1HaH/YsKr1dFfq5qFefQ9hV7dxIs0PaGYzUzSt57I9q9vtChY6Gxf4o9hH7o/2eg+1Q2hP4fKevswnkUZvbUD84JZ3h9GNXtbOJYZMTn4OhPWa7ehHkDXIO1o9dxb6KWyMn+YTnKTTC9kOhntZ28R2gQLa0bbvOJ37ixrq7wy5xjm6rH7z80Pxdty9cUn/owCfvrl1eve/g7dW7Plmr3Vc/cABbgxQmlNaytnAZ+Z1XniPGBQmt4C/1YS9fQFgXJmDxl/qw/oWE9ZEELP5SH9bHuvj3WNTLp9wOHEmBwyNX4+tq4gutJXszFydgHSAsrH8xYX00AesgYWF9rIt/j0W9fLK8fDjuv2ICX4ea3XwVoH6RsEoJWPcTFtYvEVY5AesBwsL6WBf/Hot6+WR5+XDcf5UEvh5sdvNVhvoVwppKwHqIsLD+FGFNJ2A9TFhYH+vi32NRL58sLx+O+28mga9Hmt18TUP9mZh6cbYMbYM2dmcgX9NV7Hts84TyjGfXWXhuOJvV0s6uQj8X9fZLiNl1NuqVH8qHVwZzCq95JY9XBnMKnTmFjoZ1gSHWeYZYHzHEusgQ60JDrIIhVtEQa8YQq2yIVTHEEjum+V4cya7flTfW55Ue9rmdzSm3337AuUSS5M0qbdRsD9pFTtpqTtrkVnPvnt3B5XLMD8pceBM5oT4vp5x4lYn6JfOy5H0M8vpdEUt7nQx/1ocMUZ9mKe9CpW5Y+abfpRP6uahXF0LMxZoPr41hkV1J4TWv5LEN9/lMSEfDEr9OW0dw1MuCQqfgoXOKwnPgsVZiWWKSvLLSRslDe4/6wSlpPPWzS4cyF96GTU4FysP1Fu/Sob85iE3qZ5cO+6oM+CxDLIdvumvrZ42vjIJToLKSN6LU5aismMfRXzX7gc94vJ2q8Duh1GO7jPZgOeyy0M9FQeeJos9eanLVxkGJZK6NkQzlIZ2yQkfDYh/AN6+G8e/SfxFU6C/VvKrNQ9oXQZdCv+P6uejhpxKGn/Zbntr+leZ3uLch1kS9OqTttTHfU4Avz9L4PLwv3u++JWLxvni/+5aIxfvimgx4n/Ift44nnAz/7hndZWRP96dQ5u/TqZA2h7hyv0fleH/YpfGot3+WY+wL/RzxGmrsa/2I8kHdXhv5dQz7OO684WKlrazzFyXwxDqv0dJ0QsppOqGdSrpyv+8p9xGlHGOI/uL5F0epkLJ/0MJwvtqZ5+h0BcOlwLdIUuss34ILfVtD28vx3dZYztvDFljDeiODb3AtxU2Ds2BccDnmVTtHcafgcpPkxCn4ifPva6t33V6rHrx9/91X1u89VD9wcJRgz4lhR/7mC6pCCnEiD7sujVDeeZSPx1FaSnMxAlVqOZYlQn+pLkYkHd2zmbhI4TWv5OEllbjp6iKFjoYluqK9vMUfFen35a3TFJ6H7RLoaZSH7gHqByfLy7KrL291yiz2siz2Fbtgu6H8Pc3uvLOg3rlUD4PVCT4Gz5JyGLB0N2GcAXlnUd6HIO9swD+jBTKp8MjBuSTPpazyzBec66wYrLjgXNLPY1S+0GrIeNQrNzud7QTn8rmi5wainXaOYR1CfoTvnJIXIjhX2uBAUl67tOsLzhXGDdSDc+GlUpdGIe9cyhuDPHTd+EW3QEHkSmnkj/TzSh4H5+o30JMWJHFQLLQHFlhrF4klwblwmSc2R7OZHIylX5uJ9c/y0Nk0IJ1NCp2wNrU0pdlUSZoN42As58W0n5M210ub+g3Gos3Zk1GvnDgYS7/BatcovEp/hNliKE2zzCOl/VoAMslDm4xy4qT1h7Sp32Asmp8Udj4uzWjrzcgji7MpD9ctHIwF19P9+q/S3n6DsaA+nU955yp1h/VFqTD97X9RSpsjNB3g+RbzUP6Yh3TOV+hoWFtav7UXUNkm9fsC6hqF52EL4Mg2Cbci+w0YiAEcF/sCKu89DIucePsS7Q6vqbUgeYuRYT9rai0I5jAFXURZsJzc7z3wm1PSNu8fLdJ2czAGbQtYe4WIfdR+7c9mpR0anU0D0tmUks5ZA9I5y0MH89ie9utzr1F41uicPSAd7QMLwzSWNB9p2AKYYn/wODtbqRv4hczUPhK/kBlmLed/IVNb52hzktTVgmnzmO73PACx2EcKPaaHbaz5giqjfnBKGk/9+EjaeBo2OfGeuXbFx9om9eMjYV/xkTvup8sz9O05aJyU/zX4WMiv0FnDbqCBZwb/L5U7S+F7WO3hWWH48dpDzX70aw/H4Peg9pD3L1GvOGhRv/tY2xU6wzbOOWgR2sN+97EWaw+1sbySfLRhsIfanMJ6m9YeSvmf0fliIPulBi3ivbhVPzO8n8mvAA9iV31rOg5a1K+fuUOhM2z2goMWrfqZJ4+fmdYnTGt/OWiclP8v4I/+pxg/E/lw5WbO1PmXsi6t2k1bu2npj0pfah/nZH90t0Jnt4fOdoXOSvJHl8puosyH1W7upryVtD4X3tPaQym/88z3/x0Gf3S30v6wdxTS21W+77Y7DD9Fre98dkg7G5a62nku+6ODnA371vnsj/a7zt+h0Al8X6Xvexjsj2pzTlqbgPdVFrvOF96GTU6++ypsVwe5r4Iy7MeuYl+xTbLwCQPZrtRBNNl2hfYJNduljfXFB9HE2wbcWtYWLiO/k4JonpfQCn5xEns5jZVFLH5ZGOvzi3QfTsDil4WxPtbFv8eiXj45aJ8Ph0euxhcH0URrmSboKGJxEM1+g44iFgfRXKqgoxcn8MVBNC+C+mkChSIWB9HUAnwKViEBi4NoYn0ONiJ/84vnLrG8fDjuv2ICXxxEs9+X9xGLg2j2+/I+YnEQzeUMOop8cRBNLZgC14uzZWgbtLGLwRk0XcW+xzZPKM94dg0UtDJ1EE2hn4t6+yXE7KoF0NACaonsphVe80oe3xrVgsNOK3Q0rPMMsc42xPqwIdYFhljnG2JdZIh1sSFWxRCrYIhVNMQSO6b5XhxEs9+VN9bnlR72uZ3NKVfEhuBcIknyppQ2arYH7SInbTUnbXKruX6CaKLMhTeRE+rzcsqJV5moXxxEEwNz9rsilvb2G0QT9WmK8s5X6oaVb/pdOqGfi3p1IcRcrPnw2hgW2X1U4TWv5LEN9/lMSEfDEr9OW0dwEM2LFDoXeeicovAcVhdKDZYlJsnTAoVKHtp71A9OSeOpn106lDkHGx0WOV1Eebje4l069DcHsUn97NJhXxUAn2WI5TCIprZ+1vjKKDgXUVnJG1HqchBNzOMgmpr9wGc83k5V+J1Q6rFdDhT4LLVdFvq5KOg8UfTZS02u2jj4KMlcGyMZykM6vqDDiMU+gG9eDePfpQ9KJvSXal7V5iFfEM2Q+h3Xzxd7+AkUJLYdjUHbv9L8DgyiiTqk7bUx3yXAl2dpfB7eF+933xKxeF+8331LxOJ9cU0GvE/5r858/18nw5+d2V1G9nT/KZT5J63f2pwlcnDl/pjK8f6wS8MaQDdQ5DNvAF0tuB8G0YzTMezjuPMGLdAp6/wFCTyxzmu0NJ2QcppO7IZy50O5P/GU+7BSjjG0IJq7KU/K/psWhvPVOIjm7qgb36XAt0hS6yzfgtsdhh/vLTiUz2JvwfGe7CC34CxvIg/rjYzdlLcUNw36CaKpnaMsIojm7hh25G8OXCmkBgmieTblpw2i6bsYgSq1HMsSob9UFyOSju7ZTFyg8JpX8s6C33HTlfZlew3L94I6B9E8S6FzlofOaQrPw3YJlINorr5kcPK9ZIB2kINoYpBLDoCYFORyjPDLrefSd7uhvuHxQ431Rmgg7bMD0U5ra/kSoBZEQrPDgwSTLNXnF6ar1UZ5oVFYqDbqmajX5vrssJTXLrTtVMqHDRRWroreYzBJvgo3CnlnU94Y5GFwL7YxYdy5cjWN/JF+Xil/b7NTrp++zCt0OGhjWiwJ2oh2Wsa2ZmN4LIaxA+n9HqGfI15D+T27o165jipy9V261YLp8EtC/fojiCV2f6lfEkIeDOfziuZ/S5K8c5Q2Sh4H9JXfnLQ5W9o0yEtCHBBuWOTE41wLTqstW/v1e1CG/fg92FcclG23UjesfNPbJPYBAtnIos9WaGPY569oc8oe+D3o/CR9ORn19i2/YDOq0Bn10Nmh0Bm2scYv2KBNQv3gZGmTtPE0bHIapbxhs0maXWfex5SyZ1KelL2nVcitvY61fmtjZEPUnXcm5K2H30gXrwxIeZdub+p8Hmr9cDL5t3t0zJEYTOwbl9CvxzHp0ijk2enaQtHx/cruDh9sG8ea3W3S7JnmY0l538tAKKN81KvXbEs1G7cbnskxjCZP3G9yaRTyQssTeWR57kloE8tTkz/KSWSkzSdnENYZChbK2CdP4XE55Ik8ppGnNg/6/ACUp8hIWzN8iLA0eZ4Jzy4hXqX+GqU84o1R+SNgc76wq5u/DVCfdWG9go021DfOcko7JigP6zrcR1ubqZiP5fa2/i70mRampucXKlPVQr3o/izxy+UuST+7NsuHP9Y0oV3N7jprW3+PRp25D8sL3hiVfwPmordAT98rq9Bz5f4nT7lMzL/vYSjPRpvdz8abveWzzd7yQjvX7OVR8tZDHo4zlza0/kZ5IZbwMUbl/zLM1y6tgzpSP6/QX0f0u/hWnuE4Z6ys8kzKu/55p8Wj6C223Xot8h5NwsdnzJvozvrIflzV5ytzM/NzC1OFWmGuOFdOGlfO/vxpiwnfvldaXeY1CmLJvp/43hgY1fKKleCvJf6M8Isip7GoV05Ce12QtjUaafoB6eeI1xD6j/SEH5YP76+Ph5FP3V0pEt1D+7FGkQ3zsZZ4zAXiUfPFhCftDED4cGXuOaebx5FAPIYdo432eReuUfc33//X0fzp7g5d7Btc26He49yO5X8H5vbfhnlLcKW+2Kn1kL9WyZe/pb9GlLJ8JrGWZKjJFcuLTq6JaesaaquU/1mrfY63T+zSMVF+yNdIDObvA+aL1CfoT/rGvJRfr5THMSb8TEa9Y3M91UPex6PuhM+0/slQWZ6D8XxqLZVdG0OH5aHxsE7B4XmSMZkm64NL7MtnFTo4pnDOH1foG84PU9pcKUnyOMA65mHbb2l2ynHS9rqkTa69f3V3B5fLMT/aWLP0jeT5GDxnulkqu4bK8rkZ8jhmwGNeobOGcNd6+M8QzqhSbyLSx6P2b1p+Mwq/2lwzKB3E+mqzmw72M85pf767g8t2PKvU/Wazk981TvZ0MP9byjmNbQm24dZm5xnbbPZjeUzyfgjPXVwG5/Gu8q024dzF9gGx3LN1tFer+Qia38c+wvkgz/Wt3z4fYDLqlQ3r8DjRQv9Y5heWwRbgI78nnpbIdcLTRvds2x69HPKA5RhDmzsFQxvXUm9S4YvHHtuONR4a2nym0RijvEH7R5u30dfQfBgtH+dzpMPPRpTySf5HLgZbw12j4Gh2fh3lZZQ8tmHYXrRh7JtoazK0jdq4i+s7n++t8Z7Gr1rj4V2TH9oh672cwmyhWFiYmWo0irXp6nwlaS/Hmn5pam62OjdfKJYapVJ5dnqp6U9Xpouzs9XZhemFxlxlYX6p6S/MTTfmyuX5YnmuVp8rLnn765XyfKPYOLGfV24UyrPFpaZ/Yne+VK8U5+enivXq3Fyjn71EzT7jXIFjCJ/j+JOzbZ6vP9cab2H32vSAt2nmOK19mn25JqZ9VfADvrQnmZ7PZmpz4QjloV3kPmrvn6dsg5S/Avw52TfQ9r1wz82l0WZ3+/a2nhcGSxXtDBLX62PN7nb79ipcYj95g1Iez+rYp8EzPl7LjSlY2rzEerYm0v1ewWM9uxn6iM8gUedzxDu2nX2FrELXt8fh+HyQxnOgc4EZbU9B0kSk+zeYh+OE75bxXjHmoR70ew9TZOH4egj8eS4nSbMTbAu0fT/NTuCdpPf4a/bytRzjFn1sHrfaniSWl7GTj3r7jfVV8x21McA+Z9ZDT1sv4RiIO5NDm4B7Ct+gNbC2p4B12V5L+edhzjlMcw7aJ9YXzc4wL1Gk27E0e03a2lX6RTvns9y7zBA9aQc+Q/q5KKj9KrK9R7n6ztoC+UcV4Udb82r97M7mNka9faatr3GflcMOa3ufmm1j/0izbdpYZzugrVl9exO+sY7nS2l8R20c8zjH8i/COP4rHt8xbp8vivx96OtzlC/vxWjnNb59Gp89X+fhK+mMifnSzpgihXZSG3x6p/nXyzinTmlzKrad51Sfb+sS98GEUl7zd/NUHmXu23vSxuV6yks7LtEP/Ssxcym2A+0s7w9p4xPnaJzXM8QL0sD9Mwk9nSEaa5TyiDdG5f+a4uszptgalx5p9mIyz/gc5cLrdin3G8DDd895/3ead+0C3V1J/d6r0F+qd+209Z92/zXwemnBNw40v4/XV9x3OIbj7iHwOSfODWj3ed/+py3dyhOmSxLnIqPkaWdaeFfvb9MZSqizVX7/I+5ezO+QjcLxrt0NEPvBY/H3wE/4XfITNN1fH/ltlnYXh/Un7j4L2ywp//sem6Wtc5CvR5o65h8o+1I+vdD6j3UZy/vOC7VzOu2dFxxP72E3ezED+wg1zUdA+bCP4JOFS/36j6IfeSqPctTGEe+B+nTVJd/dGbwH/zuBznjqxWKxMV2Zn51eKBUatYWl3uOvNGaq042ZwlSpVqmXatV+9vh9Ms4oMp70yDitP8RYGQ/WWAIWhyaMG4Ncb4n8k9Sh0tg/CXMn1O+foHx4b1TzFfJKHq+B+90/0vY8LbB4bkbsuLGhrdlRRlGk+zso2yub7/8b9j5yYV5bA0bU5g0KzxmlvLaHjfeXHwO/n8sxTZTdBspDOz9BeTiPbKQ8nEcmKU/bY0wzBl3y6c9YTLss6GhznzZfD0pH269jeVvQ0fYCtX0UHt++ezcanYxCR1uLou995lk6zTgflPfapfzPndXBPOus7jIio3OgTKH1e1zh3dAOzGnnKxHJBm0Q79HjORfrPNoP1lPc/2Hd2gg84L1sTprdkXIO88cp7I4m60Bz6VDJOq08RRau3j/vw46jvkqbcD3pG0dIl8fRL8AYuZTGprZvrNkdeZ60b8xrOW3feFjnaa3vWWc2Qh7rzCTk8fjEEMQoE05JfkHa8XlpjA0WGmyDeX0Xt/crtj30+mYsASvNmsSHlXattLq+6Ukran0zaoiVofag7JPW/kn6zDroW2NjvSXSwdRn/KyDmTD8FNPKdbE6aKk3w44V8n12bdzE7dk/SHOW1Ivbs+d1g5T/Jvg7j7R+p33vh9vJNPlOYdK9fvaffHfpkZZ2h8P3TkfcnWGUHbZN7orwvYjvwfzuu4+6nGfwS7m/LjLT9td99zbZN8wqmKjzq3tiq3tiq3ti+r9p6Qzzntgv97knxvZZyv8U5rZfidkT+zUo85PVPbH30lLsif1kdU/svbQS9sR+G8bIH6zuicXO0yfTntgfxNhgocE2OO2e2C8rPpyU43eK0I+T+1a8fnn17A72/0k2XvD+BPT3X57VzSe2+7pmd552t9k9e6lFU7Nd7r+9rb8LA6WZqs+PCfueQmUhjV+B9JcqJlja9xQ0H5Xv7KI/9WSzU47zssqzEQ/Wq4ZYbxpiHTXEOmyI9YIh1jOGWG8YYlnKy7KNVnxpdnBYdPV1QyzLsW2pE68YYq3ar1X7FbKNlrJ/zhDLUu/fMsSyHNvDOh4tbfSwzrWW/XjEEOuDMA99ENpoyZelXR3Wefu7hliWfFnK60eGWMcNsSx9k2Gd01bH4/K1cVjn7Q/COs1SJ541xBpWvX/NEGtY9zreNsQKaaOlLJ5tSOwBl+S74HxG8QKdCQTal6/57gKE/Q5GJXVsAz7n12LV5pS8Qd45nS82yvXC/HylNF+bmp6ezhC+8MrPeM8y7fcHRNbrw8h6XrtHlgO5ujQKeeOUNwZ5wqOT/QXEf5gz1Mp8Gvkj/bxSnmMspO1L+Q73OqDjiw9/d7M7b43CA577+e6paeefGKvgR2d3eMV6rGdZqov5GaCvPcffGXqOdJHe9c3uenzmyLxwe7MKn5osRhRZaPcXsoSB4xTvoro+Psnuj9fT2tlhvT8eOIZMjfUR+Rm2GDJ/vaXj2v2+uHvIkcKD0I5avPwqjZ3lvo/+N8/uriP10saQkfL/C9zn+K3W79X76N1t4zg0Uv5/a8nL6d4Q3EevOz5O5vvofxPkvXofvbeNq/fR9XZZ0Fm9jx5vA6zvo/+Hs3WaaeOESfkN53Qw/+PZ3WVERv8Z5r9Mq/zqffROOU6a3ZFyDjPtfVeW9ep99E6ZYbuPPgnj6PRzOuWRThT51yjyfPU+eidvmO+jcz9b3UcX224dA2+mtDBVLU/NFRbqUzPV6Zl+YuCt+pCdMqs+pN4uCzqrPmS8LbH2IT8ZY7/ifMi4OF83w9z3mXO6y4iMPgdlrlj1Id9LS+FDXrHqQ76XVoIPeSuMka+v+pCx8/TJ5EN+PZAP+UkY9+89a3bKGfZhSdoz1uzwLLIZbXb4XgN8u7QO8qSc8DoehteC8Jpr4cv4RJrYlhEqz7/H6Nl3oC+xjdIOfIb4Un495En5LDwTHkV/10De+mZ/WOsIa+0AWMJXXim/dpF8aVhrCGtcwcJneDZ1sNU3IWKLV2fqc5Xpcmmh3JirzhZm+1lX8VlyV/uibt0xHg+p49LJs6WKS5clflg+8luzgVKXz1Bc4rsbWrxD7fsjS4WlnWeyLgT6Jkvq+HBCPxcF1c2iT65ZRa7aGpu/fYbrVO4/7R6BdsdqpWBJfZe0daDcH9R8WpYpj3fM087el/Ibyb9E65t1xOve1t+FAdNyfSP578Ga4K+ck0xvGL+R/OstvpPuAKx+Izld7FuUudU3kv8W9NFyfiP5j2g8B7qvteK/kfyfU6wvV7+R3EnaHuqwfiP5j2Ctos2jmo8jPEpfaPdHXeJ5VMr/Kxp3gb41rM6jaPe5fYa0p7VzEUnaOQyPeW3e1OwBj3lt3y3tmBdZ9DvmNT/Q931c3/ddtTHA4wPHAM9vOA/EfaPUJXmPJUOYUeSf+7S7mEnrbRwTeCbyZ7QfJ/TQ58G6cd8Zz5/bwfxz8tu0M9TV74x3/l39zngvP1o/r35nPPx3xrfCOL7w3O72a3Y0Q/xFkb8PfX2O8hVeV78zrq9Rl9EvXf3OOOThWk7Gi2/+Qjub9jvjMkf/dw1PB60vXAYA",
      "debug_symbols": "vb3friW5cWf9Ln3ti00yIkjqVQYDQ/ZoBgIEyZDlD/hg+N1nM5jkijrlw8qz9+m5US91V8XKf/ztTJLJ/M/f/tef/uU//s8///mv//tv//7bH/7Hf/72L3//81/+8uf/889/+du//vEff/7bX5//9j9/e4z/SbX+9ofyT89/tt/+oOOf/bc/1Oc/2/M/9/HP9NsfUhqQnzD+Wa5/yvVPff5zVGi2oC5oC/oF/bEgLcgLygJZsCr3Vbmvyn1V7lfl/HgsSAvygrJAFugCW1AXtAWrclqV06qcVuW0KqdVOa3KaVVOq3JaldOqnFflvCrnVTmvynlVzqtyXpXzqpxX5bwql1W5rMplVS6rclmVy6pcVuWyKpdVuazKsirLqiyrsqzKsirLqiyjch1QF7QF/QJ9LEgL8oKyQBboglVZV2UdlduAfoE9FqQFeUFZ8Kyc04Bn5awDbEFd0Bb0C+pjwbNy7gPygrJAFjwrl8cAW1AXjMrjQI3m5zDa34Rn5TIUowFOKAtkgS6wBXVBW9AvGG1wwqrcV+W+KvdVua/KfVXuq3JflftVuTweC9KCvKAskAW6wBbUBW3BqPw8p2W0wQlpQV5QFsgCXWAL6oK2YFXOq3JelfOqnFflvCrnVTmvynlVzqtyXpXLqlxW5bIql1W5rMplVS6rclmVy6pcVmVZlWVVllVZVmVZlWVVllVZVmVZlWVV1lVZV2VdlXVV1lVZV2VdlXVV1lVZV2VblW1VtlXZVmVblW1VtlXZVuXRBuUxoF8w2uCEtCAvKAtkgS6wBXXBqlxX5bYqt6uyjMM7WqWMwytpwPjr/m/agn7BOJgT0oK8oCyQBbrAFqzKuirrqmyrsq3Ktirbqmyrsq3Ktirbqmyrsq3KdVWuq3JdleuqXFfluirXVbmuynVVrqtyW5XbqtxW5bYqt1W5rcptVW6rcluV26rcV+W+KvdVua/KfVXuq3Jflfuq3FflflXWEWhiA9KCvKAskAW64FlZHwPqgragXzACTdOAtOBZWWVAWSALdIEtqAvagn7BCLQJacGqnFflvCrnVXkEmuqAuqAt6BeMQJuQFozKdUBZIAuelW3s6Qi0CXVBW9AvGIE24VnZxvaMQJtQFsiCUXnYR6BNqBeMhqZtwPjr41yMZmX+b55/uI7jPJrVhLagXzCa1YS04FmnjsqjWU2QBbpgVB6u0awmjMp9QL9gNKsJaUFeUBY8K7dx1Y1mNcEW1AXPym0chNGsHEazamMzRrOakBeUBaPyUIxmNcEW1AVtQb9gNKs+pKNZTcgLyoJn5T42YzSrCbZgVB5XwmhWE/oEG21nwvjrOuD5h3sbMG7e8oDnH+7PzbDRUiakBXlBWSALdIEtqAvaglU5r8p5Vc6rcl4b5nfdj8cg21Q3tU19kd96P2RQ2pQ3lU2ySTe5YxwHvwOf1Db1RX4T/hgb6nfhk/Km4UhjW/xGfJJuGg4/xH4vPm7PzW/G09hfvxt38tvxSWlT3lQ2DUcelf2efJJtqpvapr7Ib8wnpU15U9m0HbYdth22HdXrjX2raVPeVDbJJl3kz7Hjt938QXaSVx5npu8t7XtL+9rS6s+c4zmg+kPnpLJJNukm21Q3tU19kT98TtqOtB1pO9J2pO1I25G2wx85sw3yv1sH+d/tg3STbaqb2qa+yK/2SWlT3lQ2bUfZjrIdZTvKdpTtkO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7bDtsO2w7bDtsO2w7bDtsO2w7bDtqNtRt6NuR92Ouh11O+p21O2o21G3o21H2462HW072na07Wjb0bajbUfbjr4dfTv6dvTt6NvRt6NvR9+Ovh19OdrjsSltypvKJtmkm2xT3dQ2bUfajrQdaTvSdqTtSNuRtiNtR9qOtB15O/J25O3I27HbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO923nc777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO92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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3briW5ca77Ln2ti+QhGEG/yoJhyLJsNNCQDFnewIahd1/JPxiHqvZgjZlz1rrp+dXfyRg8JY9B5v/88m9//tf//o9/+fUv//7X//rln/7P//zyr3/79bfffv2Pf/ntr3/6499//etfbvV/frnWf2iMX/6p/OEXYtK/cst1/SX9O/e/p/174u+4+v67/132v4vo39r2X9a/re6/+9+97L9D/477+bb+iv7luv+y/pX9b9nP73iNHa+x4kV/+IVXvPBX9G9p++/+d51IJzfRv/3+/+VawBuoGpgyTBmmsClsihSDsWHFUEEUZMVNYW5YuVZogWxY+QbAr/MNoxiMDWwKmyKmyLIsN8xmIArzqgZjQykGq1Du+MxaDcaGdhl0g7mhm9Jlw8q6WhfwhhV5BdrApqzIA8QUsWfEfmLaT8z9E+W6qtMwWgnZ5Fq9nLqavWkatebERt01JAhErpE/N/zXhv8a+69xd/I4S3NybXo65s6IckffiZwszqW4hrQphebPIW0NxEa9OrlGrpFrw7XhGkpMaRihmVASIxSW0txUr+5kz9Vi8at1aX1RXyFoEXJcacVgLELlASGflcQIuavkIWZxshxq1+XUnaykW3GtWE42rzmt+nPNyq01NurFiZymEXUn10ZzWlZ40WqCN/lz4mG95jSvOW1a/etXcXKtXE7LiizCC67kzzUP28jJYtB7c7IYdHKNLA863ooJmka8GnX831VaSuKap6hPtzfNHnmK6LJYkaeISmgWU0KXs9JGSJGSP9c9rLVbN1kMiKqTx2C45u85rfrXCkiM0DVVEBtN11aK2qrtY6Vo0zAq1cm16s9VD9tca/5cd23Vurbeo0GXU3cSo5WiTcNovd2bXFtvd2PQbbmvlKPD7QVEm/hqTvdv9BWWV4o2sVF1rbrWXFspUuqudX+O7vh1Bg2jcTl1I3aN/TnxsOLa9OdWe0UrbbL6FKVVwzaJ0apX1EFLW62KrNhvGkarhpGAyGkarXdmExutd2aTh2C3wqG5lfX2DMRq1TWlVdc2jU1ztXWbyGj1kqOAyGj1JJvu3BgVNI1WT7KJjVat2+QaubbKSGm4ttK2aVleOTlXy7BJjNZ7NAjERqsd30RK9bqK0zAqrhV/brUMSqsEN4nRKsExQGyEtCmREbmGtIGGa8OfQ9p40RoTKq36NwQ0jJCiCbo1vkumot/fRE7TaLXem1xbKdrERs2tNLfSPET3EN1DkIcgD0EeYniI1UdxWbQGvpuG0WotNpHRdG29ZZtkU72qk1mp5XLqTh6ieojqIZqHaB5iDeu5LUJ6lSy9dbXym1wbrg3XkMq+CGlTEqPVWzGDlrZKta2WcJNrq0VXWi06T9AwQpyV7hyXumjFeZMYrTgLgdho1b9NZMSusT8nHlZcm/7ceqNkxa+v2Cut92jTNFotw7xA02i1DJvYaL09m8jJQ5CHIA8xPMRwjf059rDi9qaHmBYCI4VN9hxGCptCM3sYKWxyK82tNA/RPET3EN1DkIcgD0EeYngITxuxh2AP4akk8RDiITy9mIBvshDjak4WYqwSnBVERquVnw00jVCCSmLUXeuukWsoNxDKTWkYsf8G0qbkv7bGsZvc8nTL0yzzahk2mWUuxcmfq/5cNXvsKeJmv8vdfpfpcrL4saeDPR2Y2m9yTTyseNg1R52rPWCkQ0k2ydWcXCuuFdeqa6iJoNUzbRpGSAcI6VAio+Ha8OeGxU/wRhGIjVbLoDRNm4jV6suwDDAZxEZ4P5TIaI14NoU2jVBzlJaV1ZZMvBUg1BclMlr95aZpND3E3FYaRgCbhhHe+AnqTtOoulZda64117preANASIcSG612VwnvtNIwEtfEn5sev4lloAsohuVqjiXUhpWislBXqipQHHW1SnE4Ys1oY6h8BfZAGGsLpTvOEjgM0XFvLFdgD3Rj6LIN2bHBbgeSY78CQ6VQKdQR6kjqdNS0KYqjrssBZw1kw3bVQH+2lRKIXyPgdKzdsYWqkRxAPMDA6cgtkB2lBoaqZaFIgTC26n6/yLHUQHbEqqKiFoBiBNOor+rZtZ4piiOFSqGOUEeoHKqmDahpUxyO+jIspOsKJMcSaolni8cXnXlZq6kNvfnG1YgahtpD7aFSqBQq3qGNwxHv0EZxxIuzcTrOUKc/i07bEL+23m5024bDsYZaQ22htlB7qHiHFPEObeyOWNHeKI4ot42hSjwrHl901Pei40ItgAbEA+ttYS0AxeGIF30jOVKoGklFcdT4ElAcsWehKFfgcNQCUPRgolEfQHbUAlAkx3oFJnU6NiSegdOxD0cqgeyIlmtjBNMCEKA4agEoDkc0ChtdxbzfEIlfr8jEO7SRHdFAbxRHLSxgj2CrX7xXboHTEY3CRnZEYW0MFZsWG1fi12pqmyi3jaHOUGdS58Z+IW0bQy2hoh9SRPXcyI6onhtD7aH2sEBhd1yBiFlfiEZhYw+cjhLqShsByEC3ru712m5gCqofYG5osIT/iS0sRbTZG0OlUCnUEeoIFTtaG9kR+0obp6OWycKK+rYRKgOno5YJsO3dqq7dvRIZkWvk2nBt7F2sjrn5JjaS4kRGqENKe/W2N1tTvomcplFpTmJUXatshNVlBk2jvvc0bmIj21/pjVwbrg3X2DV2TYrTMJqX095L6d32V26aRsW14s9Vi19ve8/lnqTvPZeObnzT3kHpnclILicxms3JQuiKvRKqggCno1YFRXFEK7SRHZtXUu2+FXsNXJVp7TJ0zMMNKXA6ao1XZEeOYBzGJFQJY7Yh2cl2JDvZlmQftiXZh22+9GFbkn0U12xL8qauWyRd98WVhm6MdF3YV3KN9mL/TWS0Xo9Nw4hdY39OPKy4Nv25GdrUDYCOXfRNYlSq0zCqlxMZNddWW7W2ETom5GsboWNCvrYMbppG6/VQQtex9k267rUjXrrbvjFUFI8i3nX9TbRNQMzBDVd9Q1QEA+SN7FhDraG2UNF4KfZQezyLWog0CiZiimjBNnZHDpXjWQkLEuqMZzGc6SvFupmviM59ozii11v7HF07977q2ESCNg5HNMdUgBQ4HdGRbGRHDJA3RjAOY5zUMCYwhkhiPKmIOdnGsfGeEVyB5Iih2tqRIez3b0RfubEHimMLtYWKrnNjqJgSbMRPjIUozY0UiLTxQvT+G8URA7iNocJDY6Or5aqBwxFlvJEC8cOyUFOsKI4o7o2haooVQ6V4VlM8F6LSblzPrp0kKhinboS6PIcKCnZt9BCcAjaiYDcOw7r6CsNQkcyNPdCN6ZrCxgjWIliLYC2C9QjWIxhFMIzwRgNOR/QbG9kRrdHGUPHybqTAMDbD2PRg7SqBFOjBMCgxjGA1gmFasra07j7zCvR80FUJxR5qD5VCpVBHqCNUDpVDlVAl1BnqdBUjFsNQo7ix8bCxhlpDjbT1SFuPtPVIW4+09Uhbj7T1SFuPtPVIW4+09Uhbj7T1SBtF2ijSpuOetUlIumyhiG5GEa/p2jEkeCkYiiPa37V9SLoqsXE6atQVxVEiGFrate1IpC+k4jAcaGk3kmMJVVOhKI54IbkChyMWKDZiML/q5NBRv2IPFEcKdcSzIyxwqBzPIsVro43gHbgRJQTUtYqNmDOslgvjGcPhiF5kYw8UxxbBWgTrEaxHsB7BKIJRBBsRbESwEcE4gnEE0/mOYqgzjM0wNt2YLnxs9GBweTDsgRGsRrAawVoEaxGsRbAewXoEowhGEYwi2IhgI4JxBOMIxhEMfezaMSUdPClikWQjZoarydRFEulAqKsaTU28ojhiHLUx1BZqC1VTrDgcMTDcGL+mJa8YP4xXWpHjJzh+QpMpwOGoyVQ0dWCXxDBULW7FUGs8i4ZJsdVAccT4YeN01NIEjviJkdR4Fm2qzOUujAJYO5cDqx73vsNClMXGUGuoNVSUxUZx7KH2UPEWbmRHtKkbhyOHyqFKWJCwOyNm6A7WFuGA86OhOKJH3xhq1bWfG+aG1gxkQzcFeb0AI5QF5gA8dPQBmpeTafCB3OSaRqjDSbsE7mnhTdMIEzpQv5xC8+fIw5Jrw58brsE/EL/GYiTVaRjNy6k77cnq6DZZvUl0wnnPoJtOOAfWQNbkcmANRGn1T5tQsgiCJnwjOVKoFOoIFTVckUPleFadOREX9eZUFEf151R0FWMJQ7eAsYRhPKtu2ytLSf21FcURXvaKhIWJAYS6IknjCuyBsLBeWeIWyI5YptpIgdNxRrDpxrAFYujG9pLJBJKjLpoo9kBxhLvzxvXDa2tlYIRhKI5Ykts4HEeoI1S4PW8MFYthG/ETFSiOSPHGlba1MTIwBDEcjvBn3RhqLYGhtngWrvgbxRFLkBvxw+uVYE2x4nBEcW8MVVOsGKrEs5ri1QQxKu1GPLtqlGAJcCPUVY2wtVLXWuyNwxEFu7EHTscWqiYTCE/2jWGMwhhFMIpgI4KNCMYRjCMYRzBBsAlkR3iXbyRDDCsMkzodscC80Y3NWgIjWI1gLYK1CNYjWI9gPYLp0YUCFMfIB2zObORQOVQJVUKdoU5TWY9lbAy1hFpCraHWUFuoLdQeag+VQqVQR6gjVA6VQ5VQJdQZaqStRNpKpK1E2kqkrUTaSqStRNpKpK1E2kqkrUTaSqStRNr0ZMbag2Ls2mzEa7oRRx5w6gl7BmtRnosehFhY0f5uRNWYC5GgjeyI6rmWZBlLLhvRGm3sjj3UHs9SWKBQRzyLHqfhdJbuhQD1iImiOKJ5XX08V90FWQj3S0N2RLuzkQKnY41gNYK1CNYiWItgPYL1CEYRjCIYRbARwUYE0xQrhiphTMKYhLHIhzY9mB4D2UiBHqyXFhjBagSrEaxGsBbBWgTrEaxHsB7BKIJRBBsRbESwEcEw1mir9sFpxJAdZ6jTVd1/2jgcS6glVHQ+GylwOmqtVgy1t8D4YaqB6yfW0JKxUmNIjuhxNoa6ipsAY8PeJmba28SMFRoAlr8X7N1hhgfn6mrvRYTqxEbkGrk2XOO9T8q6pKI0jbCEpMRGszrtLTDmqzmxkW2B3URGtgXG2DDaNI1QzVasuBcnf448rJ2oYviIKNlpHcbOkRK7xsNIPQ4E2AOnIxZqN9qGJOvayUZsXq7ihkunITvWEkiB07FFsBbGeqg9jJHlopClQcbl1J0sJ4Sbk2tSnYYnZF6BFOhZMa8WKI66jzuBniZdKNnosYfXqCEFRrAexnqoFMbsPBZPL+Fp57F42rnLm7qT1acprtlZM8bwZZ3bEmwubep6WkvgTaJUXLMTZqInSZXEyM4D3jSM7DzgTa5Z7RWslKycFB2wKPlz7GGZnDwGdpJU/CSpXNM1Oz0nepJ0gqZR2SfvBA6mStU1T5GeH1Vye56iYu+jFE8RTo9sspjCzWQNRwQbR0o6XAENI3ENDTxoumZnYwWeJrBczXdDqvluSDXfDal2llmqHWaWWl2zs44C71O1jFGLUneyOGOtZdM0Gq552ir7r7H/mvivicdZPM7mSnCTac3aUdFxzLLcSnWy3Gh2AlhwokQJaVNyzdOGdZrlASI4W6JEzcm14dpwjV1j17RnBrHRLE7bG0X2OGRRuZxC8+eqxU/PnvZFaOcI1J22D8rdRg4jKU7TCLmrZCEIA3klyyEdHyiRk5U0Vdfa5RSaP7fa7rWmJRgXKK1+d5MYDdeGP8cell0Tf05cW7m71rkE+zYgDAo2dScxMpeNm9iourZqzhpwCfZr1mqZwAllDUkETiibphHehY7AqDCKqDEbQ+VQOVTUmo2hzngWTdjyWxBdM9k4HFGLNoZa49kaFlqoLZ7FO7GOdgo2aDaid1XUyqYIH6mV/YwOZrkE3CiOSNBGWFiVlPEibKTAaQjfFEN2LCXQjWE4YUiBMLYqM4YThuKI2eXG4YjhxEb88MoSXR3ZOBzRuW7sjhKqJHU6zlDx6gHhsVKXJ4HgAoqNmmJFOJytXMepVMMeKI4tVLyDij3UHs9idL5xOGJ0vhE/vCq4Dic29kBxlFC1qQHOUKc9O3VJZG0BT2y6GOLZBpyOmswOhEoLNZmK4oiC3ciOFKomE4gWdGMYG2GMIxhHMIlgEsEkgs0INj1YQR+99rSnXmCxcTqim94ojjVUvLyK6M42hrEWxnoE6xGMIhhFMIpgI4KNCIZh19ornzo2UYx80EUVxRnqdFUHKBuhzoWaYiDe443rJ9YG+dQRyTqoOrHRsxFp2xgqClYR9XedR71xOKLSbpyOGDRuFEcUISO+aHSB6iK7kRxRfzcmdTqiCDeGsRbG0P4qov3lAaTA6YhhyUZxHKHqnRlAlNtGGJvA6Yj6u3EZW7vBU5dPNrKhLp9sDLW0QLegHrUb41m9eYKA0xHVUxF1UhHvpjCQAqcjutCN7IjBzsYINkOdSXVjdLVAN0Yl1BLP1lBrPNtKoP+E3quxMalhjMIYhbERxiLxFImnSDxF4ikST5F43XBSnBFserBxlUAK9GAj8gFDpY01gtUIViNYi2AtgmGytLa359AsAWK6tHa6b5yOqNUbxZFD5VAlVIy5FVHyG4chX1cgBfoPM/qhjf4TOMtj6D+h46iN8WyPZ3vYpbA7Ig4j4sAlMOIr8RORNqzFGPoP4x4tw1BLDXQLOnhaO/NTB0+KGMxvDLWH2kOlUCmp0xEd60Zx1LQBNW2K7DhDnf7svEogfq0Cp6OWG7CGqpFsQDzQgdNR65kiO6L33xgqXrKNFAhjq+XCoRzg3eNjlGPMwXijNmshbE5h6wxu6XmtZMoY7axjyYtHMPp546SPpI+kc9I56ejijSnxDEZLooxzus4SXJJe0vO1JsbvMlir4GYKpqRrnEUZz0ywxnlzTyzB+upsDr1qeW0ewauLb8udYPEI1hWizRIMX5DNq4ycU1hKNik9D6+Qzbj4b51wXszBuADQOOmSdEn6TPoMHQMa5xGs6d0swbUnnsEt6S0931ti/G4F48CG8QjmpGucmzKe6Yu7xnkzJZ7BWJ80TrqW12YOxg1SFylzMPx3jGcwfHg2axltTmE1LUOZgnF/lHHSZ9Jn6Dj565z1Gazp3SzBWMXY3GpiDu5J7+l5Konxu6w8g+G3ZJx0TjonXZIuSZ8tsTjj8JCx1snNIxg3ghknvaXnGyXG76LdGFo/N0swJZ2SPpI+ks5J1/dRWd/HzSMYnlrKrOW7mYJL0kt6vkT89RDRhTYKN3e0cimvZwreOyzYOEsw2hBjDpakI86bUT+NYRPvqehOwWYOxvqasQSjjDa3FBZpKU15BqOMjDkYK4jGSV99nDPyBO84LgZ1lmDcuWc8g9FOKmPg4QybeMdxvMi5J5ZgtDnGScf7aIw8wbsGR1nnGYw+YjMOtxlLMKewuLGuoJ5g0OJMiWewlulm19eAIzHyZIK1fDcnvSa9Jh1trPEI7knvSUf/aEyJZ7DW7c1J56RLsiPJ/kzxRFkvH6BS4NDiPILXapxz0pFevdoTYxhjpNd4xR+XeZYC71Bc4lmwX9RwFWfB2KbhisuCxZmGSxoLVmeMkV7jpHPSOemo28YcrDcwbh7OOHnkHHHQ8Y9xTxy/pWMhYwlGPcelljdzsN7QuJmCkQ/GWZ/BaIdxwWTBLpMxJ52TLknXPQNl5INx6LjuxHkEow4YUzCOehonvSW9JTs92e8RTyzuNFxbWZruiyjrzshmDuaks3pC3yTNiY1WSjeZBo9g/K7ehgLSIymK01GPpCiGSqFSqGP7QqzbdEvgcJQrkLZLddF7Tp2x9rjQD04v3HuHN5YaOBz9WuMbe+B0bKE2cezmvrB4BOvZ6c2UeAaPHqw3HUxlSjyDpSXm4FkSR1g9emSc9bA5bH93oadq1BroWTTaFUiOPVS/ALbo6SNNm/rJGHPwKIkjj9RzxnhEXKUkTumRlJ7ZEkce8VUSh0340jhT4u1Lf2NtgeJoLvsLQ+3xbA8LFCrFsyPUsXcRb+QaOBzlCuyB4jhboKtwrsF9swXDK1w4WzC6wu2yBQs6G1fbs1GbnqHcE8/gnvSedEq6JlZ5JH2k57XZncoSrBu1m0fwTPqM5+FS45z0UhMjQysY09HN6GY2o4s1Xs1xRzynXgAsyj2xBKOpxd22BYtBxhg+GlPiGYxuxjiFncnmdF0va3WGzao8g9HdGkswhh3GHNwQh6YswehyjEcw8sQ46SPpGEZv5qRj2GGM3yIwyt2Yg7FJj/uA9YLXzdgac+7BJenobjfXpNf0PF7tzagPxhyMYcfadV08gjUfNvfgkXTNB2VOOqfnNR8EjDq/GdOntZm7mJyxM9ZwB3HVIRduHNYrX517YglGq2acdKTdeAT3ZLMnmz2FpRSWUtiRwo4UdqSwnMKi4cPNxhWuPs6UeAZj+mEcOpx+nDm4lMSUOIWtKWxNYVsK21LYlsL2FBbTTtzDrFfOOkf+4NpZ56Rz0jnpknRJ+kz6DF2XvYyTXpJekl6TXpPekp7qBvyVnZNOSU/p7Sm9PaW3p/T2lN6e0ttTentKb0/ppZReSumllF5K6aWUXkrpJU0vKc9gLVNlLVNWHsGaxs2oJ3iX9aJ7455YgiXpWs+VZ9JnPK9LXWMqc7CmdzMFow00zvoMRl9gvGwy2hk4Qhuj3TNedhj5pvfnGEsw+nquyhKMMt2MMmX0C3ozDuN9gQtz46HMwRqfzbCDPMf19s6UeAaPpKNcjLOenkcfzaIsweijjYczTm05Jx3ts3FPDJvIc1xga4x6aLzsCPJc8N4Zz2BKjFGmsQSjvZWizMF414wpGH2Qcdans47BjGETZQdnJOcRjHoorEyJZzDK3TjpPT1PyQ5lPT2PfJhIu47HjGcwxhubUaazKrNxw7ac8whGmRr3xBJcU9iawrYUtqWwLYXtKWxPYSmFpRSWUtiRwo4UVvNhc9Il2ZRkU5LNmWzOCKvjMeOeOMLihJdzCltT2JrC1hS2pbAthe0pbE9hewpLKSylsCOFHSnsSGH1Hj9WHsE6Kd1MiWcwTrEr63hsbSgXvai3YdlCL+Jt2JptOv7B1marWhai3BPPYEz+sN3YcHhrsy5FGY9gvI/GSdf839wTy5o7XuD1PnZsyzVs13VsuTWMeTq23BqWpTq2xxqu6DMeJfEI5qRz0iXp+sGUzTN45a1z/C6u3neOOOAeX+f4LYx5nOO3+no3nfFbQ3kGa9o3czDVxEnXfNiM30LdwDl356RL0iXrM1jzYXPoOO7uLMF6kH8zB+OTMsZJb0lvyU5P9ulKjHii/uAQvHNPPIM56aInshaR0zTC52WUTMMGX1cio+pada251lzrrnXXyDVybbg2XGPXOLRptN7XTa5N16Zp+rkfJTZCPVUaRqijSvZr7CnCitQmt9zdMt5JELll8l8bbnn4r7E/x/6c+HPiz02PwfRYedrgU7TJYoDTXZvMMi7D2WSWMe7ZZJbFSwsrUJv817y0xEsLK0+b/Dn2GLDHSjwG4rGaHoNpscJx9E3kZJaxlbfJLGMbb5NZxprTJrfcixMW49DK4syWMcrJeASjHhqnsJJ01MbNk407RjTOSS9J18s+lGsPbldiCu5J70mnkngEj/T8SM9ruqoyJcbRiQbWdG2G3sF404zFGRtzxqUnRlgC62KoMkrKmIPxbhlLMCWd0vOYEaJX77oBtxmzos36MbDN5IyVHmcJxptkjN9iMN4mY+gC1rRsHsF6e6gypWc0/hM8WrCWy2YKRvtgPIJn0md6HrMHjIC6rtBs1hGKMkYf+hU7HX0YJx0fODNev4sNVr0q2HkGo03YjLQYU7AkXdLzgt9FPcQqy2Zcl2OMd8d45SE2czs+E+icdLR0xogD0o6VFWcJRh0znsGars1J5/Q8WnNsInccAzdG3TMWZzg4d2yjdR1BbC5J1zQqYzUFziR687CxOmlsnsGdgnXjfnPW0/OYyW3WMmJlCp5JRztgDMcb5LMe7NqM+mY8gmtNzMEt6S09j1nIZrw7+k1IHAt3TjpGvsZkTol6s7CzBKvz4ebpzOq5uznppSXmYIwV7FuSM7gnXeubMg7BYNbS9Wj4ZnU/VuYr8QjWtGxO+kzP46CPsh7W6ooUuGK5v2+JHsg46WidN6NF2IzRnLEED9827lgbMeak4yrSzUgJKbKjHstSnIbqZKyIQx4bkxrPwjlcER0ndvT1zmBjSjoh+VUZ0UZy9L67zXrJ2uYRrNesbebgmfTpz++LgjejAnVgLYFkGUo6HDBOOrpKYwnGEGDz6ImnZfq++tc46dISW2no7b+KempqIzmWEjgca6g1nq3TEb0KtmsJR6Gck45RjDGSg+hhv8eZg9H6GkvwbIlDh4uxM34XccOagjF6mM1aHJtRHAOslWxz1mcwehjsHevVvcYYdW5G62XMwZquzUmf6XmMAtpqjQiX5zlLMGY+mzH3wT4u4Wi2cUu6pnHzqioYFVLTL6Io6zdpNnMw2gJjCeakc3oe6z6bUUbYXCdddzBOun6+dfN6wTD/p65fc9o8g3H352b9itNmCqakU3pePySkjBEN9vVJ1xGMsz6D4UBxbZ7OpJ9uUtZvN23mYE3L5qS39Lx+G0kZozPstROOMBmPpKO+bcanzYbicMTn/TaK42qVDach+nxDfxbHuTfijccbpmeQNnrHQiM6FsJdMMYU7Z0uFRhHewdvFmNUIG2/9HrdzTPpkxJ7W8TRmmGZwNAbQfYORW/Y3dhCbfFs95ZP5+rwd7gZdQLvks7XjSW4Jr0mvSUdbQ38FG6WYJT95pGeQbtpPIOxPgQ/Bb2T1pmD0b6QpgXti7LO2I2TXpJeko42FHv+NNGGGvfgnp5B37AZfYMxdLRfU9O1eQZjZI79RsJRIWOk0TjpM+nT9QEfkI4954EjQs54poORLmPoAkYbajyCe9J70jEAYbWD9mUz2hfj9Az6ts3o24xDh+us8wguV+KeOIWtKSzStRnpMo54Yq/AOdnsySa1xMnmSDZHiqd+JpuUKViSrnmyWYJRpsbDWWf9xj3xDC5JL2ET/h3OHKx5spkSJ5s9he0pLNXESR/J5kjxT3mCE9TOKZ6SbEoKm/IE7rWb21UT4/kBLiUxJZ7BmiebObilsC3Z7EnvySbGSdgTHk3fBWX0W8awP8GoD4L3UVcVsP85dE9DNC2YsRqLs44nZCovHftRev2uoCsZGEM4c3BLekt6T3pPOiV9tV3G+CyyMQWvtst5Bq967pz0mZ6fEX+sJAgmNwOrBILJjV60KxhP6027xlQSz+DRE6ewXBMnO1Lid4USwybKCOMI59DhZ2FcavDadXCW4IY0krIE96RrWShrGqsyB4+eeAYzBcuVOOvpeS0LMBxfpbPyDF7zbOekt6S3pPek96SvttRZgtf7YrzaCucRjDIyTvpMz88Uf5QR/DEHLoNxlmCUF8YnA3sMpusnwS/lleeE+oBbXJyTrp8Gr8ojWJKu8cFvwSfCWPNcGXVmM+qJhp09PY/6oHGbGjdl1AfjGYz6sBn1wTjr6XnUBzDDD1TzU6+MNe41cdIp6ZT0kfSRdC6JR7BciSV49sRerxj+Bc7xPI4MO7OVL2OS7zyCm+c/lz5DZ883LpqfBaz5uTnr08qOsefvHHotXqZcKwVrnm+WYCoRdqTno6y5RllzlZqYg1P5wkdgM3wkneN59KfGzdvnmzm4F2vfGH2iMXEw6gDaNL2d1ZiTrm0y0tii7dIbWo1n0mfo/boS98Te/jPm28a1JJ7BrSdOYTHmgV+G3rXasYLKfaWLMI9l7NvTpb+LozTKOHQiVRltDlb4GR/hc16/hWmm3oLqzMGoA8YjeCQddcN4BnOyycmmpLCSwiKfjXviiCeumXcOm1hFd454ap9o3BNHPLV/xDyUMd02RpuzmZI+8VtDeTjjSKxzTyzBWhabU9iadIyjNrekrzp/j46UR/Bai3HuiSV41RnnFJaTTU66JJtaRmjTtF/DroFemmpcko52Bqv3LJquzSMY7Z5xTyzBPYXtKazWyc1J13oIxlx78OYZvOYszkmvSa9Jb0lvSV/vi7MEr3fWeK0tOI9g5Llx0iU9Lx5/vdR0wHdSsPo94Oco8OMbGNsL5tFjfQqn6KWlA2N4Qb85MObXi0stLOJpPINXn27MV2IKlqRLen71m5sxd75HLMo98Qxec6Kxvh5T9KpS45b0lnTUbcxHBH3iwOaAoE8cmJsI5rnOKyx2dvTS0c2Yzzqv+GCZSzCfdU464ol2WC8bdR7BvSeewZTCSqQL69HO07khbpthEz6kesHnTi/mfcajJB7Bq49z5mBJuqTn5+WM9eIB//H7FbwSUzDKyHjFDeszAh98Y8RzM9of4xUf+HcL/O6dR7AkXZI+kz5Dh9+9MwWjHhr34FoTS7Cma3PSe3q+R/yxXjzghy5YDR7wNxcsBw/4lQuuiXAOHV+WNS4l8QxefYFxw281ZQ7uSUf+b0a/oPHBp1GMR0sswdwTz2BJuqTnZ3VmbVfxvqAvcx7BLT2DvMWahrC2pZuTjndnP496bkzBnJ5BPd9hUc+Nkz4jbrgCwrn7M6L9hXJJupaLPq/loow2YT+DNmFzT3qPfMA5RedIr4yWOOkpjZjfOVM8g/fXOPSZ0oizicYl8gcfLjGuSU9pxE3fzsgHvPu4n9M56SmNc9TEyAe0A7sf3Oz6xHyN4PEyMV9zpsTL/xLjWL3O0lmCcXjceDhjc9a5Jw6b6LOcwybWewnjwIl5nHEriSnxDO49mBCHodwTz+CR9JF0TjonXZKu+aC82h9ndsa5PeNSEo/gCp2VR3C7EvfEEtyT3pNOLXHSMa8xxm9NMOY4xpR4pR3reBP+6c4SjDpgHDrmns5JLzXxCF79oDMlRhxQJ3GdlLME95o46cgH46SP9DzyAfPKiQ+1OuN51Em9OMEYegej3DHPnU3TDu5XTTyCUQeMk65p39wTJ5st2WwpbE9hewrbU1hKYSmFHSks3gX4B+h1msbcEnOw1MRJnyUxJQ6bdLXEEZZKSUyJU9iawtYUtqWw2j5cyjNY35fNEoz8MebgURInm/q+bE42OdlEnTFONmeyqW0mWL9UYtwTR/xxoYNz2By1Jk42W7KZ8mSkPMEatXPEf6Q8wdjGOOXJSHkyRrKZ8mSkPMG1V84p/ilPsC2+mVOecMoTzPeNU55wyhOuJXHEn1OecEs2U55wyhN8Fs445QmnPMGdnc4p/ilPMI5yTvFPeYI1cOOUJ5zzZIZNSXkiKU+wBu4c8ZeUJ7gSwjjlCdYKCP4ierfnvXClTMHoW3tXho42BPc3OK/fhb/BxDXmztDRB2GMRFiPnRgjEdY/J8ZIzklHG4h1y4mvuhHWZieuHXde+YM11QmveGfoiD+utCLqytDvON87sshP46RjrLL2/RdDZzDa6rXXX/VaTmPk4TrHvzjZQb3aOt61zZR09FPr3P/Na7yKtC/m0Nfc0znpqEvLZ2Ax9A5GuQzEHx7pNFhZgiXpqHvGq04y7OMaKGe0z0gX7iRwTnpNek16S3pLek96TzolnZI+kj6SzknnpEvSJekz6TN0+K45Jz2lt6X0tpTeltLbUnpbSm9L6W0pvS2lt6X0tpTeltLbUnpbSm9L6W0pvS2lt6X09pTentKLj5DQmMo9sQTjnTUewS2FbSlsS2F7CttTWEphKYWlFHaksCOF5RSWU1hOYSWFlRR2prAzhZ0RFp9FIe7KIxhjGCZl6Hjv4DnvnHTkj3HSe9JRNzZT0pEnxitujHcWXvTEogxd44x33zjpyAfjpM+koz1XHldNPIJRT+RSXnEWtEXYI6C1jroYegMj7cZZn8E96T3pSLtx0pF24xVnQbkMtJlCytCRbzomMU462kDj0HHZlPMILknXtG9G3FAu2HMnEWXoyDcdh8xLeQb3pKO/2ExJp6Qj7cZJR9qNV5wnygX77zSrMnTkG/bfnckZ6znOSS9JR/tgLMEYtxvP4Jae78lOT/apJI54Yu/emYM5/RanOEj6LUlxSGmcKY345opxKYnjt3SsYhy/hb1+5/it2SMOcPx3TnEY6bdGigOn3+IUB0m/JSkOM/3W9DiUK8quXFF2Bd+2N64lMQe3mliCe0ucfot68Ei/hfnmcsytekWnMSedky5Jl6TPpGsa17tWdN1p7ecuhj7BmC8YS3BNek16SzrGnJt7STyCtUw3U+IUB0375vRbnH6L02+hjTJOvzVTHGb8Vr2uxD1xxKGmfKgpH2qtiSMOui+z9r4Xj+Ce9J50SjolfSQda5UX6gPOG4x1Fn8xdAJj78mYgmfSZ+gYszn3xBK80u7MwVibNY44NE375vRbPf1WT7+FddrNlH6LUhxG+q2R4sDpt1I+tJQPLeUD7kswnhEHXHs+LrwXGIONi5UxZmjKEoz313jFZ53SXVehSTDWyY3TM1gzNx7BM+koI+PpjLUg57CJcZRzhMVdns49ccRT95iMk82ebPaIJ8ZUzskmpXhi76BUZQ7GPuBmCR1HEEZBfmLdxpmDsddsTIlncEthW7LZk96TTbx3ZShTMPbKjZPOSeekS9Il6zMY9c1YnDEuMsY+iDEH16TX9HyL+KsPRkG9Zc1ztOfqU1Gm8gjGnpTxDNZ4gnVPypgSx/M4gzgqyh0+EsSbR7COwzf3xBI8UtiRwnIKyyksp7CSwkoKO1PYmcLOCKvrLcYRFmcinHviFLamsDWFbSks2sCKeo5DjaM2ZehowzG2cc76yueK8sVH5EZFe4UzEaOyMgfPpGM/GlzVZwP1oV5a35T1XdsswdpWbJ7BLektPY89380aZ2X4bxgnHW3j2jepeuelsaZr8whG/2XcE0dYnJtw5uCS9BI21a9j7ZtUvc9yrD2OqvdZGlPSUS7GMxjv2mZOz6BNWPsjVe+wNMb+u7E4qx+I8QwuSUcZrb2Vm9EObEY7YDyD0c+u/ZfFM5iSjn52M8YYmzk9g/139Il1jyuUUd+M2Rn7Wc4SXJJe0vMNfoxDeQbDj3ozwb9Rn6eeeAarHzvqGPaVpE1lDh2+ef1SHsE16erjraw+3srq96uM+BjDHxXljn0i56zDJsoRayzO8HFFeXWB72tXluAZaSH189zcneE7QeuGjZsx9zHmYEm6JH0mfYaOD6Q6j2DM74wpGPMC4xmMcZRx0nt6vkf8dW6Ofq3immdCv1bRT5G2M+innEOHTyChb6q469lY46mMNRa1CT9AY8xfjCW498QzmJJO6Xn0ZcpT62pRluBhZyXWq3MllmCxMxGLJXgmfdqZiPtVu0riEVySXpJek14psfkDr1eZg3sN1vdxMyVOYeFzu/Y4FnMwfLM3o93A2k7DHBN+Xzern1tV5mD1eWvKMxjjus3wJ1z+cos5eCR9mL/caop64hmMvnUz2jrjCIv5o6z9msUUXJKOMTnWtdr25UMasc5v3GpiDsbY1TjyZ/vybU7Puw/e3ZRiDo45Y4OPuvMIxj4d5pINd/EaY11ls/pyI726vo25UsNtLYQ2vOG2FuOensG7sz61U/UeOLqmMgePpGPsVxB/+OOZTazFbZako03YjDbBWJx1f1zjr/vjmKfovW6EOYje6+acdOQb5gsN8yAqyBP4ojsnHesVxjMY6xXK+By2tgN6/5qznR24uXOwvl/K6F/w7uv9a8acdO7+Lg9tT5SlJU76TPoMnbUP3Tz8vYZ/nXO87+orvrnVxCmsthuXck88g0fSR9I56Zx0SbqmS9nP2S1mZ8xljEtJPIJr0mt6vkX8se66yw5zlp1XwtE2Ckuw5r/yLIkjf+Z1Je6Jw870c4KLObjaOZTFI7glPdWxqeMrZarB40ocdWymOqbnqoxncKpj08/Z3Tw9f3rqp/SmNeNSEye9puejn+qXn9mseqOa8wgeSR9J56Rz0iXpQsHzSuz1rRd9RzZLcGmJk17T8zXiX7RvLeDhedjL8Heq69mrzXIlluDZEkfYepXEYUf7Kf3dWnpiH4d0+Jw7J72NYD8DtXgG+xmodYW6nXVazMGcdC0LZT8DVfUWNeNor3qN9qo3P/e0eAaXpJf0fI36pn5uGH929XPbzCVx0iXpknSsORiHjrvnnTm41MQSHGPp3mMs3XuMpbv2s8YUTOm3KOkjPY+9b4yxe58+Bu6k8RTlEVySHmPpvvtT5crBrYbNGEvrLWfGdCVOccDYwzjpnJ7nHjzj/R3XlTje31GSXpJek16T3pLeeuIZ3OMdH6n92eeUlUdNnPTU/ozU/uh5Ln0HObWH7Gf3bq498QyOsXrnGKt37ilsjNv77n83z/jd0RLH+8tcEyddKHheiaOtkCvait3nknK877vP3UyJ412WFu2/nskyjv5CqCWO911Su6rnlzdz9C963gp7ZH3qOFxZx+GbJVjPv2xO+kjP65kg1NWJNR/stRE+C+ic9JJ0nRNN8Kp7vO6fXlN/Dl59t3PSV99tvN4dZwlebZfxqnu8znIuHs7wUXfuiSW41MQcXJNek82WbLZksyWbK8+NB56vyj3xDOakc9Il6ZL0mfQpzvVqiTm4UHAtiUdwBzcwXYkpMeLQwYODmYKlJUbcCDxb4tBxHwhjvkNN46xckl6SruWCOta0LDZLsKZFmZDeqTyCR9JXW82YNxH8w51nsCR9zamd2Rn+VMbrXXBeccNcjNA/Mvoygu+3Meo/+jXCvNIY9d9YgjUOSCPW1pwluIxglDv6OIJvknFL+hoXMfZECL7QjPV/whzQWYIl6XgHjYcz/JyNUabGK73YUyD4NjsnvVEw3qnNyCvsNRD6Keeko05uXu0YYw9Cr+oyRp00FmfWOG+ewSXpKFPscRDWBo01npvTM2jrjBEH1Gf4FTtTMCedky5Jl6TP0HGOmLFnQaL5jPJF32SMd8dYgjVuyiM9M1JYtF2btW5sTnbWWhmjLybsbRmjnhhT4umM+aPzsok+jjB/dE56TTreKYwNCGepGH034c4NRr9MmBsaI/6bpSQewWhvwQO3bTvD5gCjbhsnHe8d1vkHzhobt6TjvcOa/P269MQzmJKOOm/Mwagnm/FuGq88wXq+3t/FWLfXe7cYa/V675Yx3rvNqM+bkYdY/xyY6xmjrhpTMPLTeATPpM/0POoA1h71viznpCNvN2v8lZGfnZUpGO/d8j+/GWUNX+tRNW6bR/BMusYH3DQ+yijrzfVKvH6XkOfaN1FTpsQzGGVtnHRKOiV9JB1lSigX+IEw/M+H9jvwXR+4udoYeQXf9QHfXWPkm3HSe9J70inplHS0FcaUeAYzB6N+GkvwTPqM5+GL6xy/i7PJzpQYv4tywXkiZwluSW9J70nvSaekY/ywec2DGP75Az60DP/8AR/arcOHltedfjeveYRz0lGXRlNeaYE//8CczrknnsE96T3plHRKOiNuqBuYu/FAvmHutuOPORrDF1rvjHJOOsbzm/Gu4ezAwLcpjEfSMdbajHbDWIIlPaNx0/ikvMW5GOcZjDqwWfNzc9bT86gDmzHu5c2ID8pFNM7KGB9uRh9njPSi7HBGxjl0fEqe4UM+cJ+GMcYVm/GeGnMw2pDNqJ/GiCfefXxpwjnpmv8o96l5vpmC8T4aSzDGcmDG2RlnxJ/BGv/NScd7Bx911v7OeASj3hrPYK0/ymhPNmv8pzIFS9IxVodfOsOPlOErztizY/iKM9Y/Gb7iDL8L45J01B/j9VvYC2P4YDB8vFnnfdgHZO0rjZOOdnIz2g34ZrPOAbE/yDoHxD4g6xxwsyQd9coYcV7vCGON1HkGl/SMtv+kLMHaNyn3K/EI1jZ/c9JHel77JmX0rdivZPhdGKNtV25XSbxsYl+StW81nsG1B6M9NKbgnvSebFLS4feCNQ1WP0zjEYy6hDUQ1n52s8Z/c+hd46+Mtt14BuNd3tyQRlbmYPS5xpR4BuMdN5bgkfSRbHKyyckmJ5taxzYnmzPFE+2AMl0lMWyK8gxGm2Cc9Jr0mvSW9JZ09C+bUQ+VcWZkYBzOQ32ElNVHaHPSR9JH0uHTZZx0Sc/Dj8s4fhfnRAbG+Yw7nY1xX4px0mvSa9ZncEt6T8+rf5cypd/FHvpm+Alsxr4/5heMb1oO+BGx3tGxGT5mxhwMn1VjxAdtl96/gTkFi96XtbknlmC9L0uZ0/OcnsF9L5ibMM5rGCPOyug3nTkY8TdOOuIPP6V9D9Vm+AFuhu+fMQdTCgvfOeNkB/7SmEMx5o/OHAx/aWNKPINnCjvdpuj6qjEHl5KYEsNmB6O8NsM3w5iDsSa8WdO7maxc9n1Wm7EmbJx0vCOYu+17qzAXk0vLDox1V+cZjLVizNFE/Wc2w2fYeATDv924J05he7LZk07JJiWbI9kcyeZIYTmF5RQWPp+YVwq++rQZe4ID8zLRMw6bUR+MV1ngrLGoL6Jx6OgfnUdwSXpJek16TTp8jTbDr3Iz3l/j9DzqMOaMgnOjA/MpwbnRreOexoG5j+gZBMxxBPNNY73nSlnvg9oswXrPlbLec7UZNgsY5WKcdLx3mDcJ1kUH5k2CeeXAmWhBXzYG6ue+5wpp1HuuNF2keauMdnuzjhmmck88g0fSR9I56Zx0Sbr2s8o6rtjMzkP7VmUdV2wewTXpNT3frsRrvwx7JYI7HwR7E6I+OcYUDP8347UPhT0CwdcNBXsBont8xknH/tdm7M1hL0B0P24z9q2MRzD2zbEvILo3t3kmfYYOP3+Bv5boHhz2CET33TZr2pWx72bMwfC7wH6B6J7aZviBYI9A4Hsv8O8S+N47czB8J+CjJerTYjyDEZ/NiM9m7Pdhv0DULwX7BaJ+KcYcjHwAT/QXzmJxnpiXGWv+bB7B8Hcy5uCe9J6exz7sZpQpfMMm7itwTjrKcTPKEfsdE3cYCvYyJr4V7Jx0xGez5pUy4mAswdgnxd76RBtuzEmHPwb2RGbRu1Iv5fU89j5mTfmJr/UZl6Rr+W4ewdh/36xjAOQV9rkG1gbnbs+Vtc3ZTIkxJkScce+9swS3pLek96T3pFPSKdkfSddzAcqYHxlT4hRWUlgdA2h6tV9DfnZN4+buacT8yLgmHWncjDHMut9jMQf3pKMfwbroxPqkMyVOvzUinzvXxByMdBmn+Mykz3h+9ymbKXH8LhW1849//OGX3/76pz/+/de//uVf/v63P//5l3/6Hxf+65d/+j//88t//vFvf/7L33/5p7/892+//eGX/++Pv/03Hvqv//zjX/D373/82/1/b6t//su/3X9vg//+629/XvSPP0To63XQuw9vO/Q9fe1u4F4XedfE+nbtNrHcJh+Z6Gv1TE3cK7OPTODyVotFe2mivzZxj0vXwg5slHLv5LgR/tZGe22D8RVAmLjn1uwWqHxjYZyyc41OdkIk5cX8tlD5UKhYbNZCvTvQlybkkA709ZqOewD1KifmIR1ttaKajnv06RbuHfd3M7Pcq4tm4y6Pfr3KztV3fjY/V5/72Qwt7dM5Wvrns/TwmqyTOdvEOgjw8jUp41QsVKNY7q36V2k5xaOtOZDG427zn7zxFd2rmrjnQK+TcqikGDHARLZwd2bvW7i6W+gvLdRDBb3HlJaOexgZLdc9HfvWxiEvcPMVTNybU69jcbKw1szVglzPLKyVVVi4d6wfWUAfrRbGfJSXy0Hcq9VV0xtS37ZRcGRVa/e9wuc27knQ+zYk3pB73v4sHt/Y4Ec21gUalh+lfIGNSi9tnNq+KTPes9zqzLf7goYbzjQ72r0f9cjIOoxlRmpLBfM7I3So6Bdbb7B8EV+OEg5N6L0OYSONe7nhyUBjRX9EUu624mVSDt18F49Hv+dxL+NxagC7D//WSs6zpORSIXlStI29Y7vXrujVSKHXUxWLGnbPTyIW/G0s+ikt4oUyIx2t1/ctkFmouQH73gKd3rbLTNzLJKk7uJvlb2ycRqHeofQSZVrv1//t3Oz+zq8bOF7n5qF6Dvbe9d5ZTDbKd7lxqJ/rvk8vknm9HLu9W7fmy0E9HUehPli5pyevR5B0yNF7adle1vXdtVdvGrXTWKN6u3Ovr7408QXjaaLTW9Kia+vXy4Hsyca7Y3Li05i8xJg8TRq/zw7+9LCeTjOl2m3k1NYg42VufMFs62yjT7fB7VmpYI1PS+Xu5F6Wymg/10YZ0TveWwKRljY/YCNmn1zrMxuzRIeQB09PbbTH8SC3kd+4D9mQ4l1TGix8xEa9SnRv/XVaji0Q9iS0nko9rJDUY36I5wel6co90H63V4jJY7u3EV71CkcLPlpoeeb3nQWmT/cJPD7dJ7ybjlI+mxPpVXvfQm/TRyw9TTG+syDX58d/Uj47/jtaeGv8J+3z4z/pnx3/HXPzzfGfjM+P/4R/6vjvm7rVX84tZJ4WJnr1dTeej2IhvrTc5fVa6CynZSLxZaL0itS3DbDnJfMjA7NYWzPTqt9HDJC1/TMvr3/AgJflvVBYn1goF8c2QXtoYnj3c/GjjLh3S721qlSemWCPRbuexaIVf8tbf1Ql7nX9aHafVcvSfO3xtvYsL3Dh3W6u0qLOR0zgPk5bOHwWC7hFbRM8HpngmFuxPDSxDufZwPdZXkQftD7c9MxElMh8ViLr7vwYbbZnJjgGvfzMRMzv1mVfj0yk7uNhBV/3KXkP1J7Fovskc52If2aihInyrFDpsol/fdiN1T7dRJ8vu5FjZ3zFHLW+HPyX03aHiJmY13y5H/imhSLPLHg/NGt5beGQE5N9AWTy6zWU0w7DvWdulaLXOZ/sMJS7GL3Noqv31yVyWvUMHwJJr/r1gZR4F3Dvao5H+y3r7hez0Vp7khvUm0WDOr2cTpV2fXpmWVr5mVPLb1IyrgcTw28s8JPJKZGPcSjPZH6Xm/T5uWU57Rq9N7k8m3hrdllOe0bvTi/LadfovfnlOUvfnGCWXj4/wyzHrY7PTzG/qWNDXtax3j+/x1D65xeUSv/8itIPEvOm285p/+jdfYajkbedf+j69E7DD2y850F02kN6d6/hbOTNjYJztr65yl++YrvhaOTdvYIfGHlvs+Bs5M3dgveNtOcxeWu/4AdG3tswOBp5d8fg3Jq8uWVQRv+pewZE3rrSeLRSTjh4tC3Ik10HYm+dicd4YiE8k0joyaBs3Svhvcyhu+MvWK4v/On1+rOJ94ZU/AUr9oU/vWR/ztJ3h1T8BYv2hX/uqv03dWy+nhDyz122H8Nb0jEOKwWnPaF1rbQ1X51frjifbVBMbsfrxd6zDXz9Y9voT2245++6DfrB2ssg72rvzH1dsDI+u/Zy2ldqTDFATUv430/Tz0aE2Pul5Pj2MSOxJ9LmOBl5L0MOS0lHC28tJc36+aWk06rF5bOX9toR+t0DHPRyr6/Mr5jsz89P9ufnJ/vzKyb78/OT/fkFk/16fcFkv15fMNkfn5+o16t/eqKOBclPTtT58zNs+fTU+Asc6L7A940/Pxetp9NKX2Lk3QntD4y8N6E9G3lzQvu+kfY8Jm9NaH9g5L0J7dHIuxPa8fnpbD11lV8wnV3XAdmrS/XJRJDj3BHTfDkZrbV9viWs/WfuVDBR5MWUB3khtfopmUqHvODPDz1qlc8OPc4m3hp61NMG1LtDj9rKZ4ce5yx9d+jR2hcMPVr/qZPib+qYvNwZrKc9pC+YFEtzTzRpUl5HQz45YzlbeGfGUvv16RnL+2ecy8uGo37F0aX6+bNL9fOHl+pXnF6qnz++VL/i/FL9igNM9StOMJUvOH9UT47373a0p72jd/cG6+fnHOfT+O/tx/XPzzrOJ/rf3EmrXzBlIPnJRt6ed5yNvDnvOBp5d97xtpH2PCbvzTvORt6cd5yMvL2R9gVHb+rgnzrxuHtKmtFrzidTj+X+HTbqa8eeyp93k6r8U92kvkvL63XL92082hksV3MH/5v7Qxvi/d3Vizyykd7da/b2umy/YjLFn59M8ecnU/IVkyn5/GSKv2IyJV8xmZKfO5n6rpaNl6fOqvzc6VS5s9V7mdLnISJyci1o4VrQXvpmn21I3ESTN7Q+ZGP6qtK4rvbIxrj8Vopx0Xhow13/R3ntdH+2Ee/uqOWpDXf5uM09zI/mO7cj33vyMRsUm2vyNB5TvLusz+rH+miI2aD21AZ3j4c8zA/c57f3oYkf2vBVjMHlYTzwLaptI3f9H7GBu0vVhoynNnxweOPD/JjekI056yMbfHm5rO9HPLNRfNjOpT6MR4l4FHpoo1Xv6trD9pTj2A4/revcY758OLdzthEHd/hwcOcH8fCTO3w4ufODeMSew9N+jmnEvsXrg3rnPnuU6LPlpR8LRtRvLIK+9mN518LrZdSzhXeWUVv9ucuod8foQ7FCB6fEelqcijvGhPi1b9LRxhC/D4uv+swG+xsr3B/aEHdbFxF5ZmO6O826sfphPLzHv831R28Kxf1gdzm/ntzW+dk35U0LhzflaOGtN6XVn/qmtIvSqW95nZvHrag3p8bteILnranx2cRbU+PW+PNT43baSnpvanzO0jenxu20IfXu1Lj18nOnxt/UsnK9dlTv7fO7Fq1/3lGq9c87Sv0gMe+daGr9C/ytjkbePdHUTrtSb+6g/MDGWyea2vE2qDe3Yc5G3tyHOWfrm3souPr4pxp5dyPmB0be24g5G3lzI+Z9I+15TN7aiPmBkfc2Yo5G3t2IObcmb+7EtB/cCvfpnZhW4rrkVvqj1fpW092+7XAuapz8zyma6HSHwGzvm5giaVPptY1TUpov1t0s5VF2xCJZubu2Z1naY3DVTmPmkw2KcUCjyY9sjOiw2uBn8Rgzqge3Z/HAx4i2DRmvZ9un2/berGInE19RxeYV1WP2+Sg7Jsf4/WqP9k973IN9zwHqo6LtJYq21/rodUld5lpHeW1DvsCDqsmnPajOJt6b0MgXeFA1+bQH1TlL353QyBd4UDX5uXdAf1fLxutG6N17nE57fcdbanrzoslrMh+xMOMC++uRBfKzldTbMwtz+gbdfGXh+KKUGLxQOTRh8zRmj69W9PF6j+9sY/hUt4/XexZnG+z3YvW8rvMxG/HOMj+0IcM/CCDCz2xE+9PzmP9j8cgfJmhPVg3piq6F8scvvv8kwPmE1Burhu9aeL1qeLbwzqphv+TTq4an74Q1/zZLb7kF/f7zWuXkhOKT/SiM3j7QZPiyBWXvpI80OhwXF9SHFjwOMp9Z8PPPlHuRjzTfft6300MLI1qK9tCCx0GedSHd12163ti8PrAJV9PYoD7cUCze4N3mnjlocPO5xY0P41F924jbQ0cArv4xP678cHO0SWw4z4fxaF45bhsPnV7YO9XB8tBGb3EDBPVnNorXsVHq6zw9rcmXcJtJQ/rvPzJ2vicg7ke/d+LS+uSH7gnguCdAXt9YcBzAFvc1qYWeXQF6Sfqe1KPrk2t1r4ha27NYVF8/u008u1G1+JSx5vnehy5l9fsiayvPYlElphTl2W3Uwx0iymHL+nwDs4897yUaemTi8qp1v3Mvs/N4I9AVHsytSP6s4HcfHTofYpqxel7yh7XGd0b6uwPYl5/F6sddp/c+rXVOzGieJUPqITGHlqP2uASZavq46vg+JkdH6FiBEzoZeTsm42Dk7TyZr/PktGXEI67Cj3j0j0SD3SezcOqufx+N0z5A9cvo76Xn63WGHHckSrQhtR+K5v2YtIdFk/Pkmxf4+zzhn1o00q+oq4cm4PQ9JWq+6kRtvvzIXx+nJu3db62eY9L97m/qr/dZf2DDB0K3jddz4dN+0/BvL3DyBKrfzQF/UDIjSkbK65IZpy84knsQ0zjM64/bTcUHylL7628W9uNRqLeL95wn4R8lp5dmnG5AuXw57d7GOxg5nYaSwuSZkgYjv/v04Ok41NvfLzx94OnNDxiebuW7B3UxREy15GNGqi+C34O9+tAIx44xp/Hu74yca4mPSO5d9HYYCRx3jH299B5AH16/03kmav49RWrJPeH7L+weY1LjhEe9vnn/vjNyOhb15qdc++lU1Jvfcv1BYvzlqxddh8ScbuL3raOZJt0fytS7eHvE43XxHgfh6WuuLX8u6XctoxzX2Xz6fx2qmby9hvx6+Hya/r87BD9+xSqOVrTDAHxex+2BtGDHL6Nx/PBRxGOO/uSj7euEaMzQTklpny+V2T9dKsek+PZTKeUwBTjdr/d2UvjnJiU8La/TDO90RV8h/l+/XfT9Z0yvkxc/uV/CJCqfTEpeGvpA8yPhofFqTfkUgdjjLfQkfEsOMw/CV39F8+jpA+F9/aOO60n46FPbk/yLBehvPkn2KPx8kv++t1JGexI+PsvG43PhpT+Kf1oieRD+3UtpTybevJL2ZOLNC2mvzy94X59f7j5Vx1gJrKMcvnV9vGfv3Y9d1+MA4M2vXZ+O4rz7ueuzjfe+d12/4Oacs5F3v3hdv+D+nXPZvOmyTVV+spF3/b5/YOQ9v++zkTf9vt830p7H5C2/7x8Yec/v+2jkXb/vU4M0enTw6WNWv6slpwNPNJIfxaktaZ+/tZdOH4Hi4U5PPNKs93sb/Txii5uASn+9zHrOEva37x4IHxr6041xtUf59uSO8LtKcjZC8YHEWR8biU8knqrr0QiFryLR05jQiB706o+N0P/WDX/MyPBFp5pva/igEd/jqHw9jgnHal7y6PqYEY7k5Br7QSPuklXlehyT2JKTQg+NiH/NuObNwQ8a8Q2Xmp0GP2rE82SWp+/OjHdnPn13Wq0xTOoPM7Y13wxrTR6+gK37MmnLHsMf6bn4kv9tCft3Lew4xOPNo5x02oN68yjnMSnuPVfzF5Z/n5Tzt7G8JblafvXo7XhMiup+iMfRhE9w7s2JfkjK8RpdX0sT/qZ55u+MHF303zuKdprwFR/XtMKHKnbafBrRwg/uhxw5bT7N8PlNHx66d9m/M3FaJr3cW+LGw3t7NNI9Ip1OPc3RSFyX0kn4qRG/W+wer5UvSM5pbHQ0MsLvdJx6mrORK1z+iT+fnHHqws8x8YXbe5NgPDTCNVYX6vOY9NijqJ/Pk+yp/sHkSOTJfGzEp1q3EfmC5Mz50Ij4vKJnZ5QPGokFJBnyOCaescLt83ki/Lhl81Habe9pexLfDL9HE4fSmcebUOLIzM1pPt2+b++PHziiFqdVOr9eiTp/eCo26FragPiQkeGbWvlCut+bOOYJ1XRENbf3H+kD6XJnMLr660Ie1/UV5TOu8vnyORt5s3yORt4rnx/kyReVj8/Lb3zYMFHxqFA5zXJOA65117DvgaYmsv6uiL/gW2fj+vS3zkY5bgK+53d0NlJbGOn1oZE3/Y7OI2qmuJ5SXq9ZjtNF+dLcXV+yo/x3szZ8a/Ow7eA7Bnl78XeV5GxEwkjabf+gkRmustd4aKT1mNnTKSanfI2bNyRvxXyfr/V4t7Qvu9zYH9mQyyeiUq7x0IYXzXMbxQf2ks+Mfiwe3uFIeX3mc9RTT14otpLLwUf1B1Xkiu2t5Lf/+ypy9gnwZYb86n2wOXrPDfIH/Y2fHKLr6bj+Dum3XJfSnxrxqraOGT/t+RpFz/fYSPhSlkMffHKCdKcROrTxJwMz3U/9xMA3jmXjmYnirisl30L0IRMjrpmUZ7Fo4WPb5rNYkM/FvxlofsjEiIs3ZD5LyBUnqeqzhLQet/bQo4S8O/44euTEeYHBzxLCcXsIz/rIxIzsnPWRCe5xAfN4YmB2a20mPcqHuAx21mcxGHELAX0yCc8M3JsQfro5X336XX94slD8Skou2Z33ux6VTp17jTejjvooFhSTwDSU/YgFv2OMn8bB1/vuVf/riYU4g3sjP0vFDAvyWQvlURyqd16cDyM/LIu0F/SROPhQgis9S0Xrn6sPZUatnsn7tMn1yERyb/mAibWZ5vtqyY/qQyZGbM3lBcqPmJA4JjMfJmTGMfnsavAhE3FA/XqYF3XEyZSac+P9mtHlimXj5Ff8uwW408V59+DMR2fj4O93NtKjH+6VnhlhiemuvDRx7MolfZDhyUkMDlf7G+cjC9NTQfORhThFzaM/sxAft3hq4S0PsnH8ENS7HmTXcS3mLT/S4xwoblO8slPsd/eEjNORJ/EzutL6SxPHWPR0xKc9M5HOo6Qbjj6WEB/4S3aO+N7E6bxTbFuTXM9MvHdzy9nEFSbaQxPu5jHGfFIivfm73vPHW76/dPRkgnxN+t77Ho9MTO+Z+6RHJr7ZEMoV/CMmRqzcHC5xvY7rNl6z8jGPj5hoEmsu6Zalj5iIrox6eWYiThVSvl7/QyZ8oEPfeBB+xES4I0t9nZ18jdOUasYdNu3KV6d+0MyQLzDTLopbj6/x3Ey6W/vKDv3fmzmtvZZ72OaxqXeXeTBz3AGldJ9rHjN82EwscI3repyoOGt3J+oUm/NHN3wOuq54rY/NRKfXheVxgUusmeUTkL+PzfEjmyUNc7/ZVP2gmZHMSHlsJl6G28whUcdjVO+X1A/MhDvAXVL82MzXFHhJG/H5QrUPNaBxGS8TPzIxfT2JpjzqCUZMeUfeOfuIiVL8TuBSr2cm0rcyDw3m0YTvMt1bdIfmqZ2MsM9WB/eXC1NHG2VQuqeKTr3ID8y4g/7N8thMfKryXkm/+KkZjjvaRl7K/qiZuGt9fDMP/5gZuWJ7QEp5HJuUxce26XSm6gMddZtf0lH/yMybHfUPEvVuR93rlzT/PzDzbrv9gwKnVP3G8+rnbtE30+N3aka9GXP0x2aiaxyT50Mz96zC6829RzIem0mH8fMGw4fNcJiZhzH06bY/iut57+3y8bI9p/qT+4R7k8Jb4Zvpaa7UuGlgXT38qKOs8T3oKoe6S+MnGykyoo25uT81w3FWWJjKUzMSw2+Rw9z8B2bSyWWZ7Xlsepj55mzdJ8ycBiM/MtPDDB/q7+iffx1PJ7DefR1/UEZxf5/kbfGP5kpcRyTzel5jcmzaczPhTSuz98dtTIsGPF8r+lEzIzVVz3ul5t69N9f62ExPZuhx+9taNvO4j2wxRLv5ed5wMjMfd7U99U29Pi7wuGl0mXle/STqTT8sb7IcJ/rNHT5uPtWbH5jxHfqbT12LfM3w9QexiYuSejstLH4gUZ8w4wfib56nLB7/L/JmRqL61b8iUZ8w00ssV/V2yOJ5/T/Im95Sojp9SaL640b0cr+CxY+XEua8kpn6aHNruI9gH8LPTLQ4UyrPduniOz+dn+2PjeF+tGO0Rxs6a1XHB1b8aGrBVwk/vfZor/Au1flJE3z5YuK93vUoL+6aF59Tqc9iEY0st2fLu9+YGPWZCQkT81HtXH25mTi1ZCcT4lsJd1/wzET3ZYUbH20A8/CJGY/6rEQoHFFpPisRDg8eefamfpOQpybisv3Bz+oFhxsol/4sFnEokgs9iwXFVwOof7pEyuvaKWV+RVd9fE/cf+Zp3ahxOuWbL/18xH2/tPA/TKuSHzLx3lnIk4k3T0KeTAyfZtWRlhA/FAv3cqiVn2XnmwexjrF47xjWaavQD7gSPfIPe88v67xZacOL65GT26cdqt7zCztulr7jFXYwIN3vR7/xyQEAIV8PuZEfWYirq+mR27oMH8DLKPVRHLz7ubdPnlmIj3pTct18aEEexiHKQp6VRf+khfCfyncWfX9Z7hD5rImj6yiH62geZL5toMRaYcl+uO8biAN8+UjKBwzEB95LzoUPxGBGDMYLA9IPQ4h748Da6HtFOOXCvc74j3++//nHP/36t3/57a9/+uPff/3rX/7rDvmPZexvv/7xX3/78/7nv//3X/6U/u/f////tP/zr3/79bfffv2Pf/nPv/31T3/+t//+25+XpfX/frn2f/5PX7Wx0+B//sMv5f73Pditf6D7bb//3db/X2eF+6jr32UFaPWeuN7/QQCEGHdfd/+H/vkfK8r/Fw==",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ABwKCxkAHAoKCwAcCgIKAC0IAQInAhoEDAAIARoBJwMCBAEAIgICGi0KGhstDgQbACIbAhstDggbACIbAhstDh4bACIbAhstDgkbACIbAhstDhQbACIbAhstDhUbACIbAhstDhYbACIbAhstDhgbACIbAhstDhkbACIbAhstDgsbACIbAhstDgobHAoXBAAcCg8IABwKEAkAHAoRCgAcChILABwKEw8AHAoNEAAcCgwNAC0IAQwnAhEEDAAIAREBJwMMBAEAIgwCES0KERItDgUSACISAhItDgQSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgsSACISAhItDg8SACISAhItDhASACISAhItDg0SACISAhItDgMSLgiARQAqIwAAC8MNIgAqgEwAAyQCAAMAAA75IwAAC9gtCwcDLQsDBAAiBAIELQ4EAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHKwIABQAAAAAAAAAAFwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEYACQAiCQIJLgyARgAJACIJAgkuDIBGAAkAIgkCCS0OBQktCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEUABy0IAQgAAAECAS4MgEQACC0LAwkAIgkCCS0OCQMuCIBFAAIjAAAMxw0iAAKATQAJJAIACQAADq8jAAAM3CcCCgQLLQgACy0KBQwtCgQNLQoHDi0KCA8ACAAKACUAABcoLQIAAC0KDAktCAEEJwIFBBkACAEFAScDBAQBACIEAgUnAgcEGAAqBwUHLQoFCAwqCAcKFgoKCiQCAAoAAA1OLgyARgAIACIIAggjAAANLS0IAQUAAAECAS0OBAUuCIBFAAIjAAANZg0iAAKATQAEJAIABAAADmIjAAANey0LBQMnAgQEGC4CAAOAAygAgAQEABklAAAXnC4IgAUABwAqBwQILQ4JCC0OBwUuCIBFAAIjAAANtAwqAgQDJAIAAwAADjMjAAANxikCAAIALRfGuCcCBAQCJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIFAgUtDgEFACIDAgQtCwQCJwIFBAIAKgQFATcLAAEAAiYcCgIDAAAqBgMFACIHAggAKggCCS0LCQMwCgADAAUBIgACgEgAAy0KAwIjAAANtAAiAwIHACoHAggtCwgELQsFBy4CAAeAAygAgAQEABklAAAXnC4IgAUACAAiCAIKACoKAgstDgQLLQ4IBQEiAAKASAAELQoEAiMAAA1mACIDAgoAKgoCCy0LCwknAgoECy0IAAstCgUMLQoEDS0KBw4tCggPLQoJEAAIAAoAJQAAGCotAgAAASIAAoBIAAktCgkCIwAADMcBIgAqgEgAAwAiAgIFACoFKggtCwgELQsHBQ0iAAOATQAIJAIACAAADyglAAAZTi4CAAWAAygAgAQEABglAAAXnC4IgAUACAAiCAIJACoJAwotDgQKASIAA4BMAAQOKgMEBSQCAAUAAA9oJQAAFhYAIgwCCQAqCSoKLQsKBQ0iAASATQAJJAIACQAAD4slAAAZTi4CAAiAAygAgAQEABglAAAXnC4IgAUACQAiCQIKACoKBAstDgULLQ4JBy0KAyojAAALwygAgAQEeAANAAAAgASAAyQAgAMAAA/mKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQUxdnHEg87uxjwEAgEmJQAAD74cCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC4MgEYACAAiCAIILgyARgAIACIIAgguDIBGAAgtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLgyARgAJACIJAgkuDIBGAAkAIgkCCS4MgEYACQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLgyARQAGLQgBCAAAAQIBLgyARAAILQsBCQAiCQIJLQ4JAS4IgEUABCMAABD4DSIABIBKAAkkAgAJAAAReCMAABENJAIAAwAAERojAAARTCcCAQQJLQgACS0KBwotCgULLQoGDC0KCA0uCIBJAA4ACAABACUAABgqLQIAACMAABFMJwICBAktCAAJLQoHCi0KBQstCgYMLQoIDQAIAAIAJQAAFygtAgAALQoKASYMKgQCCSQCAAkAABGKIwAAEcgAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBwwtCgUNLQoGDi0KCA8tCgkQAAgACgAlAAAYKi0CAAAjAAARyAEiAASASAAJLQoJBCMAABD4KgEAAQUC3G4ngHYSnTwEAgEmJQAAD74tCAEGJwIHBBgACAEHAScDBgQBACIGAgcnAggEFwAqCAcILQoHCQwqCQgKFgoKCiQCAAoAABI3LgyARgAJACIJAgkjAAASFi0IAQcAAAECAS0OBgcuCIBFAAUjAAASTw0iAAWATQABJAIAAQAAEmkjAAASZC0LBwEmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAYJQAAF5wuCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEgAAS0KAQUjAAASTyUAAA++LQgBBgAAAQIBLQ4EBi4IgEUABSMAABLVDSIABYBNAAMkAgADAAAS7yMAABLqLQsGASYtCwEDLQsCBA0iAASATQAHJAIABwAAEwwlAAAZTgAiAwIIACoIBAktCwkHASIABIBIAAgOKgQICSQCAAkAABM0JQAAFhYtDgMBLQ4IAi0LBgMuAgADgAMoAIAEBAAYJQAAF5wuCIAFAAQAIgQCCAAqCAUJLQ4HCS0OBAYBIgAFgEgAAy0KAwUjAAAS1SUAAA++ASIAAoBMAAQOKgIEBSQCAAUAABOaJQAAFhYNKIBNAAQABQsiAAWARAAEJAIABAAAE7clAAAZYC0IAQQnAgUEDAAIAQUBJwMEBAEAIgQCBScCBgQLACoGBQYtCgUHDCoHBggWCggIJAIACAAAE/4uDIBGAAcAIgcCByMAABPdLQgBBQAAAQIBLQ4EBS4IgEUAAyMAABQWDSIAA4BMAAQkAgAEAAAUMCMAABQrLQsFASYAKgMCBA4qAwQGJAIABgAAFEclAAAWFg0iAASATQAGJAIABgAAFFwlAAAZTgAiAQIHACoHBAgtCwgGLQsFBC4CAASAAygAgAQEAAwlAAAXnC4IgAUABwAiBwIIACoIAwktDgYJLQ4HBQEiAAOASAAELQoEAyMAABQWJQAAD74BIgABgEgAAy0LAwIBIgABgEoABC0LBAMcCgMFBhwKBQQAHAoEAwYBIgABgEMABS0LBQQBIgABgEsABi0LBgUcCgUHBhwKBwYAHAoGBQYnAgYEBQAqAQYILQsIBxwKBwgGHAoIBgAcCgYHBicCBgQGACoBBgktCwkIHAoICQYcCgkGABwKBggGJwIGBAcAKgEGCi0LCgkcCgkKBhwKCgYAHAoGCQYnAgYECAAqAQYLLQsLChwKCgsGHAoLBgAcCgYKBicCBgQJACoBBgwtCwwLHAoLDAYcCgwGABwKBgsGJwIGBAoAKgEGDS0LDQwcCgwNBRwKDQYAHAoGDAUBIgABgEwADS0LDQYcCgYNAhwKDQEAHAoBBgItCgIBLQoDAi0KBAMtCgUELQoHBS0KCQctCgsJLQoGCy0KCAYtCgoILQoMCiYqAQABBVVFTwUJdio6PAQCASYqAQABBYFkm2itHhyEPAQCASYqAQABBUWnynEZQeQVPAQCASYlAAAPvi0IAQQAAAECAS4MgEkABCcCBgQCJwIHAQEtCAEFJwIIBCEACAEIAScDBQQBACIFAggnAgkEIEMDqgACAAYACQAHAAgnAgoEIC4CAAiAAy4CAAqABCUAABlyJwICBCEnAgYEIC4IgEgAAyMAABabDCoDAgckAgAHAAAWsiMAABatLQsEASYtCwQHBCoHBwgCKgYDBw4qAwYJJAIACQAAFtIlAAAZ8gwqBwYJJAIACQAAFuQlAAAZTgAiBQIKACoKBwstCwsJHAoJBwAEKggBCQQqBwkKAyiASQAHAAkEKgkIBwAqCgcILQ4IBAEiAAOASAAHLQoHAyMAABabJQAAD74tCwQFCyIABYBEAAYkAgAGAAAXSicCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABoELQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYuAYADgAYLAIAGAAKAByQAgAcAABe3IwAAF8IuAIADgAUjAAAYKS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABgVLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAABfkKAGABQQAAQMAgAYAAoAGIwAAGCkmJQAAD74tCwQGCyIABoBEAAckAgAHAAAYTCcCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAABjfIwAAGGUtCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAAYiiUAABlOLgIAB4ADKACABAQABCUAABecLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAGMolAAAWFi0OCgEtDggCLQ4FAy0OCQQjAAAZTScCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABoELQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAXnC4IgAUACQEiAAmASAAKLQ4FCi0OCQEtDgcCLgyASAADLQ4IBCMAABlNJioBAAEFxWvEWg4QAAI8BAIBJioBAAEF9C7lhLv0IdE8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAABnxAwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAGY4mKgEAAQUohpKwR9z9QzwEAgEmJQAAD74uCIBFAAUjAAAaFA0iAAWAQwAGJAIABgAAGn8jAAAaKS0LAgUtCwUGACIGAgYtDgYFLQgBBicCBwQFAAgBBwEnAwYEAQAiBQIHJwIIBAQAIgYCCT8PAAcACS0LAQUtCwMHLQsECC0OBQEtDgYCLQ4HAy0OCAQmLQsDBgwqBQYHJAIABwAAGpUjAAAbAS0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAAF5wuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAbAQEiAAWASAAGLQoGBSMAABoU",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n        offchain_messages::emit_offchain_message,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n    utils::{array::subarray::subarray, remove_constraints::remove_constraints},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash,\n    address::AztecAddress,\n    constants::{PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_SIZE_IN_FIELDS},\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note_unconstrained`, except the note is emitted as an offchain message instead of a\n/// private log.\n///\n/// Like `encode_and_encrypt_note_unconstrained`, this function uses unconstrained encryption. The sender can set any\n/// message contents, potentially preventing recipient decryption and resulting in note loss. Since offchain messages\n/// inherently lack delivery guarantees, constrained encryption provides no benefit and is not offered.\n///\n/// While delivery is not guaranteed, message integrity is still protected via cryptographic commitments in the note\n/// hash tree. For guaranteed delivery, use `encode_and_encrypt_note` with private logs instead. See\n/// `messages::offchain_message::emit_offchain_message` for more details on delivery guarantees.\npub fn encode_and_encrypt_note_and_emit_as_offchain_message<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n\n        // Remove the tag from the log\n        // TODO: This is a tech debt. We should refactor this file such that the log is by default computed without\n        // the tag.\n        let message_ciphertext: [_; PRIVATE_LOG_CIPHERTEXT_LEN] = subarray(encrypted_log, 1);\n\n        emit_offchain_message(message_ciphertext, recipient);\n    }\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let note_nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = (packed_retrieved_note[2] as u1) != 0;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, note_nonce),\n    }\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u64, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u64, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u64)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u64\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u64, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_timestamp) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical timestamp (timestamp of\n        // the historical block against which we are executing the private part of the tx) as this one also takes into\n        // consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by scheduling\n        // immediately after the historical timestamp, i.e. at timestamp `x + 1`. But if there was a delay change scheduled\n        // for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value change was scheduled at\n        // timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier than what we'd expect if we\n        // only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_timestamp);\n        let timestamp_horizon =\n            value_change.get_timestamp_horizon(historical_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the timestamp horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(timestamp_horizon);\n\n        value_change.get_current_at(historical_timestamp)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u64)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_timestamp = header.global_variables.timestamp;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_timestamp)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        smv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "205": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "206": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "208": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "209": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "218": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "225": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "243": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "286": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "303": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "305": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "318": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "320": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "321": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in\n    /// private with historical timestamps. This function can be used alongside\n    /// `ScheduledValueChange.get_timestamp_horizon` to properly constrain the `include_by_timestamp` transaction\n    /// property when reading mutable shared state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'timestamp horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the historical timestamp that is used to construct the proof).\n    /// Reading in private is only safe if the transaction's `include_by_timestamp` property is set to a value lower or\n    /// equal to the timestamp horizon (see `get_timestamp_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_timestamp`\n    /// (timestamp of a historical block at which we are constructing a proof), since due to its asynchronous nature\n    /// private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the timestamp horizon\n    /// computed using the same historical timestamp.\n    pub fn get_timestamp_horizon(self, historical_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The timestamp horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the timestamp horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the timestamp horizon.\n        if historical_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the historical timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the historical timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `historical_timestamp + 1 +\n            // minimum_delay`. Our timestamp horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    historical\n            //      change       timestamp          timestamp horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the timestamp horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         historical\n            //         timestamp                      timestamp horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the historical timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           historical                         timestamp horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because historical_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                historical_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "339": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "356": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "380": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "381": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "393": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 180, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[utility]\n    unconstrained fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenCommitted {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<5> for TokenLockAdded {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable<2> for TokenRefunded {\n    fn pack(self) -> [Field; 2] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; 2]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<6> for TokenRedeemed {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenLockedFirst {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable<6> for TokenLockedSecond {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
