{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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Ui0CAAAtCjAcBCosHAsAKh0LHBwKLgsAJwIdAEgnAiEEKy0IACstCgUsLQodLQAIACEAJQAAGlItAgAALQosHgQqCx4dACocHQsnAhwAaCcCHgQrLQgAKy0KBSwtChwtAAgAHgAlAAAaUi0CAAAtCiwdBCoKHRwAKgscChwKKgsAJwIcAHAnAh4EIS0IACEtCgUiLQocIwAIAB4AJQAAGlItAgAALQoiHQQqCx0FACoKBQstCAEFJwIKBBgACAEKAScDBQQBACIFAgotCgocLQ4LHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcLQ4FCRwKHwUAHAoSCgAcChYLABwKGBIAHAoaFgAcChsYABwKERoAHAoOEQAcCgQOAC0IAQQnAhsEDAAIARsBJwMEBAEAIgQCGy0KGxwtDgYcACIcAhwtDgUcACIcAhwtDiAcACIcAhwtDgocACIcAhwtDgscACIcAhwtDhIcACIcAhwtDhYcACIcAhwtDhgcACIcAhwtDhocACIcAhwtDhEcACIcAhwtDg4cHAoZBQAcCggGABwKDAgAHAoTCgAcChQLABwKFQwAHAoPDgAcCgMPAC0IAQMnAhEEDAAIAREBJwMDBAEAIgMCES0KERItDgcSACISAhItDgUSACISAhItDhASACISAhItDgYSACISAhItDggSACISAhItDgoSACISAhItDgsSACISAhItDgwSACISAhItDg4SACISAhItDg8SACISAhIuDIBKABIuCIBFABcjAAANqw0iABeATgAFJAIABQAAEg4jAAANwC0LCQQtCwQFACIFAgUtDgUELQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkrAgAHAAAA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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3djjS9cqV3L/tYB8n4JedWDGMgj2VDgCAZGo1PhLl3VwbJWHy7d7HZVfUZMGAdqJ/v3d2xMpkZK5NkJPmff/vf/+l/+x//53/953/9P/7tv//tv/wv//m3/+3f//lf/uWf/8//+i//9t/+8T/++d/+9fGv//m36/5/helv/6X8w+Mnj58yfur4aeOnj591/Gz9p1zjZxk/RzwZ8WTEkxFPRjwZ8WTEkxFPRzwd8XTE0xFPRzwd8XTE0xFPRzwd8WzEsxHPRjwb8WzEsxHPRjwb8WzEsxHPRzwf8XzE8xHPRzwf8XzE8xHPRzwf8eqIV0e8OuLVEa+OeHXEqyNeHfHqiFdHvDbitRGvjXhtxGuPeHr/1PHTxk8fP+v42eInXdf4WcZPGj95/JTxU8fPRzy7f/r4WcfP1n+Wa/ws4+cjXrt/3sfHN8gEnWATfEKdcJ+1P4CuCWUCTbgj1xtkgk64I5cbfEKd8IhMtwRfE8oEmsATZIJOsAk+oU6YkWVGlhlZZmSZkWVGlhlZZmSZkWVGlhlZZ2SdkXVG1hlZZ2SdkXVGvnOJ7ot5J1OHNuBOpw5lAk3gCTJBJ9iEGdlmZJuRfUb2GdlnZJ+RfUb2GdlnZJ+RfUb2GbnOyHVGrjNynZHrjFxn5Doj1xm5zsh1Rm4zcpuR24zcZuQ2I7cZuc3IbUZuM3Ibkfm6JpQJNIEnyASdYBN8Qp0wI5cZuczIZUYuM3KZkcuMXGbkOwep3lAntAF3DnYoE2gCT5AJOsEmzMg0I9OMzDPynYPMN9AEniATdIJN8Al1Qhtw52CHGVlmZJmRZUa+c5DtBpvgE+qENuDOwQ5lAk3gCTJhRtYZWWdknZHvHJTrAXcOdigTaAJPkAk6wSb4hDphRvYZ2Wdkn5F9RvYZ2Wdkn5F9RvYZ2WfkOiPXGbnOyHVGrjNynZHrjFxn5Doj1xm5zchtRm4zcpuR24zcZuQ2I7cZuc3IbUSW65pQJtAEniATdIJN8Al1woxcZuQyI5cZuczIZUYuM3KZkcuMXGbkMiPTjEwzMs3INCPTjEwzMs3INCPTjEwzMs/IPCPzjMwzMs/IPCPzjMwzMs/IPCPLjCwzsszIMiPLjCwzsszIMiPLjCwzss7IOiPrjKwzss7IOiPrjKwzss7IMwdl5qDMHJTIQbqBJ8gEnWATfEKd0AZEDgaUCTOyz8g+I/uM7DOyz8g+I/uMXGfkOiPXGbnOyHVGrjNynZHrjFxn5Dojtxm5zchtRm4zcpuR24zcZuQ2I7cZuY3Iel0TygSawBNkgk6wCT6hTpiRy4xcZuQyI5cZuczIZUYuM3KZkcuMXGZkmpFpRqYZmWZkmpFpRqYZmWZkmpFpRuYZmWdknpF5RuYZmWdknpF5RuYZmWdkmZFlRpYZWWZkmZFlRpYZWWZkmZFlRtYZWWdknZF1RtYZWWdknZF1RtYZWWdkm5FtRp45qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagzhzUmYM6c1BnDurMQZ05qDMHdeagRg4+Xg80cjCgTKAJPEEm6ASb4BPqhBHZrmtCmUAT7l5guUEm6ASb4BPqhDbgzsEOZQJNmJHLjFxm5DIj3zmodEOd0AbcOdihTKAJPEEm6ASbMCPTjEwzMs/Idw6q3kATeMId2W/QCTbBJ9QJbcCdgx3KBJrAE2ZkmZFlRpYZ+c5Bu25oA+4c7FAm0ASeIBN0gk3wCTOyzsg2I9uMfOeg3VfnzsEOMkEn2ASfUCe0AXcOdigTZmSfkX1G9hnZZ2SfkX1G9hm5zsh1Rq4zcp2R64xcZ+Q6I9cZuc7IdUZuM3KbkduM3GbkNiO3GbnNyG1GbjNyG5H9uiaUCTSBJ8gEnWATfEKdMCOXGbnMyGVGLjNymZHLjFxm5DIjlxm5zMg0I9OMTDMyzcg0I9OMTDMyzcg0I9OMzDMyz8g8I/OMzDMyz8g8I/OMzDMyz8gyI8uMLDOyzMgyI8uMLDOyzMgyI8uMrDOyzsg6I+uMrDOyzsiRg3yDT6gT2oDIwYAygSbwBJmgE2Zkm5FtRrYZ2Wdkn5F9RvYZ2Wdkn5F9RvYZ2Wdkn5HrjFxn5Doj1xm5zsh1Rq4zcp2R64xcZ+Q2I7cZuc3IbUZuM3KbkduM3GbkNiO3Eble14QygSbwBJmgE2yCT6gTZuQyI5cZuczIZUYuM3KZkcuMXGbkMiOXGZlmZJqRaUamGZlmZJqRaUamGZlmZJqReUbmGZlnZJ6ReUbmGZlnZJ6ReUbmGVlmZJmRZUaWGVlmZJmRZUaWGVlmZJmRdUbWGVlnZJ2RdUbWGXnmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYN15mCdOVhnDtaZg3XmYJ05WGcO1pmDdeZgnTlYZw7WmYNt5mCbOdhmDraZg23mYJs52GYOtpmDbeZgmznYZg62mYNt5mCbOdhmDraZg23mYJs52GYOtpmDbeZgmznYIgftBp4gE3SCTfAJdUIbEDkYUCbMyDwj84zMM3LkoN/gE+qENiByMKBMoAk8QSbohBlZZmSZkWVG1hlZZ2SdkXVG1hlZZ2SdkXVG1hlZZ2SbkW1GthnZZmSbkW1GthnZZmSbkW1G9hnZZ2SfkX1G9hnZZ2SfkX1G9hnZZ+Q6I9cZuc7IdUauM3KdkeuMXGfkOiPXGbnNyG1GbjNym5HbjHznoJcbbIJPeER2uaF1KNedhINKEiVxkiRpkiV5Uk1KjZIaJTVKapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKmReV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmeeUeU6Z55R5TpnnlHlOmedRLuQWxEmSpEmW5Ek1qU2KPO9UklLDU8NTw1PDU8NTw1PDU6OmRk2Nmho1NWpq1NSoqVFTo6ZGTY2WGi01Wmq01Gip0VKjpUZLjZYabWpEUdGgkkRJnCRJmmRJnlSTUqOkRkmNkholNUpqlNQoqVFSo6RGSQ1KDUoNSg1KDUoNSg1KDUoNSg1KDU4NTg1ODU4NTg1ODU4NTg1ODU4NSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTY3Icw+SJE2yJE+qSW1S5HmnkkRJqWGpYalhqWGpYalhqeGp4anhqeGp4anhqeGp4anhqeGpUVOjpkZNjZoaNTVqatTUqKlRU6OmRkuNlhotNVpqtNRoqdFSo6VGS402NaJwaVBJoiROkiRNsiRPqkmpUVKjpEZJjZIaJTVKapTUKKlRUqOkBqUGpQalBqUGpQalBqUGpcad57UEtUl3ng96aFQJoiROkiRNsiRPqklt0p3ng1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1PDUsNSw1LDUsNSw1LDUsNSw1LDUsNTw1PDU8NTw1PDU8NTw1PDU8NTo6ZGTY2aGjU1amrU1KipUVOjpkZNjZYaLTVaarTUaKnRUqOlRkuNlhptakRx1KCSREmcJEmaZEmeVJNSo6RGSY2SGiU1SmqU1CipUVKjpEZJDUoNSg1KDUoNSg1KDUoNSg1KDUoNTo3Mc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzzTzXzHPNPNfMc80818xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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ehX0KuhV7Pt5bq/7eW70qtGrRq/aa8ATTrjgBeMNvPSqRYM7z8FLrxq9avSq0atGrxq9avSq0avWGG+7x7c1vPSqteI5jLfd49voVevB43jpVet46VWjV60z3s546VUbeAdeetXoVRvMM71qAy+9agPvwDs5vpN5pldt4p2Ml161yfGlV23inXgTL71q9KrRq0avWk6ew3jpVaNXjfVVo1etmGd61ehVK7yFl1411leNXrXCS6/awsv6qrG+aqyvGuurRq8avWr0qrG+avSqsb5qrK8a66tGrxq9apvjS6/a5vjSq06vOr3qrwZ3ePD8yeMJF89ZPH6/v531VY/gcbysrzq96vSqB97AG3jpVadXveGlV51eddZXnV71lvxs8TheetXpVWd91elVp1ed9VXvk9dhvKyvOuur3vHSq06vOr3qo/M4XnrV6VWnV531VWd91VlfddZXnV511led9VWfjJf1VZ+Ml/VVp1edXnV61Tkf7ImXXnV61elVp1edXnXWV51eddZXnV71wkuvOr3q9Kqzvur0qrO+6vSq06v+6VU7/Hj74cc7D0844YIXvC9/evVwwA3uMN6Nd+PdeDfefb3j9YIDbnCHBzzhhAteMN5Pr/JwwA3u8OOtwxPGG3gDb+BtjLcx3sZ4G+NtjLcx3oa34W14G96Ot+PteDvejrfj7Xg73o634x14B/M8mOfBPH969TDz/OnVw3gH3oF34p2MdzLeyXgn452MdzLeiXfinXgTb+JNvIk38SbexJt4E2/iLbzFPBfzXMxzMc/FPBfzXHgLb+FdeBfjXYx3MV56NejVoFeDXg16NejVoFeDXg16NejVoFeDXg16NejVoFeDXs3X7cZ8BdzgDt9uzNeEk9cseMF44wUH3OAOD3jCeOnVpFeTXk16NenVpFeTXk16NenVpFeTXs1Pr85cfXp1uDPPnXn+9OrM4adXD+OlV5NeTXo16dWkV5NezcF4B+MdjHfgHXgHXno16dWkV5NeTXo16dWkV5NezU+vzvx8evVwwczzp1dn3j69ehgvvZr0atKrSa8mvZr0atKrSa8mvZqFt/AW3sJbeAsvvZr0atKrSa/m4nO1+P4uvr9rwHx/V8J46dWkV5NeTXo16dWkV5NeTXo16dWkV5NeTXqVrK+S9VWyvkrWV8n6Kllf5et+rvJV8ILv9zfjfq7y06uH8dKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQqWV8l66ukV0mvsje4w/e/C9knjJdeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa9yMt454Anzufr06szDp1cP42V9lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeZTHeYrzF96j4HtXtcy6+R6yvkvVVsr5K1lfJ+ipZXyW9SnqV9CrpVdKrpFdJr5JeJb3KzXg3492Md99u1OuOt14BX2/Rq6JXRa+K9VWxvirWV8X6qlhfFeuroldFr4peFb2quOOtKHjBjLcx3sZ46VXRq6JXRa+KXhW9KnpV9Ko4HyzOB4vzweJ8sFhfVb+f5+qMtzPeznj7/TzXYLz0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvqu5/j4rzweJ8sDgfrLr/PSrOB4v1VbG+KtZXxfqqWF8VvSp6VfSq6FXRq1rM8+JztfhcLb5Hm8/V5ntEr4peFb0qelWsr4r1VbG+KtZXi/XV4nxwcT64OB9crwHfeV6vhIvXXDBeerXo1aJXi14terXifp4XvVr0atGrFff7u+jVYn216NWiV4teLXq16NWiV4vzwcX54GJ9tVhfLc4HF+eDi14tzgcX66vF+mqxvlqsr9bAy/WrxfWrxfWrNe73aHH9atGrRa8WvVr0atGrNfFOvPRq0as18U4+V1y/Wly/WvRq0auVeBNv4k28iTfx0qtFrxa9WvRq0atFrxa9WvRq0atFrxa9WqyvVvG5Wng5H1yLz9Xic0Wv1uJ7RK8WvVr0ai2+R/Rqbbyb8W7Gu5nnzXg383x69XNmd3jB+zc/+9u/HIf74Qb3w3l4HF6HJ5zw8cbr8IKP9+ztfPa3fzngBh9vzMMDPt6zz/PZ3/7lgo+3nfd8evXh06s8ez6f/e1fPt6z5/PZ3/7l4z37PJ/97V9O+Hj78/oLPt6zz/PZ3/7lgI/37Pl89rd/+XjHeW+nV18+3nnm+fTqyws+3jxzfnr15ePN855Pr758vGef57O//cvHm8d7evXlgo+3zlydXn349OrnbOVwwA3u8PGu8zk8vfpywse7zns+vcqzR/TZ3/7hfLxnHjLg4z33zp797V8e8PGe+2jP/vYvv731fEdOr768L59e/Zx9HA64HT7v7fTqy29vPZ/n06svJ3y8cT4Pp1dfPt4483969eWAj7edcZ1efXnAx9uO6/Tqy8f7fP5Pr+r5nJ9effj06ssBN7jDA55wwgXj3b+9/dnf/uWAG9zhAU844YIXjDfwBt7AG3gDb+ANvIE38AbehrfhbXjb483DA57w463DBS94X+4vOO7r9Abj7YPnTxhvx9vxdrwD78A78A68g/EOxjvwDrwD78A78c6AG9xhxjvxzoQLXvC+nHgTb+JNvIk3medkvMl4k/Em3qdXH2aei3ku5rnwFt7CW3gLbzHPi/EuxrsY78K7OL6LeV7M82KeF96Fd+PdeDfezTxvxrsZ72a8G+/m+O47z/F6wQFfb7w6POAJJ1zwgu94I14w3mhwhwc8YbyBN/AG3oa3Bcx4G+NtjJdeRUu44AUzz/QqOt6Ot+OlV0Gvgl4FvQp6FR3v4PjSq6BXQa9i4B146VXQq6BXQa+CXgW9CnoVE+/k+NKroFdBr2LinXjpVdCroFdBr4JeBb0KehWJNzm+9CroVdCrKLyFl14FvQp6FfQq6FXQq6BXsfAuji+9CnoV9CoW3oWXXgW9CnoV9CroVdCroFex8W6OL70KehX0qr2ut70CbnCHBzzhhAteMN54wQE3uMN4Ay+9avSq0atGrxq9avSq0avG+qqxvmr0qtGrRq8a66vG+qrRq0avGr1q9KrRq0avGr1qHW9fMPNMrxq9agPvwEuvGr1q9KrRq0avGr1q9KpNvJPjS68avWr0qk28Ey+9avSq0atGrxq9avSq0auWeJPjS68avWr0qhXewkuvGr1q9KrRq0avGr1q9KoV3sXxpVeNXjV61RbehZdeNXrV6FWjV41eNXrV6FXbeDfHl141etXoVdt49/V2etXpVadXnV51etXpVadX/XW9/bXgO8+dXnV61QNv4KVXnV51etXpVadXnV51etUb3tbgDg94wng5H+z0qtOrTq86ver0qtOrTq96x9sTZp7pVadXnfPBPvDSq06vOr3q9KrTq06vOr3qA+/k+NKrTq86veqcD/aJl151etXpVadXnV51etXpVU+8yfGlV51edXrVOR/siZdedXrV6VWnV51edXrV6VUvvMXxpVedXnV61Tkf7Asvver0qtOrTq86ver0qtOrvvFuji+96vSq06vO+WDfeOlV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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AQ8nAhAEGAAIARABJwMPBAEAIg8CECcCEQQXACoREBEtChASDCoSERMWChMTJAIAEwAAB00uDIBHABIAIhICEiMAAAcsJwIQADcnAhIEEy0IABMtCgwULQoOFS0KEBYtCg8XAAgAEgAlAAAeLS0CAAAtChQRLQsRDAAiDAIMLQ4MEScCDgQSLQgAEi0KERMuCIBJABQACAAOACUAAB7wLQIAAC0KEwwtCxEOACIOAg4tDg4RJwIOBAwnAhMEFC0IABQtChEVLQoOFgAIABMAJQAAHvAtAgAALQoVEgEiABGASQAULQsUExwKExQEHAoUEQAcChETBScCHgQfLQgAHy0KDCAACAAeACUAACAeLQIAAC0KIBEtCiEULQoiFS0KIxYtCiQXLQolGC0KJhktCicaLQooGy0KKRwtCiodJwIoBCktCAApLQoSKgAIACgAJQAAIB4tAgAALQoqDC0KKx4tCiwfLQotIC0KLiEtCi8iLQowIy0KMSQtCjIlLQozJi0KNCcMKg0TEhYKEg0cChITBhwKDRIGBCoTFA0EKhIeEwAqDRMSJwINBgAKKhINEyQCABMAAAjGJQAAIV8eAgANBigCABIFA4QAKg0SEw4qDRMUJAIAFAAACOklAAAhcQwqEwYNJAIADQAACPslAAAhgy0LCw0AIg0CDS0ODQsnAhIEKC0IACgtCgspLgiASwAqLgiARQArAAgAEgAlAAAbgC0CAAAtCikNCyIADYBHAAsLIgALgEUAEiQCABIAAAlQJQAAHU4nAhIEKC0IACguCIBFACkuCIBHACotCgorLQoNLAAIABIAJQAAHWAtAgAALQopCy0IARIAAAECAS0OCxItCAELAAABAgEuDIBGAAstCw8TACITAhMtDhMPJwIUBCgtCAAoLQoSKS0KCyotChArLQoPLAAIABQAJQAAHi0tAgAALQopEy0LEwsAIgsCCy0OCxMnAg8EKC0IACgtChMpLgiASQAqAAgADwAlAAAe8C0CAAAtCikLLQsTDwAiDwIPLQ4PEycCEAQoLQgAKC0KEyktCg4qAAgAEAAlAAAe8C0CAAAtCikPASIAE4BJABAtCxAOHAoOEgQcChIQABwKEA4FJwIuBC8tCAAvLQoLMAAIAC4AJQAAIB4tAgAALQowEC0KMRItCjITLQozFC0KNB4tCjUoLQo2KS0KNyotCjgrLQo5LC0KOi0nAjgEOS0IADktCg86AAgAOAAlAAAgHi0CAAAtCjoLLQo7Li0KPC8tCj0wLQo+MS0KPzItCkAzLQpBNC0KQjUtCkM2LQpENy8KAA0ADxwKDzkEHAo5OAACKg84OSwCAA8ALV4Ji4K6N7Q7maExYRj9INQvUWbJ6fE/teplqW0eCm0EKjkPOBwKODoEHAo6OQACKjg5OgQqOg84HAo4OwEcCjs6ABwKOjsBAio4OjwsAgA4ADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCo8OD0cCj0+BBwKPjwAAio9PD4EKj4PPRwKPT4BHAo+DwAcCg8+AQIqPQ8/BCo/OD0cCj0/BBwKPzgAHAo4PQUWCj44HAoPPgUcCjg/BQQqPj04HAo8PQUWCjs8HAo6OwUcCjw+BQQqOz08HAo5OwUeAgA9BgwqPTtAJwI7BbQkAgBAAAAMFCMAAAv3HAo6DAUEKgw8EQQqPjsMACoRDBUtChUJIwAADDEcCg8MBQQqDDgRBCo/OwwAKhEMFS0KFQkjAAAMMQAqPQkRDio9ERUkAgAVAAAMSCUAACFxDCo9DgkWCgkOHAoJFQAcCg4WAAQqFRAXBCoWCxAAKhcQCxwKCRAGHAoOFwYEKhASGAQqFy4SACoYEhkEKhUTEgQqFi8TACoSExUEKhAUEgQqFzATACoSExQEKhAeEgQqFzETACoSExYEKhAoEgQqFzITACoSExgEKhApEgQqFzMTACoSExoEKhAqEgQqFzQTACoSExsEKhArEgQqFzUQACoSEBMcCgkQBRwKDhIFBCoQLBcEKhI2EAAqFxASHAoJEAIcCg4JAgQqEC0OBCoJNxAAKg4QCS0IAQ4AAAECARwKERAAJwIRACAnAhwEPS0IAD0tCgo+LQoRPwAIABwAJQAAIZUtAgAALQo+FwQqORcRACoQERcnAhAAQCcCHAQ9LQgAPS0KCj4tChA/AAgAHAAlAAAhlS0CAAAtCj4RBCo6ERAAKhcQERwKPBAAJwIXAEgnAh0EOS0IADktCgo6LQoXOwAIAB0AJQAAIZUtAgAALQo6HAQqEBwXACoRFxAnAhEAaCcCHAQ5LQgAOS0KCjotChE7AAgAHAAlAAAhlS0CAAAtCjoXBCoPFxEAKhARDxwKOBAAJwIRAHAnAhwEHS0IAB0tCgoeLQoRHwAIABwAJQAAIZUtAgAALQoeFwQqEBcKACoPChAtCAEKJwIPBBgACAEPAScDCgQBACIKAg8tCg8RLQ4QEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARLQ4KDhwKGQoAHAoUDwAcChYQABwKGBEAHAoaFAAcChsWABwKExcAHAoSEwAcCgkSAC0IAQknAhgEDAAIARgBJwMJBAEAIgkCGC0KGBktDgsZACIZAhktDgoZACIZAhktDhUZACIZAhktDg8ZACIZAhktDhAZACIZAhktDhEZACIZAhktDhQZACIZAhktDhYZACIZAhktDhcZACIZAhktDhMZACIZAhktDhIZHAoICgAcCgYIAC0IAQYnAgsEDAAIAQsBJwMGBAEAIgYCCy0KCw8tDgUPACIPAg8tDgoPACIPAg8tDgcPACIPAg8uDIBHAA8AIg8CDy4MgEcADwAiDwIPLgyARwAPACIPAg8uDIBHAA8AIg8CDy4MgEcADwAiDwIPLgyARwAPACIPAg8tDggPACIPAg8uDIBKAA8uCIBGAAwjAAAQig0iAAyAUQALJAIACwAAGm4jAAAQny0LDgktCwkLACILAgstDgsJLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDi4MgEcADgAiDgIOLgyARwAOACIOAg4uDIBHAA4rAgAMAAAAAAAAAAAXAAAAAAAAAAAtCAEOJwIPBAUACAEPAScDDgQBACIOAg8tCg8QLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLQ4MEC0IAQwAAAECAS0OCwwtCAELAAABAgEtDg4LLQgBDgAAAQIBLgyARgAOLQgBDwAAAQIBLgyARQAPLQsJEAAiEAIQLQ4QCS4IgEYABiMAABGODSIABoBS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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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DWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENsPmkygXFrCCDeyggAoaOEBsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGltjZ6OLYwA76TTgnDbKgETQvGuedTKcSVINaUA+SIA2yoBEUjhKOEo4SjrOtzbGDAvomnI4GHpvQb8n77MkLva0vLGAFG9hBARU0EFvF1rA1bN7WPkPAZ08u7KCAChroNt863tYneltf6MO4TjWoBfUgCdIgr3gcLv5iyu6zFnxaZPdJCT4tcqGACvqS+l7wJr1wBnqTXlhAv9Hl1IIOl99S8EmRCxU8XD5m5JMiF85Ab9HzSPIWvfBYs1PhLXphB33NnDTIgkbQXOTdeZJX9M3mP97ndvUf7zYcBzgD/cf7wmNJffKET3Fc2MAOCnjYfPH9t/uk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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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0qukV8l+exbXl14lvUp6ldwPJvtXSa+SXiW9SnqV9CrpVdKr5H4wN9eXXiW9SnqV3A8m94OTXk16NenVpFeTXk16NenVZL998v3gpFeTXk16Ndm/muxfTXo16dWkV5NeTXo16dWkV5P99sn3g5NeTXo16dVk/2qyfzXp1aRXk15NejXp1aRXk15N9tsn3w9OejXp1aRXk/vByf3gpFeTXk16NenVpFeTXk16Ndlvn3w/OOnVpFeTXk3uByf7V5NeTXo16dWkV5NeTXo16dVkv33y/eCkV5NeTXo1uR+c7F9NejXp1aRXk15NejXp1aRXk/32yfeDk15NejXp1eR+cLJ/NenVpFeTXk16NenVpFeTXk32ryb7V5NeTXo16dXkfnCy3z7p1aRXi14terXo1aJXi14t9tsX3w8uerXo1aJXi/vBxX77oleLXi16tejVoleLXi16tdhvX3w/uOjVoleLXi3uBxf77YteLXq16NWiV4teLXq16NViv33x/eCiV4teLXq1uB9c9Gqxvlqsrxa9WtwPLvbbF/tXi14terXo1WJ9tT7rq3747tet7PCAA054wgsu+O4TrntIs62Jd+KdeCfeiXfinXgn3ol34V14F96Fd+FdeBfehXfhXXgLb+EtvIW38HI/uNi/WuxfLXq16NWiV4v11WJ9tejVoleLXi16tejVoleLXhW9KnpV9Kr4frD4frDoVdGrolfF/WCxf1X0quhV0auiV0Wvil4VvSq+Hyy+Hyx6VfSq6FVxP1jsXxW9KnpV9KroVdGroldFr4rvB4vvB4teFb0qelXcDxb7V0Wviu8Hi/VVsb4qelWsr4r1VdGrYr+92G8vzjMU66vifrDYvyr2r4r99mJ9VayvivVVsb4q1lfFfnvx/WDx/WBxnqFYXxX3g8X+VbF/Vey3F+urYn1VrK+K9VWxvir224vvB4vvB4vzDMX6qrgfLPaviv2rYr+9WF8V66tifVWsr4r1VdGr4vtBTpw3jpw3zpw3Dp03Tp03jp03zp03Dp63oldFr4pecfi8bfbbN+cZNr3a9GrTK46gt83+1aZXm15terXpFQfRGyfRG0fR22a/fXOeYdOrTa82veJAetvsX216tenVplebXnEsvXEuvXEwvW322zfnGTa92vRq0yuOp7fN/tWmV5tebXq16RWH1Bun1BvH1NtmfbVZX216tenVplccVm+b9dWmV5tebXq16RVH1htn1huH1ttmv33z/eCmV5tebXrF0fW22b/a9GrTq02vNr3iAHvjBHvjCHvb7Ldvvh/c9GrTq02vOMjeNvtXm15terXp1aZXHGdvnGdvHGhvm/XVZn216dWmV5tecay9bdZXm15terXp1aZXHG5vnG5vHG9v++6399f9frC/bq/66/aqv26vOufb++vuX/XX7VV/3V711+1Vf91edc63d863d86391fDe78f7K/bq/66veqv26vO+fb+ang73o6347296pxv75xv75xv76+O934/2F+deR7M82CeB96Bd+AdeAfewTwPxjsYbzDewBtc32Ceg3kO5jnwBt7AG3gTbzLPyXiT8SbjTbzJ9U3mOZnnZJ4n3ol34p14J97JPE/GOxnvZLwT7+L6LuZ5Mc+LeV54F96Fd+FdeBfzXIy3GG8x3sJbXN9inot5Lua58BbejXfj3Xg387wZ72a8m/FuvJvrS68avWr0ivPtvd39q97oVaNXjV41esX59s759s759t4a3vv9YG/0qtGrRq84395bw0uvGr1q9KrRK863d863d86399bx3u8He6NXjV41esX59t4GXnrV6FWjV41ecb69c769c769t4E3uL70qtGrRq84395b4KVXjV41etXoFefbO+fbO+fbe0u8yfWlV41eNXrF+fbeEi+9avSq0atGrzjf3jnf3jnf3tvEO7m+9KrRq0avON/e28JLrxq9avSq0SvOt3fOt3fOt/dWeIvrS68avWr0ivPtnfPtnfPtnfPtvdErzrf3tvFuvPSK8+2d8+2d8+39e769H37Gmz/8Pd9eh4/3/X9l6Z/z7e8/pt8/59vjef7xvv9nWv1zvv3Dx/v+/0f0z/n2Dx9vPq+/Lz+9muf1n17N5/EOD/h433+Qv3/Ot3/4eN9/lL9/zrd/+HjXec9Prx5+erXOaz69+nCHj7fOPDy9+vDx1vE+vfrwggs+3vffF9A/59s/3ODj3ec9P73a530+vfrw8e4zz0+vPvz25uu8t9OrL+/Lp1f5OvN8evXltzfbeQ+nV18OOA+f93Z69eXjbee9nV59+Xjff+13f863f7nBx9vPZ+P06svHez7bz/n2HOc9nF59ecHHO877Ob368OlVjvOap1df7vDxPp/506svH+/zeT69+vKCjzfO+zy9+vDpVeaZ29OrLx9vnrGfXn35ePO85unVlyd8vPm8fsHH+/y+OL36coOPd53PwOnVl493nfd2evXl460zt6dXXy74eOvM8+nVl4+3jvf0Kvd5zdOrfD7bp1ffxxOe8IIL3r/5Od/+vOZzvv37eOfxweMBJzx5/uLxgvG2F9zuz7bO43gb3pY8f/L44nG8bd/HO97OeDvePng+3o634+14O97OeAfewXgH3sF4R/Ac5nkwz4N5fnr1eRxv4A3GG3gDb+ANvMF4A2/gDbzJ5yrxJt7Em8xzMs+JN5nnZJ4T78Q78U68E+/EOxnvxDsZ78Q7+Vwt5nnhXfw+WngX3oV3cX0X3sU8L8ZbeIvPVTHe4vNceIt5LsZbeIvxFt6Nd+OlV2Mz3s3nil4NejXo1aBXg17F6wVfb7w6jw844IQnP7t4vOB7fYNeBb0KehX0KlrwHLwNb8NLr4JeBb2KjpdeRcfb8Xa89Co6XnoV9CroVYwG389z0KugV0GvYuClVzHw0qugV0GvIvDSqwiubyTPwUuvgl4FvQp6FfQq6FXQq6BXkYw3ub6Jl15Fcn0n451cX3oVc/A4XnoVEy+9CnoVk/EuxkuvYuFdeOlV0KtYzDO9ioWXXkXhLbzF9S3mmV5F4S3GS6+iuL70KjbejXfjpVdBr4JeBb2KvXgO46VXSa+S9VXSq3zdeU56lfQqXxNePL94HC+9yoaXXmXDy/oqWV8l66tkfZX0KulV0qtkfZX0KllfJeurZH2V9CrpVfbiOYx33Oub9CrpVdKrHHjpVbK+SnqV9CoH46VXGY3HGW8wXnqVrK+SXiW9ysAbeBMvvUp6lYmXXiW9StZXSa8ymWfWV0mvkl4lvUrWV0mvkl4l66ucfK7oVbK+StZXufDSq6RXSa9y8bmiV0mvkl4lvUrWV8n6KllfJeurpFfJ+ipZX2UxXtZXWYyX9VXSq6RXSa+S+8HceOlV0qukV0mvJr2arK8mvZqsrya9mq/k+ZPHF48Xj9/xTno1WV9NejXp1fz0Kg4/3jz8eNfhBRe8L3969XCDOzzggBPG2/F2vB3vwDvwDrwD78A78A68A+/AO/AG3sD76VUdHnDACT/efXjBeANv4k28yXiT8SbjTcabjDcZb+JNvBPvxDvxTrwT78Q78U68E+/Eu/AuvAvvYp4X87yY50+vHmaeP716GG/hLbyFtxhvMd5ivMV4i/EW4y28G+/Gu/FuvBvvxrvxbrwb777e9XrBDe7wnef1CjjhCd95Xq+C8Ta8DW/D2wYccMITXnDBeOnVoleLXi16tejVoleLXi16tejVoleLXi16tcbtxhrM82CeB/M8bjfWYJ7p1aJXi14terWC8QbjDcYbjDcYbzBeerXo1aJXi14terXo1aJXi14terXo1aJXi16tT6/OXH169TDzPJnnT6/OHH569TBeerXo1aJXi14terXo1VqMdzHexXgX3oV34aVXi14terXo1aJXi14terXo1fr06szPp1cP78ubef706szbp1cP46VXi14terXo1aJXi14VvSp6VfSqXgMOOOEJL7hgvPSq6FXRq2r3c1Ut4IQnfH//VisYL70qelX0quhV0auiV0Wvil4VvSp6VfSq6FWxvirWV8X6qlhfFeurYn1V436uatzPVcULbvD9XNWnVw/jpVdFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FWxvirWV0Wvil7V5HM1+VzN+9+Fmnyu6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhVFeMtfh/Rq6JX9enVmYdPrx7Gy/qq6FXRq6JXRa+KXhW9Knq16dWmV5tebXq16dWmV5te7dcd734VfH8f7faCb5936zBe1leb9dVmfbVZX23WV5tebXq16dWmV5tebXq16dWmV5te7c54O+MdjHc0mPGOAeOlV5tebXq1WV9t1leb9dVmfbVZX23WV5tebXq16dWmVzsYbzDeZLzJeJPxJuOlV5tebXq16dWmV5tebXq16dXmfnBzP7i5H9zcD27WV3vyeZ6MdzLexXgXn+fFeOnVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplf79mq8bq/G6/ZqvF6//3s0Xvd+cLzu/eB43fvB8Xr9/u/ReN37wfG666vxeuFteBveu74ar9ur8bq9Gq/bq/G6vRqv26vxanXfW9uX+wtucL/vuQ8Yb8fb8Xa8nfF2xjsY72C8g/EO5nkwz4N5HhNmnkfBeANv4A28wTwH4w3GG4w31n0PwTwH85zMc7b73pJ5TryJN/Em3mSek3lOxjvxTq7v5PM8med7Pzhe935wvCbeiXfinXgX87yY54V34V1c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vBMvver0qtOrTq86ver0qtOrvvAuri+96vSq06teeAsvver0qtOrTq86ver0qtOrXng315dedXrV6VXfeDdeetXpVadXnV4NejXo1aBX43W94xVwwhNecPE6eOnVoFeDXg16NejVoFeDXo2GtxV853nQq0GvRsfb8dKrQa8GvRr0atCrQa8GvRoD7+gw80yvBr0aA+/AS68GvRr0atCrQa8GvRr0agTe4PrSq0GvBr0a3A8O7gcHvRr0atCrQa8GvRr0atCrkXgn15deDXo16NXgfnBMvPRq0KtBrwa9GvRq0KtBr8bCu7i+9GrQq0GvBveDY+GlV4NeDXo16NWgV4NeDXo1Cm9xfenVoFeDXg3uB8fGS68GvRr0atCrQa8GvQp6Fa/rjVeHBxxwwpPXWXDBeOlV0KugV0Gvgl5Fw9smvOCC7zwH94PR8dKroFdBr4JeBb0KehX0Kjre8YKZZ3oV9Cq4H4yBl14FvQp6FfQq6FXQq6BXEXiD60uvgl4FvQruB4NeBeurYH0V9Cq4H4zEy/5V0KugV0GvgvVVfHqVh4/3/eep4znf/uXjHef1n159OOEJL7jgffnp1Ycb3GG8C+/Cu/AuvAvvwlt4C2/hLbyFt/AW3sJbeAvvxrvxbrwb78a78W68G+/Tq/e5nXjOtz/8nG//coM7POCAE57wgo/3/f8Fi+d8+4efXr3P3cVzvv3LnecMOHhOwpPnLPjxxmG8T68+jPfp1YfxPr36MN6nVx/G2xnv06vnPQy8T68+jPfp1YfxPr36MN6nVx/GOxjv06vnPQTeYJ4DbzDPgTeY58D79OrDeJPxPr163kPiTeY58SbznHiTeU68T68enngn43169byHiXcyzxPvZJ4n3sk8T7yLz/PCuxjv06vnPSy8i3leeBfzvPAu5rnwFp/nwluM9+nV8x4KbzHPhbeY58K7meeNd/N53ng343169byHp1cffrx1uOD9m5/z7V9ucIcHfLzvs4XxnG//8oQXXPC+/PTqww3u8IDxPr3KPDzhBT/eefjx7jc/vfpwgzs84ON9n3uM53z7zzfghye84IL35adXH25wh493nnl+evXh411n7E+v1nk/T6/WOlzwvvz06sMN7vCAA054wngDb+BNvIk38SbexJt4E2/iTbyJd+KdeCfeiXfinXgn3ol34p14F96Fd+FdeBfehXfhXXgX3oW38Bbewlt4C+/Tq/e5mnjOt+86n6unVx8ueF9+evXhBnd4wAEnjHfj3Xj39T7n27/c4A4POOCEJ7zggvE2vA3v06v3eaF4zrd/OeCEJ7zggvflp1cfbjDejrfj7Xg73o634+14B96Bd+AdeAfegXfgHXgH3oE38AbewBt4A2/gDbyBN/AG3sSbeBNv4k28iTfxJt7Em3gn3ol34p14J96Jd+KdeCfeiXfhXXgX3oV34V14F96Fd+FdeAtv4S28hbfwFt7CW3gLb+HdeDfejXfj3Xg33o1349149/U+59u/3OAODzjghCe84ILxNrwNL70qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplebXm16tenVplf79ipft1f5ur3K1+1Vvm6v8nV7la/bq3zdXuXr9ipft1f5euFteBvehrfhbXgb3oa34W14G96Ot+PteDvejrfj7Xg73o634x14B95Pr9bhx7sP/3j76/1nw/Ocb//N883vP9Od53z7b67D8/C+/O7Vb25v7sf77tUPn9d89+o3H+/7u7Y859t/8/H2/PuvP/zvf/7bn//5X/7yp//1h//2nz//+j/+41//+O9//uu/fv713//Pv31/5V/+9ue//OXP//Of/u1vf/3jn/77f/ztT//0l7/+8f1rf3h9/vEPP+vF/etnQfj6x19/+Hl3//DTjPr1E4j58+/j/PrPduTPk/L96+8f+Nl0HL9+/lHvB85P/HxMfv38I//x7+cl/vP83M+XTNG/P5PtV873L/f3L5+HevvVz0Pj90M/c9Tb+6H4vkivX6O+L/KzJRz7/cv5//7EvK8bv/p51roPrV+jvx+q+4P7V4/3Q/s7D338/GDmZ9Q/25brt7i/NT+ez3j7z3efva8z2t/T2Nf48cbnx392eefr94//TGB//vX8+HyPfJwfb98fbz/T1XJ8fry1n3/rv2ev/XwAWv893y3j57ln7lr/r77A+D2A+BnkXL8ne/3Kft9y/errdX4g7hyun2k4j+X//6K3e3Xmz8Tk92Vr/aqfS/X3v//j3/8v",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3friW5cWf9Ln3ti00yIkjqVQYDQ/ZoBgIEyZDlD/hg+N1nM5jkijrlw8qz9+m5US91V8XKf/ztTJLJ/M/f/tef/uU//s8///mv//tv//7bH/7Hf/72L3//81/+8uf/889/+du//vEff/7bX5//9j9/e4z/SbX+9ofyT89/tt/+oOOf/bc/1Oc/2/M/9/HP9NsfUhqQnzD+Wa5/yvVPff5zVGi2oC5oC/oF/bEgLcgLygJZsCr3Vbmvyn1V7lfl/HgsSAvygrJAFugCW1AXtAWrclqV06qcVuW0KqdVOa3KaVVOq3JaldOqnFflvCrnVTmvynlVzqtyXpXzqpxX5bwql1W5rMplVS6rclmVy6pcVuWyKpdVuazKsirLqiyrsqzKsirLqiyjch1QF7QF/QJ9LEgL8oKyQBboglVZV2UdlduAfoE9FqQFeUFZ8Kyc04Bn5awDbEFd0Bb0C+pjwbNy7gPygrJAFjwrl8cAW1AXjMrjQI3m5zDa34Rn5TIUowFOKAtkgS6wBXVBW9AvGG1wwqrcV+W+KvdVua/KfVXuq3JflftVuTweC9KCvKAskAW6wBbUBW3BqPw8p2W0wQlpQV5QFsgCXWAL6oK2YFXOq3JelfOqnFflvCrnVTmvynlVzqtyXpXLqlxW5bIql1W5rMplVS6rclmVy6pcVmVZlWVVllVZVmVZlWVVllVZVmVZlWVV1lVZV2VdlXVV1lVZV2VdlXVV1lVZV2VblW1VtlXZVmVblW1VtlXZVuXRBuUxoF8w2uCEtCAvKAtkgS6wBXXBqlxX5bYqt6uyjMM7WqWMwytpwPjr/m/agn7BOJgT0oK8oCyQBbrAFqzKuirrqmyrsq3Ktirbqmyrsq3Ktirbqmyrsq3KdVWuq3JdleuqXFfluirXVbmuynVVrqtyW5XbqtxW5bYqt1W5rcptVW6rcluV26rcV+W+KvdVua/KfVXuq3Jflfuq3FflflXWEWhiA9KCvKAskAW64FlZHwPqgragXzACTdOAtOBZWWVAWSALdIEtqAvagn7BCLQJacGqnFflvCrnVXkEmuqAuqAt6BeMQJuQFozKdUBZIAuelW3s6Qi0CXVBW9AvGIE24VnZxvaMQJtQFsiCUXnYR6BNqBeMhqZtwPjr41yMZmX+b55/uI7jPJrVhLagXzCa1YS04FmnjsqjWU2QBbpgVB6u0awmjMp9QL9gNKsJaUFeUBY8K7dx1Y1mNcEW1AXPym0chNGsHEazamMzRrOakBeUBaPyUIxmNcEW1AVtQb9gNKs+pKNZTcgLyoJn5T42YzSrCbZgVB5XwmhWE/oEG21nwvjrOuD5h3sbMG7e8oDnH+7PzbDRUiakBXlBWSALdIEtqAvaglU5r8p5Vc6rcl4b5nfdj8cg21Q3tU19kd96P2RQ2pQ3lU2ySTe5YxwHvwOf1Db1RX4T/hgb6nfhk/Km4UhjW/xGfJJuGg4/xH4vPm7PzW/G09hfvxt38tvxSWlT3lQ2DUcelf2efJJtqpvapr7Ib8wnpU15U9m0HbYdth22HdXrjX2raVPeVDbJJl3kz7Hjt938QXaSVx5npu8t7XtL+9rS6s+c4zmg+kPnpLJJNukm21Q3tU19kT98TtqOtB1pO9J2pO1I25G2wx85sw3yv1sH+d/tg3STbaqb2qa+yK/2SWlT3lQ2bUfZjrIdZTvKdpTtkO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7bDtsO2w7bDtsO2w7bDtsO2w7bDtqNtRt6NuR92Ouh11O+p21O2o21G3o21H2462HW072na07Wjb0bajbUfbjr4dfTv6dvTt6NvRt6NvR9+Ovh19OdrjsSltypvKJtmkm2xT3dQ2bUfajrQdaTvSdqTtSNuRtiNtR9qOtB15O/J25O3I27HbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO923nc777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO92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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vL3djjS9cp15LzrWQTIYP6RvxRgYsqwxBGxIhiwPMDB871MMkrHi7Vaxs6vqm5Pdz/fu7liZTMZK/iX5v//uv/3Tf/1f//2//PO//N//+j//7j/95//9d//13/75b3/75//+X/72r//4D//+z//6L49//d9/d43/KfXxo/z942dZP2n9rOsnr5+yfur6aetnWz/7/MkrHq94vOLxiscrHq94vOLxiscrHq94suLJiicrnqx4suLJiicrnqx4suLJiqcrnq54uuLpiqcrnq54uuLpiqcrnq54tuLZimcrnq14tuLZimcrnq14tuLZitdWvLbitRWvrXhtxWsrXlvx2orXVry24vUVr694/RFPxs+6fvL6Keunrp+2frb1s/tPuq71s6yftH7W9fMRT8dPWT91/bT1s62fff4sj3h9/BzXVwfQhrqBN8gG3TDu2ga0DX0BXRtG5DaANtQNI3IZIBt0wyMyDQlqG/qCkTITygbaUDfwBtmgG3bkuiPXHZl3ZN6ReUfmHZl3ZN6ReUfmHZl3ZN6RZUeWHVl2ZNmRZUceuUTjYY5kmmAb2oa+YCTUhLKBNtQNvGFH1h1Zd2TdkXVHth3ZdmTbkW1Hth3ZdmTbkW1Hth3ZduS2I7cdue3IbUduO3LbkduO3HbktiO3HbnvyH1H7jty35H7jtx35L4j9x2578h9Ra7XtaFsoA11A2+QDbrBNrQNO3LZkcuOXHbksiOXHXnkILUBusE2tA19wcjBCWUDbagbeMOOTDsy7ci0I48crI8qWkcOTigbaEPdwBtkg26wDW3Djsw7Mu/IvCOPHKw6gDfIBt1gG9qGvmDk4ISygTbsyLIjy44sO/LIQb4GtA19wcjBCWUDbagbeINs0A07su7IuiPbjmw7su3ItiPbjmw7su3ItiPbjmw7ctuR247cduS2I7cdue3IbUduO3LbkduO3HfkviP3HbnvyH1H7jty35H7jtx35L4i83VtKBtoQ93AG2SDbrANbcOOXHbksiOXHbnsyGVHLjty2ZHLjlx25LIj045MOzLtyLQj045MOzLtyLQj045MO3LdkeuOXHfkuiPXHbnuyHVHrjty3ZHrjsw7Mu/IvCPzjsw7Mu/IvCPzjsw7Mu/IsiPLjiw7suzIsiPLjiw78s5B3jnIOwfZc5AGlA20oW7gDbJBN9iGtqEvsB3ZdmTbkW1Hth3ZdmTbkW1Hth3ZduS2I7cdue3IbUduO3LbkduO3HbktiO3HbnvyH1H7jty35H7jtx35L4j9x2578h9RZbr2lA20Ia6gTfIBt1gG9qGHbnsyGVHLjty2ZHLjlx25LIjlx257MhlR6YdmXZk2pFpR6YdmXZk2pFpR6YdmXbkuiPXHbnuyHVHrjty3ZHrjlx35Loj1x2Zd2TekXlH5h2Zd2TekXlH5h2Zd2TekWVHlh1ZdmTZkWVHlh1ZdmTZkWVHlh1556DsHJSdg7JzUHYOys5B2TkoOwdl56DsHJSdg7JzUHYOys5B2TkoOwdl56DsHJSdg7JzUHYOys5B2TkoOwdl56DsHJSdg+I5qAPahr7Ac9ChbKANdQNvkA26YUfuO3JfkfW6NoxeYB1AG+oG3iAbdINtaBv6gpGDE3bksiOXHbnsyGVHLjty2ZHLjlx2ZNqRaUemHXnkoMgA3iAbdINtaBv6gpGDE8oG2rAj1x257sh1Rx45KKMwRw5O6AtGDk4oG2hD3cAbZINu2JF5R+YdWXbkkYPSB9CGumF05csA2aAbbEPb0BeMHJxQNtCGumFH1h1Zd2TdkUcOKg/oC0YOTigbaEPdwBtkg26wDTuy7chtR2478shBHU9n5OAE3iAbdINtaBv6gpGDE8qGHbnvyH1H7jty35H7jtx35L4i23VtKBtoQ93AG2SDbrANbcOOXHbksiOXHbnsyGVHLjty2ZHLjlx25LIj045MOzLtyLQj045MOzLtyLQj045MO3LdkeuOXHfkuiPXHbnuyHVHrjty3ZHrjsw7Mu/IvCPzjsw7Mu/IvCPzjsw7Mu/IsiPLjiw7suzIsiPLjiw7suzIsiPLjqw7su7IuiPrjqw7su7IuiPrjqw7su7ItiPbjmw7su3ItiPbjuw5aANsQ9vQF3gOOpQNtKFu4A2yYUduO3LbkduO3HfkviP3HbnvyH1H7jty35H7jtx35L4it+vaUDbQhrqBN8gG3WAb2oYduezIZUcuO3LZkcuOXHbksiOXHbnsyGVHph2ZdmTakWlHph2ZdmTakWlHph2ZduS6I9cdue7IdUeuO3LdkeuOXHfkuiPXHZl3ZN6ReUfmHZl3ZN6ReUfmHZl3ZN6RZUeWHVl2ZNmRZUeWHVl2ZNmRZUeWHVl3ZN2RdUfWHVl3ZN2RdUfWHVl3ZN2RbUe2Hdl2ZNuRbUe2HXnnYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg23nYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYRw7aNaBu4A2yQTfYhrahLxg5OKFs2JFlR5YdWXbkkYNWBtiGtqEvGDk4oWygDXUDb5ANO7LuyLoj645sO7LtyLYj245sO7LtyLYj245sO7LtyG1Hbjty25Hbjtx25LYjtx257chtR247ct+R+47cd+S+I/cdue/IfUfuO3LfkfuKXK7rCipBFFSDOEiCNMiCWlBolNAooVFCo4RGCY2RkyZOGmRBQ6M59U0jMReVIAqqQRwkQRpkQaFBoVFDo4ZGDY0aGjU0amjU0KihUUOjhgaHBocGhwaHBocGhwaHBocGhwaHhoSGhIaEhoSGhIaEhoSGhIaEhoSGhoaGhoaGhoaGhoaGhoaGhoaGhoaFhoWGhYaFhoWGhYaFhoWGhYaFRguNFhotNFpotNBoodFCo4VGC40WGj00emj00Oih0UOjh0YPjR4aPTT61ijXFVSCKKgGcZAEaZAFtaDQKKFRQqOERgmNEholNEpolNCIPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ABwKCxkAHAoKCwAcCgIKAC0IAQInAhoEDAAIARoBJwMCBAEAIgICGi0KGhstDgQbACIbAhstDggbACIbAhstDh4bACIbAhstDgkbACIbAhstDhQbACIbAhstDhUbACIbAhstDhYbACIbAhstDhgbACIbAhstDhkbACIbAhstDgsbACIbAhstDgobHAoXBAAcCg8IABwKEAkAHAoRCgAcChILABwKEw8AHAoNEAAcCgwNAC0IAQwnAhEEDAAIAREBJwMMBAEAIgwCES0KERItDgUSACISAhItDgQSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgsSACISAhItDg8SACISAhItDhASACISAhItDg0SACISAhItDgMSLgiARQAqIwAAC8MNIgAqgEwAAyQCAAMAAA75IwAAC9gtCwcDLQsDBAAiBAIELQ4EAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHKwIABQAAAAAAAAAAFwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEYACQAiCQIJLgyARgAJACIJAgkuDIBGAAkAIgkCCS0OBQktCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEUABy0IAQgAAAECAS4MgEQACC0LAwkAIgkCCS0OCQMuCIBFAAIjAAAMxw0iAAKATQAJJAIACQAADq8jAAAM3CcCCgQLLQgACy0KBQwtCgQNLQoHDi0KCA8ACAAKACUAABcoLQIAAC0KDAktCAEEJwIFBBkACAEFAScDBAQBACIEAgUnAgcEGAAqBwUHLQoFCAwqCAcKFgoKCiQCAAoAAA1OLgyARgAIACIIAggjAAANLS0IAQUAAAECAS0OBAUuCIBFAAIjAAANZg0iAAKATQAEJAIABAAADmIjAAANey0LBQMnAgQEGC4CAAOAAygAgAQEABklAAAXnC4IgAUABwAqBwQILQ4JCC0OBwUuCIBFAAIjAAANtAwqAgQDJAIAAwAADjMjAAANxikCAAIALRfGuCcCBAQCJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIF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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3fju24kWf9LnXdF+K/CNKvMhg03D2egQHDbrjdH/Ch0e8+W0FFLGae3kzl3llz41quOieWtiT+JJEU9Z+//a8//ct//J9//vNf//ff/v23P/yP//ztX/7+57/85c//55//8rd//eM//vy3vz7+7X/+dpz/k3L97Q/lnx7/bL/9oZ3/lN/+oOc/9bc/jPOf/bc/pHTCeMD5J8vhkByyQ3GoDs1BHNShO3jl6pWrV65euXrl6pWrV65euXrl6pWrV25euXnl5pWbV25euXnl5pWbV25euXll8crilcUri1cWryxeWbyyeGXxyuKV1SurV1avrF5ZvbJ6ZfXK6pXVK6tX7l65e+XulbtX7l65e+XulbtX7l65e+XhlcdZ+TyPRnYoDtWhOYiDOnSHMSEfh0NyyA5n5X5CdWgO4qAO3eFROT9O7JwelXM7ITlkh+JQHZrDo3IeJ6hDdxgX5EflcpyQHLLDWbmcUB2aw6NyORVnE5zQHcYFZxuckByyQ3GoDs3BKxevXLxy8crVK1evXL1y9crVK1evXL1y9crVK1ev3Lxy88rNKzevfLbBch7Tsw1OEAd16A7jgrMNTkgO2aE4eGXxyuKVxSuLVxavrF5ZvbJ6ZfXK6pXVK6tXVq+sXlm9cvfK3St3r9y9cvfK3St3r9y9cvfK3SsPrzy88vDKwysPrzy88vDKwysPrzyuyuU4HJJDdigO1aE5iIM6dAevnLxy8srJKyevfLbBepzQHMRBHbrDuOBsgxOSQ3YoDl45e+XslbNXPttgbSeMC842OCE5ZIfiUB2agziog1cuXrl65eqVzzZY+wnFoTo0B3FQh+4wLjjb4ITk4JWbV25euXnlsw22fII6dIdxwdkGJySH7FAcqkNz8MrilcUri1dWr6xeWb2yemX1yuqV1SurV1avrF65e+XulbtX7l65e+XulbtX7l65e+XulYdXHl55eOXhlYdXHl55eOXhlYdXHlflehwOySE7FIfq0BzEQR26g1dOXjl55eSVk1dOXjl55eSVk1dOXjl55eyVs1fOXjl75eyVs1fOXjl75eyVs1cuXrl45eKVi1cuXrl45eKVi1cuXrl45eqVq1euXrl65eqVq1euXrl65eqVq1duXrl55eaVm1duXrl5ZW+D1dtg9TZYrQ3WB1gbNEgO2aE4VIfmIA7q0B28snpl9crqldUrq1dWr6xeWb2yemX1yt0rd6/cvXL3yt0rd6/cvXL3yt0rd688vPLwysMrD688vPLwysMrD688vPK4KrfjcEgO2aE4VIfmIA7q0B28cvLKySsnr5y8cvLKySsnr5y8cvLKyStnr5y9cvbK2Stnr5y9cvbK2Stnr5y9cvHKxSsXr1y8cvHKxSsXr1y8cvHKxStXr1y9cvXK1StXr1y9cvXK1StXr1y9cvPKzSs3r9y8cvPKzSs3r9y8cvPK3gabt8HmbbB5G2zeBpu3weZtsHkbbN4Gm7fB5m2weRts3gabt8HmbbB5G2zeBpu3weZtsHkbbN4Gm7fB5m2weRts3gabt8HmbbBZG+wnqEN3GBdYGzRIDtmhOFSH5uCVh1ceXnlcleVsg9JOSA7ZoThUh+YgDurQHcYFySsnr5y8cvLKySsnr5y8cvLKySsnr5y9cvbKZxsUPaE4VIfmIA7q0B3GBWcbnJAcvHLxysUrF698tkE5d+bZBid0h3HB2QYnJIfsUByqQ3PwytUrV69cvfLZBjWdkByyw6OylhOqQ3MQB3XoDuOCsw1OSA7ZwSuLVxavLF75bIMqJ3SHccHZBickh+xQHKpDcxAHr6xeWb1y98pnG9Tz6JxtcEJxqA7NQRzUoTuMC842OMErD688vPLwysMrD688vPLwyuOqrMfhkByyQ3GoDs1BHNShO3jl5JWTV05eOXnl5JWTV05eOXnl5JWTV85eOXvl7JWzV85eOXvl7JWzV85eOXvl4pWLVy5euXjl4pWLVy5euXjl4pWLV65euXrl6pWrV65euXrl6pWrV65euXrl5pWbV25euXnl5pWbV25euXnl5pWbVxavLF5ZvLJ4ZfHK4pXFK4tXFq8sXlm9snpl9crqldUrWxscJ4iDOnSHcYG1QYPkkB2KQ3Xwyt0rd6/cvXL3ysMrD688vPLwysMrD688vPLwysMrj6tyPw6H5JAdikN1aA7ioA7dwSsnr5y8cvLKySsnr5y8cvLKySsnr5y8cvbK2Stnr5y9cvbK2Stnr5y9cvbK2SsXr1y8cvHKxSsXr1y8cvHKxSsXr1y8cvXK1StXr1y9cvXK1StXr1y9cvXK1Ss3r9y8cvPKzSs3r9y8cvPKzSs3r9y8snhl8crilcUri1cWryxeWbyyeGXxyuqV1SurV1avrF7Z22D3Nti9DXZvg93bYPc22L0Ndm+D3dtg9zbYvQ12b4Pd22D3Nti9DXZvg93bYPc22L0Ndm+D3dtg9zbYvQ12b4Pd2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OM422PMJ2aE4VIfmIA7q0B3GBWcbnOCVm1duXrl55bMN9nKCOKhDdxgXnG1wQnLIDsWhOnhl8crilcUri1dWr6xeWb2yemX1yuqV1SurV1avrF65e+XulbtX7l65e+XulbtX7l65e+XulYdXHl55eOXhlYdXHl55eOXhlYdXHlfldBxHUArKQSWoBrUgCdKgHhSOFI4UjhSOFI6zSXY1akESdA6tH0Y9aDidDfOiFJSDSlANakESFI4cjhyOEo4SjhKOEo4SjhKOEo4SjhKOEo4ajhqOGo4ajhqOGo4ajhqOGo4ajhaOFo4WjhaOFo4WjhaOFo4WjhYOCYeEQ8Ih4ZBwSDgkHBIOCYeEQ8Oh4dBwaDg0HBoODYeGQ8Oh4ejh6OHo4ejh6OHo4ejh6OHo4ejhGOEY4RjhGOEY4RjhGOEY4RjhGO5IxxGUgnJQCapBLUiCNKgHhSOFI4UjhSOFI4UjhSOFI9p5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5zaDaGSjHFSCalALkiAN6kHDydr5pHCMcIxwjHCMcIxwjHCMcAx32KSii1JQDipBNagFSZAG9aBwpHCkcKRwpHCkcKRwpHCkcKRwpHDkcORw5HDkcORw5HDkcORw5HDkcJRwlHCUcJRwlHCUcJRwlHCUcJRw1HDUcNRw1HDUcNRw1HDUcNRw1HC0cLRwtHC0cLRwtHC0cLRwtHC0cEg4JBwSDgmHhEPCIeGQcEg4JBwaDg2HtfNiVIJqUAuSIA3qQcPJ2vmkFBSOHo4ejh6OHo4ejh6OHo4RjhGOEY4RjhGOEY4RjhGOEY7hDpu4dFEKykElqAa1IAnSoB4UjhSOFI4UjhSOFI4UjhSOFI4UjhSOHI4cjhyOHI4cjhyOHI4cjhyOHI4SjhKOEo4SjhKOEo4SjhKOEo4SjhqOGo4ajhqOGo4ajhoOa+dq1IOGk027Pw7DBGawgBVsoIAKdnAECjbBJtgEm2ATbIJNsAk2wabYFJtiU2yKTbEpNsWm2BRbx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sI2w2ncoxgRksYAUbKKCCHcSWsCVsCVvClrAlbAlbwpawJWwZW8aWsWVsGVvGlrFlbBlbxlawFWwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvFRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0skTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCzRmSXFsIINFFDBDo7AmSUTE5hBbA1bw9awzSyphh0cgTNLJiYwgwWsYAMFxCbYBJtiU2yKTbEpNsWm2BSbYlNsHVvH1rF1bB1bx9axdWwdW8c2sA1sA9vANrANbAPbwDawjbD14wATmMECVrCBAirYQWwJW8KWsCVsCVvClrAlbDNLuuEInFky8bSlwzCDBaxgAwVUsIMj0LLkQmwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWwD28A2sA1sA9vANrANbAPbCJtNN3RMYAYLWMEGCqhgB7ElbAlbwpawJWwJW8KWsCVsCVvGRpYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEtGZEk+IkvyEVmSj8iSfESW5COyJB+RJfmILMlHZEk+IkvycWBL2BK2hC1hS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYyvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2BSbYlNsik2xKTbFptgUm2Lr2Dq2jq1j69g6to6tY+vYOraZJcUwgRksYAUbKKCCHRyO6ThAe+oYhhksYAUbKKCCHRyB8xlnIraELWFL2BK2hC1hS9gStowtY8vYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2FjabuDYXwpqJWQ3tPBRDBTs4Amc2TkxgBgtYwQZiq9gqtoqtYWvYGraGrWFr2Bq2hq1ha9gEm2ATbIJNsAk2wSbYBJtgU2yKTbEpNsWm2BSbYlNsiq1j69g6to6tY+vYOraOrWOb2Win2czGiQnMYAEreNrm6WnZeKGCHTxt+Tx/bZab42nLapjBAlawgQIq2MERaNl4IbaELWFL2CwbczcUUMEOjkDLxgtPmy1wZ3PfHAt42koxbKCACnZwBM7lJ2175wKUEzNYQLPZls2FKCdK4FxxMhlasWF4/rU6/+3516odNwuFCxXs4Ai0ULjwrFvNZqFwYQEraDbbBguFC0/budJPtolujiPQQuHCBGbwtDUxrGADBTSb7T4LhQvNZhtpoXBhAjN42sTEFgoXNlBABTt42sQ2x0LhwgRm0Gy2kRYKFzbQbHb2WShc2AOtzV9oxexXzEUp7SSwJn3923PL9NzIOleknJjADBbw3LJzeYdss9ocBVSwgyPQmnQ/DBOYwQKetp4MGyjgaeu2ZdakLxyB1qR7NTTbXAjSbGpYwAo2UEAFT9uYihFoTfrCBGawgBVsoIAKYivYKraKzdr8sF9sbf5CARXs4Ai0BjnmapgHaAo7hMKmC5subLo1kWE7yprIhQp2cARaE7kwgRksYAWxdWwdW8fWsQ1sA5tdIUc3tArD8FHh8UhuOBxtvpdjAjNYwAo2UEAFO4gtYUvYEraELWFL2BK2hC1hS9gytowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9gqtoqtYqvYKraKrWFr2Bq2hq1ha9gatoatYWvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2MiSRpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0meDLIYVbKBtTjNUsIMjcDbIiQnMYAEr2EBsim02yGE4AmeDnJjADBbwtNlgn02achRQwdNm4zg2aepCa5AXnrZkW2YN8sICmk0MGyiggmY7eyVselS2r73Y9CjHAlbwrJsPw7OufRvGpkflnA07OAKt6V142qzn36ZHORawgmZrhqaw7bX2Zj3pNicqW5+5zYnK1vltc6IcM1jACjZQwNNWqmEHzWZia28XJjCDBazgaau2H6y9XahgB09btc2x9nZhAk+bdZ/bnCjHCppNDM1m22DX7gs7OALt2n1hAs02DAtYwQYKqGAHR6Bduy9MIDbBJtgEm2CzqGh2TlpUXDgCLSrsIzo2J8oxgwWsYANPW7P9a1FxYQdHoEXFhQnMYAEr2EBsHVvH1rFZKDTbSAuFCyvYQAEV7OC4sNjsJ8cEZrCAFWyggAp2EFvClrAlbAlbwpawJWwJW8KWsGVsGVvGlrFlbBlbxpaxZWwZW8FWsBVsBVvBVrAVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rAJNsEm2ASbYBNsgk2wCTbBptgUm2JTbIpNsSk2xabYFFvH1rF1bB1bx9axdWwdW8fWsQ1sA9vANrANbAPbwDawDWxkSSJLElmSyJI0s0QMK9hAARXsgTNAsmECM1jACjZQQAU7OAIztowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9gqtoqtYqvYKraKrWFr2Bq2hq1ha9gatoatYWvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2EbZ8HGACM1jACjZQQAU7iI0syWRJJkuub18Owwo28LSd0ybK/AbmhR0cgZYlFybwtInZLEsurOBpk2QooIIdHIGWJRearRlmsIAVbKCACnZwBFqWXIitYqvYKjbLEqmGAirYwRFoWXKh2dQwgwU0WzdsoIAaaKkhdmAtH9SOkOXDhQ08K6gdIcuHCzt4bu/5LZViUwgdE5hBs9kPsny4sIECWl3bfdbmz6kxxaYFOlbQfrEprM1fqGAHR6C1+QsTmEGz2f61Nn9hAwVUsIPD0aYFOiYwgwWsYAMFVLCDZjuPsU0AdCxgBRsooIIdpK617gsTiC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKr2Cq2iq1iq9gqtoatYWvYGraGrWFr2Bq2hq1hE2yCTbAJNsEm2ASbYBNsgk2xKTbFptgUm2JTbIpNsSm2jq1j69g6to6tY+vYOraOrWMb2Aa2gW1gG9gGtoFtYBvYRtjqcYAJzGABK9hAARXsILaELWEjSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0smROxjxnMZc5GfPCBgqoYAdHoGXJhQnMILaMLWPL2DK2jC1jK9gKtoJtBsgwbKCACnZwBM4AmZjADBYQW8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWwD28A2sA1sA9vANrANbAPbCNucgXlhAjNYwAo2UEAFO4gtYUvYEraELWFL2BK2hC1hS9gytowtY8vYMraMLWPL2DK2jK1gK9gKtoKNLBGyRMgSIUuELJkzMM93QMqcgXm+4lHmDMwLM1jACjZQQAU7OAIbtoatYWvYGraGzbLkfA+lzBmYF3ZwBFqWXJhAs2XD0zYmVrCBAirYwRFoWXJhAjOITbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1js9Q4F3Uuc1ZlF8MKWgU1FFDBDg7HOavywsf2lnOWTLFZlY4FrGA7MRsKqGA/sRiOwDMfHM1WDTNYwAqarRlaXTEcgfkAE2h1u6HVHYZn3fMF/GLzJx/dLobnr0i2ZWcSlGTiMwkcR+CZBI6nLdmWnUngWMAKms12dTGFbc7Z/Eu2zTmbf8m2f8/mX7Jtztn8Hz0whhksYAUbKKCCZrNtqCPQ2rydXHOm5IUFrGADBVSwgyNQDhCbYBP7QbZLpIINPH9QsR11tnnHDo7As807JjCDBaxgA7EpNjWbba+OwH6ACcxgAc1me703UEAFzWbnbx+B4wBPW7UtG5Ewc6bkhRVsoIAKdjDybM6UvDCBGSxgBRsooIIdxJawJWwJW8KWsCVsCVvClrAlbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawFWwFmwXI+Q50sZmSjudZUu0PWIBcmMAMnudkbYYVbKCACnZwBLYDNJsYZtCuWWpod0HzzypodecfGIFygAnMYAEraL9iGAqo4Glrh+EItNS40GzdMIMFjKGMOZ3zQgEV7OAInE8dExOYwQLaEIlt+hwimWi/wo685cNEy4cLE5jBAlbw3GetGAqooNmq4XC01e4czZYNM1jAGK6a0zkvFFDBDo7A+XwxMYEZLKD9imaoYAdHoN0/2CwOm8PpmMEC1usF2jLXtbtQQAU7OALnC9UTE5jBs26ZeP4KG4+12ZqOHRyB1uYvTOD5K2xI0mZrOlawgWazXWJt/sIOms32g7X5CxNotm5oNvsV5/1DOd/WLzZb01FABTs4Ai0JbPjSZms6ZrCAFWyggAp2cAQqNsWm2BSbYrP7BxsLtdmajgqazfaO3T9MtPuHCxOYwQKeNntKstmajgIqeNrOT94Wm615oeXDhafNnr5sDucjRgwLWMEGCqhgB8eF1eZwOpptGGbwtJ1fSqs2h9OxgQKetvN2sdocTscRaM8XFyYwgwWsoNmqoYBma4YdHIGWGhcm8KGwZZGqTdws5+oC1SZuOgqoYAdNYXvHHjUuTGAGC1jBh60e9tvOAHFUsIPjRNveM0AcE5hPtN92BohjBc2mhmazw13NZptTOzgC2wEmMIN2STKSIA3qQcPJUsLobMH1fLSrNnPSMYMFrGADBVSwgyOwY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2ETabOemYwAwWsIINFFDBDmJL2BK2hC1hS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYyvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2MiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSZ0NvRpWsIHWrWWkQT1oOFlX5KQUlINKUA1qQeGo4ajhqOFo4WjhaOFo4ZjNWgwbKKDtwm7YwXMXnqOx1WZPOiYwgwWsYAMFVLCD2BSbYlNs1qyzHTBr1hc2UEAFO2i2s/vHZk86JtB6YYxKUA1qQRKkTtZ0s50u1kjPdRSqzYWs2fa3NdILBVTQttSOgjVSQ5sL6ZjADFrHpVENMtcwFFDB03WuMVxtJuSF1kQvPF3n4G21mZCO5y87V2eoNhPSsYGnrRlpUA8aTtY8J6Ugqzjx/MtFDG1L1XAE2sX7wgTaltoPtDZ9YQUbKOBps/1m1+5Jw8mu3FbeLtyTclAJqkEt6JTY+WEzGx17oF2dLzz/frWdbw32wrOC7Qhrr5N60LmV1Q6NtdYLE3hu6Ny91lovNJVVsNZ6oW2sbbe11vnzrbVW20/WWs9BrWpTFR0TmMECVrCBAtqpYttrrbXZqWSttdn2WrtstpHWMJttpLXMCxsooIIdHIHWUJv9TGuoFzZQQAU7OBxt8mA930KsNnnQUcEOnn/tHKiqNnmwnu8FVps8aL/d5g5eVIJqUAuSIA3qQcPpbG4XhSOHI4cjhyOHI4cjhyOHI4ejhKOEo4SjhKOEw1rb+VJltTmAdjLYFMCLUlAOKkE1qAVJkAb1oHC0cLRwtHC0cLRwtHC0cLRwtHC0cEg4JBwSDmtrYnvB2tqFHbQzxE4Wa2vnQGS1qXxV7byxVqV23lhLOV9crDYRr6r9WbuuXZhByys7Ya39XNhAARXs4Ai0a96FZhPDDBbwtHX7bdaUum2ONaULLXHPP2vT8xwTmMHif82m5zk2UEAFOzgC7VJ34XmAulEJqkEtSII0yIqr4Qi0C92FBbTNs79mlzobFLR5d44j0C51FyYwgwU8d4aNGtq8O0cBT9tIhh0cgXa1s/FBm4LnmMECVrCBAirYwRHYsDVsDVvD1rA1bA2bXSBtENNm4zmOQLsY2nClTbarNu5o0+outJY27AhZSxt2hOyqdmEBrYLtdbuqXXieGDbCaJPimg0V2uS1dphiJDCDBTxPNxtWtMlrjgIq2MHhaNPUmo1G2jQ1xwpa3WEooIIdHIHpABOYwfPPnnNMq00yc0xgBgtYwXPLUjIUUMEOjkC79FxotmyYwQJW0GzF0OpWQ6t7HjebTuaYwAwWsIINtF8hhgp20Gx23OyqdGEC7Zphe2demCZWsIECKtjBETivT7bP5gXK9oNYBdsPomAHR6DaltnP1AJWsIECKtjBEdhty2zvWBu6MIMFrKApbJ91DbSmZw9KNter2eOPzepqxfaDNRx75rFZXY4P8bleQbVJXReVoBrUgiRIg3rQcLJWVLJhAjNYwAo2UEAFe6C1OHtgs2lbzR7NbNrWOUWp2qytizSoBw2ns1ldZBWbYQYLWMEGCmi7+TxQNjWr2QObTc1yPCvYH7XmM0mCNKgHDSdrOfYsZ5OyHDNYwAo20G5ozxPCJlo1e/iyiVY6qQTVoMdf1/lXJEiDetBwOq8vF5nEDpE1owsLKKDdYtsxtKZxYQLPU9R+xtkyLqpBLUiCNMh+uO3FPgKt1VyYwAwWsIINFFBBbMNtzWZLtfPBs9lsKccMmm0YVtDOk8PQTpRkaGdKMezgCLQG2ExsDfDC03Y+YjabLdWaic8GqPNvtSAJ0qAeNJzsYnfeGjabBtWabbRd1sS21C5rF3bw3NLzoajZNCjHBGawgFbXxNbUzqeIZlObmtgPtAvYhRksYAUbKKCCHTSb7Thrhhcm0Gy2O60ZXljBBprN9pldwC7s4Ll7rex5/booBZ3t1bbK2uukGtSCJEiDTGLHyK5xE/UAE1jBczPVTkK7ml14VlA7ntZkL0zguaVW4GyyF9WgFiRBGtSDhtPZYC9KQeEY4RjhGOEY4RjhGOEY7rApUReloBxUgmrQeWTPSaLNZkM5Kmi7rBqOQGuhF9ouE8MMnufRVNgl8sIGCqjgaTtfe242G+pCu1U9Xz9sNhuqddsya73nfNFms6EcK2gPg7aR1qYvVPBhu2oNp7NFX5SCclAJsorN0LbUfra15vMBstncJscMFtC21H62teYLBVSwg+em2u+zxjxst1hjHvPfZvCUDdvGs9le//Kc733Y77dPvR1W1T71dmEFz+06H6aazUtyVLCDI9Ca5IUJzGABK4hNsSk2xWbNd9hGWvO9MIEZLGAFJfaDfbzqwg7ajjKbfbzqwgSeF/XDztCz+TpWsIECKnje0h12Pp2NeKJNRpLzdcZmk5EcM2gzeQ/DCjZQQAU7OALj49otx8e1W46Pa7ecsCVsCVvClrAlbAlbxpaxZWwZW7Y9WQwbKKDtyWrYwRFot8cX2p5shrYnxdBsVmx+XHtiA82mhgp2cATWA0xgBgtYwQZiq9gqtvkBWTtL5gdkJyYwgwWsYAMFVLCD2ASb2G/rhhksYAUbKKCCHRyBeoBmG4YZLKCAZ4VkTeQMBZnbe4aCYwYLeG7vPNx2J36hgAp2cASOA0xgBguIbWAb2Aa2gW2EzSYYydkT0myCkaPZxLCAFTSbGgqoYAdHYDrABGbQbN2wgg0U8LSdvRvNJhg5jsAzHxwTeNrOrodmE4wcK9hAARU02zAcgZYPFybwtBUTn/ngWMHTdj7IN5tgJMUUlg8XdnAEWj5cmMAMFrCCDcRWsVVsFVvD1rA1bA1bw9awNWwNW8PWsAk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTbFptgUW8fWsXVsHVvH1rF1bB1bx9axDWwD28A2sA1sA9vANrANbCNsNsHIMYFmE8MCmk0NGyiggqft7K1pNsHoQsuSCxOYwQJWsIGn7ez6aTbByNEuHWfjtVlFjgk0RTEsoCnsF1uAXCigKezHW4BcOAItQKwHxBaCc8xgASvYQAEV7OAIrNjOqLD7eZupdFELOu/255/ToB5kFc88tqlKjgnMYAEraNtve9ZC4kIF7Tbajth83jC0m4gLE5jBAlawgQIqiE2wKTbFptgUm2JTbIpNsSk2xWYh0SYmMIPFn9bqfAqZaM888w8IqGD3Zzhb7O1CC4lznLrZYm+OZrMzwELiwgrab5sooIIdHI42wcnR6lbD88hb15xNWxLrmrNpS44j0Br+hba93TCDBaxgA0+bdaTZvCXHDo5Ay4ALE3jarMPLFnBzrGADzaaGCnbQbOe5bhOdxDpLbKKTYwYLWMEGCqhgB0dgxVaxVWwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtgE2yCTbAJNsEm2ASbYBNsik2xKTbFptgUm2JTbIpNsXVsHVvH1rF1bB1bx9axdWwdm+WDdXLbWm6OZrPGa/lwYQUbaDY71+0m4sIODkdby80xgRksoNm6YQNNMQw7OAItQC48FdYxaJOwHAtYweYZZROxHBXs4Ai0ALkwgRksoFz9cTb56qIedPbW2Q+3jsVJKci2PxkWsIINFFDB01SNhtMZERfZrsqGGSzgefNge8puHiZJkAb1oOF0ZsNFKSgHlaBwtHC0cLRwtHC0cEg4JBwSDgmHhMPCYO57C4MLFbRhVDt0FgYTLQzmQbEwuDCDttPsZLUwuLCBAirYwRFoYXCh2ezEtjC4sIAVtHFCO+5zoHCigh0cgRYGw463hcGFGTz346Qa1IIkSIN60LjIpoRdlIJyUAmqQS1IgjSoB4UjhSOFw0LA7nttSpicE4WazQlzbKCACnZwBFoIXJjADGLL2DK2jM3uIuz22+aQOY5Au4u4MIEZPEdvrC/T5pA5NlBABTs4AusBJjCD2Cq2iq1iq9gqtoqtYWvYGraGrWFr2Bq2hs0GGK1Pd84WS0YtyP7SMFSwgyNwjvtPTKDNLrBTSwtYwQaeNuuKs4XZHDt42pJt7dn+HRNoNjtdbMjxwgo20Gx2YtgQo3Wv2Sw2xwRm8KxrfWo2i02z7SgbaMzWmGykMdv22lCj9Z7ZLDbNJrbBRkNbgs0xgaftnNnTbG6bYwUbaLZhaOPzydAG6M/NsQltes6TaTahTa17wia06fkaRbN11xwr2EABFeyg2Wwb8gGeCjuNbB6cYwVPRbWNPJu5o4IdHIFnM3dMYAYLWEFsBZs1c+upsNlxjiPQmvmFCcyg2ewXWzO/sIEC2kD8YdjBEWjN3J5EO82808w7zbzTzDvNvNPMO83cZsc5Rqh0OUBsgk2wCTbBJtgEm2ATbIpNsSk2xabYFJtiU2yKTbF1bB1bx9axdWwdW8fWsXVsHdvANrANbAPbwDawWWpYF4MtzOZoZ8n8A8PRpvA5JtDmhahhASvYQAEV7OAItACxHgSby+dol9VhaHUnCqhgB21qy3mu28JsjgnMYPFJAXOG34UNFFDBDsa0Apvm53juHZuHZDP6HBsooII90JLAukRsRp/alCSb0qc2Jcnm9DkqaBWa4Qi0Nm99JjavzzGDtr12LKzNX9hAARXs4AicM4rsEM4pRRMzWMAKNlB8BtCc9Df3g7XuC9k71rqtj8em/TlWsIECnr9iKqx1XzgCrXVfeNrskd2mCDoW8LTZE7nNEnQU0Gx2LKx1XzgCrXXblCabKKg2P8cmCqo9kdtEQbXHcJso6NhAq2u/zdrxiWJTAh0TeNY9n73FJv/ZySU2+c9RwR5ozfTCck2TE5vb59hAuSbPiU3vc+zgCLSZQxcmMIMFrOC5kecDtti8P8cRaJfxC88ffz5Ni837cyxgBX2WoczZgBcq2MERaLOKLkxgBgvos1Jlzga80H7FxBFojffCBNqvsP1gjffCCjZQQAVtDunEESgHmMAMFrCCDRRQA63xnk/xYhMAHTNYQPsVYthAARW0X2HHeM7vNZzzeycmMIMFrGAD7Vio4Qi0ZnphAu1XdMMCVrCBAirYweE4JwqenQoyZwpemMEC2mTBw7CBAipoU9zVcATOCfUTE5jBAlawgQJa3fNMtXmBevZxiM0LdMygzXjMhvYrmmEDBVSwgyPQ2vyFCTSbGFpd20hrx+ekfrF5gDpsr9uN94UFrKBVsL1uF+ELFezgCLR2fGECc2zDnFw/sYINFFBBfoW144nWji88p0MeduTPFtsP2+tni3UUUMGz0/Kww3JehC8827Hj2UN62DE+27FjASvYQAEVNJttr47AfoBms6PZM1jACjZQQAXNZudDH4HjAM1mZ8nIYAEr2EABFTSbnTtjONoEQsfTdk6nE5tA2M8ZT2ITCPvZbSE2gbCfHRRiEwgdBVTwtJ39D2ITCPvZ/yA2gbAns6UEZrCApy3b5pytu5/9D2ITCHu2LTuv6I4dHIHZftswTGAGC2jnutnsxvtCARXs4Ai0G+8LE5hB+xW2J4uACnbQfoXtSeuivzCBGSxgBRsooAY2q9sME5hBq2uHsFWwgQJqoFhdO9zW5rMdTWvzFzZQQAX79eKmzFXHJsbrnDJXHbswgwWsYAMFtP1rR95a94UJzOD5K+YhtBZb7ES0FjvRWuyFZ4ViZ5+12AsLaENAdoytbRbb1dY2i+0+a5u2H2zynmMCM1jAClpdNezgCLRWeGG6Xl2WuQ7YhQWsYAMFVLCDI9BW6Tln5Mhc8evCCp7nw9mVJmUOkE08f4XdBdmEPMcRaINkZ+eW2IQ8xwyee8fu+2xCnmMDBVTQbLZ35jiZ4Rwom5jADBawgg20urZL5joh9iusZVX7xdayLhTw3LJmO+q8xjqeW9asgrW3CxN4blmz/WCt8MIKNlBABTtotvOktel0jgnMYAEr2OIX2zW22a62VjjRWuGFCbS6zbCAFWzgeU5aG5orc13YwRFoSx1cmMAMFtD2zkQFOzgcbYpcP3uTxKbIOWawgGcLsKSda3BdKKCCHRyBttjIhSnQZqRnu12xGWPBunBfeMDnWR6cFs4Ll4Xrwou3Lt66eOvibfPf275ofeEBy7FwWjgvXBauC7eFZeHFK4tXFq8uXl28unh18eri1cWri1cXry5eXbx98fbF2xdvX7x98fbF2xdvX7x98fbFOxbvWLxj8Y7FOxbvWLxj8Y7FOxbvwDtnizmnhfPCZeG6cFtYFtaF+8KLNy3etHjT4k2LNy3etHjT4k2LNy1eu4jYU59NyHJMYAYLWMEGCqhgB7E1bA1bw9awNWwNW8PWsDVsdhmyh1ubkOWYwAwWsIINFFDBDmJTbIpNsSk2xabYFJtiU2yKrWPr2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGthE2m5DlmMAMFrCCDRRQwQ5iS9gStoQtYUvYEraELWFL2BK2jC1jy9gytowtY8vYMraMLWMr2Aq2gq1gK9gKtoKtYCvYCraKrWKr2Cq2iq1iq9gqtoqtYmvYGraGrWFr2Bq2hq1ha9jIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCzRmSVqaLM0D8MOjsA5GXRiAjNYwAo2UEBsDVvDJtgEm2ATbIJNzJYMBVSwgyNQD9BsxTCDBTSb7TNtoIAKdnAE9gM02zA8bdaPa3PDHCvYQAEV7OAIPLPEMYHYBraBbWAb2Aa2gW2EzWaMOSYwgwWsYAMFVLCD2BK2hC1hS9gStoQtYUvYEraELWPL2DK2jC1jy9gytowtY8vYCraCrWAr2Aq2gq1gK9gKtoKtYqvYKraKrWKr2Cq2iq1iq9gatoatYWvYGraGrWFr2Bq2hk2wCTbBJtgEm2ATbIJNsAk2xabYFJtiU2yKTbEpNsWm2Dq2jo0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkjGzJBtWsIECKthBs533nmNmyUSzDcMMFrCCDRRQwQ6OC/WYWdINE5jBAlawgQLaGyzJsIMjcL7EMjGBGSygvSxTDRso4Gk7BzLVpsA5jkDLkmw/07LkwgyetnP0Um0KnGMD7e51/lmziWEHR6BlyYUJzGABK2g2U1iWXKhgB0egZcmFCczgaav2KyxLLmzgaau2DZYlF3bwtJ0jZmrT5RwTmMECVrCBAp62ZofQsuTCEWhZcmECM1jACprNNt2y5EIFOzgCLUsuTGAGC1hBbIrNsqRZY7AsuXAEWpZcmMAMFrCC9kQ1UUAFOzgCLUsuTGAGC1hBbAPbwDawjbDZ1DrHBGawgBVsoIAKdhBbwpawJWwJW8KWsCVsCVvClrBlbBlbxpaxZWwZW8aWsWVsGVvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBVbxVaxVWwVW8PWsDVsDVvD1rA1bA1bw9awCTbBJtgEm2ATbIJNsAk2wabYFJtiU2yKTbEpNsWm2BRbx9axdWwdW8dGliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLJkkyWZLIkkyWZLMlkiU3kG+d7H2oT+Rw7eNrOWe9qE/kcE3jaznc51CbyOVbwtJ1vg6hN5HNU0Gy2OZYlEy1LLjxt5wsRahP5HAtotmHYQAFP2/nGhNpEPscRyH1J5r4kc1+S532JFZv3JRMbaHcKxVDBDp42u2mw6X2OCbTfpoYFrOBpU7PNFXwmKnjauh03y5KJliUXnrZum2NZcmEB7ZQznKFge2eGwsQMFrCCDRRQwQ6OQMWm2BSbYlNsik2xKTbFptg6to6tY+vYOraOrWPr2Dq2jm1gG9gGtoFtYBvYBraBbWAbYSvHASYwgwWsYAMFVLCD2BK2hC1hS9gStoQtYUvYEraELWPL2DK2jC1jy9gytowtY8vYCraCrWAr2Aq2gq1gK9gKtoKtYqvYKraKrWKr2Cq2iq1iq9gatoatYWvYGraGzW4wzhd61OYrjvONFLX5io4j0LLkwgRmsIAVbKCA2ASbYFNsliXnnFS1+YqOBaxgAwU0WzPs4AjsPrqjZUbFxAYKqGAHz2LnCzJqkxQdE3hu+vnKitokRccKnrZhh8Wi4kIFOzgcbeqiYwIzWMAK+siV1kNABc1WDEegRcWFCcxgASvYQPttYqhgB0egRcWFCcxgAWugNelhv8Ka9IUN9D4xrdGXqTX6MrVGX6bW6MvUGn2ZWqMvU2v0ZWqNvkyt0ZeptWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2ASbYJO4G7Q5mo4VjLtBm6DpqKAdzW44Aq1JX5jADBawgg0020QFO2i28z7KpmQ6JjCDBaxgAwVUWwTQWs5cPvziAc8FxC9OC+eFy8J14bawGNuOnMv2XdwXHsHXyn0Xp4XzwmXhurDdjR6GAipo+3YYjsD5FDFxGsU4L1wWrgu3hWVhXbgvHPf3tuSfYwKnVI3LwnXhtrAsrAv3hQdcbPday7C1/4LzwmXhunBbWBbWhfvC5k32u+qsU4zbwrKwLtwXHnA7Fk4L54Wjw9YmlDo2cEqrsS7cFx7wXAX04rRwXrgsPH+s7fC5FOjFsrAu3Bce8FwP9OK0cF54eu3snWuCXtwWloXNm+0AzXVBLx6wzf92TgvnhcvCdeG2cHSM23RTxw5O6XnD0GbgXJwWzguXhevCbWFZeP5YOygzcC4ewTID5+K0cF64LFwXbgvP+ucJJjMuzrfPVGZcXNwWloV14b7wgPOxcFr4vAbY87zNI3Ws4JR2Y1lYF+4LD3jGxcVp4byw/djzxTOVGRcXt4VlYV24LzxgewPEOS1sXhvksZmlwXXhtvD02gGa8XJxX3jAM14uTgvnhcvCdWEbo7Hj3wRUcEqb8YBnvFycFs4Ll4Xrwm3h+WPtoMx4ubgvPOAZLxenhfPCZeG6sNU/35xTmTFy8YBnjFycFs4LW/1qB3fGyMX2u8436FSu755Mnl47uNeXTyZPrx2ImSQXT6/tn5kkF0+vHZeZJBdPr7WsmSQXT6/99pkkF0/vmWY6k+Ri855vyanOJLnYvOfLcaozSS42rw202ezTYPOeb6+pzoS52Lw2gGYzUIOntxnnhadXjOvC06vGsvD02m+ZiSS2/TORrCNWZyKJbedMpIvzwmXhunBbWBbWhfvCAy6LtyzesnjL4i2LtyzesnjL4i2Ltyzeunjr4q2Lty7eunjr4q2Lty7eunjr4rWnKOtvnTNVL8zglNqJMRPp4rawLKwL94UHPEPp4vlj7YSZoXRxWbgu3BaWhXXhvvCAZyiJ/a4ZShfnhcvCdeG2sCysC/eF7W7cznF7vrowgVPajcvCdeG2sCysC/eFBzyTSq01zaS6OC9cFq4Lt4VlYV24L2zec4Ul7TOpLp5eMZ5eNbYeqWRYwQYKqGAHo8N/Tmy9MIEZxJawzXSyY9FnOl2sC/eFBzzT6eK0cF64LFwXNu+5KJT2mU4X68J94QHPdLp4/vlq3Bce8EyVi9PCeWHbTuvc6zNVJs9blG7Hbt6iXFwWtj9vvXZ9BsLFsrAu3Bce8AyEi9PCeeGy8OKdgWA9Zn0GwsW6cF94wDMQLk4L54XLwtNrv30GwrB9OAPhYl24LzzgefdycVo4L1wWttPWNsF6XS4UcEqtcc1AuHjAMxAuTgvnhcvCdeHzx9q3HdSmpQbrwn3hEWxTU4PTwnnhAs8uUjUsYAWjC49ppMo0UmUaqTKNVJlGqkwjVaaRKtNIlWmkyjRSZRqpMo1UmUaqTCNVppEq00iVaaTKNFJlGqkyjVSZRqpMI1WmkSrTSJVppHpNIx2GGSxgTNm7ppFOFHAe1GTcFx7w/N7axWnhvHBZuC5sU/cmCqjglGbjAc/Prl2cFs4Ll4Xrwm3heQY3Y124LzxgPRZOC+eFy8J14ekVY1lYF+4LD7gfC6eF88Jl4ZgeOSeaXijglFor6n3hAY9j4bRwXrgsXBe2HzvPwxkTF+vCfeHh3I8ZExenhfPCZeHonO3HfMK5WBbWhfvCA07HwmnhvLD1+pnWcujCBto+HoYKdnD+0nTy/OrjxWnh+UuLcVm4Ljz3cDWWhXXhuYfVeMDlWDgtnBcuC9eF28Ky8PR2477wgOuxcFo4L1wWrgu3ha3Lz3aDjQ5d2MEptR0+A+ritHBeuCxcF24Ly8L2Y8+Vt/pxfRhy8oCvT0NOTgvnhcvCdeG28OxXNdbojO6H5oXLwnXhtrAsrAv3hQfcfWpQn5NRL8xgdEb3Yz6rXNwWloV14b7wgMexcHRG92PkhcvCdeG2sCysC/eFoxO8p/msYgc3zWeVi/PCZeHojO7paAvLwrpwX3jA6Vg4LZwX9ilYfU5VvbCB0Rnd09XJO7kvPOB8LJwWzguXhaMzuqfcFpaFdeG+8IDLsXBaOC88658nWKrRGd1TTQvnhcvCdeG2sCysC/eFx9WV3ecc1AsTGJ3RPc0nn4vrwm1hWVgX7gsPWKIzuidJC+eFy8J14bawLKwL94Vn/6z9rqt/dnJaOC8cndE9aV24LSwL68J94QH3Y+G0cL66svucoXphBaMzul8fq75YF+4LD3gcC6eF88LRGd3TqAu3hWVhXbgvHJ3gPR/HwmnhmfnVuC0sC+vCfeEBz49Vn2ti9etr1RfPa40Yl4WnV43bwtNr2za/WX3x9A7jAc8bGLvzub5bfbF57WS7vlx9sXnP1QF7njcwF5vXTrY8b2AuNq+dGHnewEyeNzB2vPK8gbl4eu03Xt+wnjy99huvr1hPnl77jfMG5uLptd84b2AmzxuYar9x3sBcbN5qv3HewFxsXguQPG9gqm2/JVKqts3zIcvO7Twfsi4e8LyHuTgtnBcuC9eF28Ky8OJti7ctXlm8snhl8crilcUri1cWryxeWbyyeHXx6uLVxauLVxevLl5dvPPtGzvd5ts3E0fgfMiqdmLMh6yL88Jl4bpwW1gW1oXtxzY7YeZz1uT5nHVxWjgvXBauC7eFZWHzNjsJ53PWxSO4zOesi9PCeeGycF24LWxvOFVDBTs4pedOLjOpLk4L54XLwnXhtrAsPH9sM+4LD3gm1cVp4bxwWbgu3Bae3mGsC5v3HL7qZSaV2M4p/gJZn3NpL8xgASvYQAEV7OAIrNgqtplO5yhLLzOdLq4Lt4VlYV24LzzgmU4Xp4Wn186BmU4X14XbwrKwwjNVzsGMXmaqXCwL68J94QHPVBE7XjNVLrY/r3bsZq/L5BkIF9ufV9ueGQgXl4Xrwm1hWVgX7gsPeAbCxYt3BsI5cNLLDISL68JtYVlYF+4Lj+A6A+Fi854DDL3OQDg/etHrDISL68JtYVlYF+4LD3hmwsX+3mOfM2QvLKBJz5GbXmcgXCwL68J94QHPQLg4LWw/9hwR6XUGwsV14bawLKwL94UHPG9dLp51xFgW1oX7wgOetyIXp4XzwmXhuvDirYu3Lt66eOvibYu3Ld62eNvibYu3Ld7Z2LudbLOxX9wXHvC8Fbk4LZwXLgvXhW3yrR1eEVDBKbUTbCbG5JkYF6eF88Jl4bpwW9h+7DDX7O+9uC884Jk8F6eF88Jl4bqwec8Z632ujeqsC/eFBzyT5+K0cF64LGwTnO1ctqn4Fwo4pcW4LzyC52Rc57RwXrgsXBeeP1aMZWFduC884Bk7F6eF88Jl4elV41l/GPeFz/r5HL7qNvc2OC2cjZNxWbgu3BaWhXXhvvCAy7FwWnjxlsVbFm9ZvGXxlsVbFm9ZvHXx1sVbF29dvHXx1sV7LaicjXXhvvCA27FwWtheUDlPwzldM9tz2Jyu6dwXtpL2TDanazqnhfPCZeG6cFtYFtaF+8KLNy3etHjn2rv2HDOna2Z7pJhTNK9/P0+rc8JYl3lanZPEuszT6uK2sCysC/eFBzxPK3u8mLM0nfPC5rXHgjlLM9sd+pylmc9JZX3O0sz2ZDBnaV6/ZZ5WFy+/cZ4y1t8wZ2A6t4VlYV24LzzgecpcnBbOC5vX+jPmDMxsfRg2AzNYFtaFzWt9G3MS5sVzje+L08J54bJwXbgtPOvb/pxrdlu/yJxIma0vZE6kzNb/IXOd7otlYYXnetwXzzq2/+e62xfPOnaOzfW1rV9kTnTM1hcyJzo6t4Xn+Wb752qDk/vCI1ivNpiN08J5+TNl4bpwW1hi/8yJjs594QHPdbFtP8wJjfO3zwmNzg2e5/C5Jk+fk/pysr87z+HJMxovTgvnhc1lwxFz8l62wa45ec+5LzzgeT5fnBbOC8/6w7gu3BaWhXXhvvCA5/lswxRz/p5zXrgsXBduC8vCuvBss3Yc5zr1F6eF88Jl4bpwW1gW1oX7wou3L965Tr2Ny81pe85l4bpwW1gWXo5pX45pX47pWI7pbDvn53L6nGKXrd93TrFzTgvnhee2NeO6cFtYFtaF+8IDntepi9PCeeHFmxZvWrxp8abFO69x9nvnFLts/dZzKp1z5TfO69rFsrAuPH+LGg94Xtcunr+lG+eFy8KLtyzesnjL4p2ZcPFy7Opy7Opy7Opy7K5r3+TFWxfXdftj23bd/kzOC5eF523XMG4Ly8K68Dw/D+MBz7Z/cVo4L1wWrgu3hWVhXXjxyuLVxauLVxevLl5dvLO92ySLOfUu27j6nG6Xbdx7Trdzrgu3hWVhXbgvPLfZjtHVlienhfPChe2Z19CL28KysC7cFx7Bc8adc4JtDWnrT7FJdo7lxGFYwQYK+LB36+60SXaOI9DWkL4wgRksYAUbKCA2WyLantptDl0X+0G2RLT1OtocOscGCqhgB0egLRF9YQIziK1iq9gqtoqtYqvYGraGrWFr2Bo2W27eHrJt7pyjBtrC8hfan22GAirYwRFoi8VfmMAMFrCCphBDBTs4Am2F+AsTmMECVrCBpjjT2yasdevqtflqjhm0Ynb+2gLwFzZQQAU7OC4cNk3NMYEZrGC/GtmwGWcXzkXdD8ME5quRjSMa5LDZZtYChs02cxRQwQ6OwGiQ44gGOY5okOOIBjmOjC2z6ZlNtzXbL0xgBgtYwQYKqCC2gq1iq9gqtoqtYqvYrOl1w8aPt5bVbf+2Gru6NVBABTs4Aue3ySaiEPavsH+F/SscTeFoCkdTOJqz6SXDcmXfONRDYdh8L0cBFezgCOwHmMAMFhBbx9axdWwdW8c2sA1sA9vANrANbMMDbxxDwe6YZoOc6IE3bEKWYwdHYDrABGawgBVsoAfeSKmDIzAfYAIzWMAKNlDAfmXfSMUDb6SSwQJGGqXSQAEV7GAEXqoHmMAMFhDF/LLKedKm+TGUiR3kD8yPoUxMYAYLWMEGCohNsAk2xabYFJtiU2yKTbEpNsWm2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBthm1/WvTCBGSxgBRsooIIdxJawJWwJW8KWsCVsCVvClrAlbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVG81/foX3QmwNW8PWsDVsDRtZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUvKzJJiWMEGCqhgB0fgzJKJCcwgtowtY8vYMraMLWMr2Aq2gm0mwXmbZPN25r2yTdtxLGAFGyiggh2Mu/jr470TsQk2wSbYBJtgE2yCTbBZ0+sT4xbbVrWbd/zXt3knxl389W3eiQnMYAEriKILqGAH45msjANMYAatmJ2I8043G8Z99fwgr+H8IO+FCcxgASvYQAEV7CC2hC1hS9gStoQtYUvYEraELWHL3pkxak5gBltgibv4WhKYwQJWsIECKtjBeGaoNe7ia81gASvYQAEV7GA8M9R2gKZQQyvWDQVUMO7ibSLNhXKACcxgASvYQAEVRKFx0laNk7by6Fl59Kw8elYePSuPnpVHz8qjZ+XRs/LoWXn0rDx6Vh49K4+elUfPyqNn5dGz8uhZefSsA9vARoOsNMh2xEnbeCBtRwbjpG08ejYePRuPno1Hz8ajZ+PRsyUBFexgnLSNR8/Go2fj0bPx6Nl49Gw8erasYAfjpG3lAOOkbSVO2lYEVDBO2sajZ+PRs/Ho2Xj0bDx6zo8JX9hAARVEYReJc67nmJ/LvVDBDo5AO38vTGAGC1hBbHb+nqtnjPm53As7OALt/L0wgRksYAUbiG1gG2GbH7s9lwkc82O3WgwV7OAItPP3Qtuyamjb0AwbKKCCHRyBFvwXWl0xzGABK9hAARU0mxqOQDtpL0xgBgtYwQaaoht2cATaqXxhAjNYwAo2UEBsFZud1ecaI2N+y/bCBGawgBXkYDUOVuNgNQ6WRIDMT9Wec4bH/FTthQ0U0O7E7JSzG7gLR6A9UV2YwAwWsIINFBCbYlNsHVvH1rFZO+7WLqwdX2gV7LS3VtjttLdWeGEFGyjRyGYrnNjB4Tg/NHthAjNYwAo2UEAFO4gtYbOLj/22+XXZczWYMb8je6H6D5rfkb1wBFrjvdB2qhhmsIC2o9SwgQJiy9gytoLNGu+FGSxgBRsoILYyFf/1X//021/+9q9//Mef//bXf/7H3//0p9/+8J/xL/79tz/8j//87d/++Pc//fUfv/3hr//xl7/802//3x//8h/2h/793/74V/vnP/7498d/fZz+f/rr/3r881Hwf//5L3866b/+ib99PP+r53JK5frrjz7slKPEoxv7Q5H0vEg/57JYiV5GFND64e/n539fDv8Fj5hlA+S4vQHnTcjcgH4824C62YAzpOzvP1rEKxswku/ExwPqsw2Q53+/nSP29vcfNx4vbUDzX/A4g59tQN/swRKHsL22B85pzNdplNKzLUibU1HPd4vmQVB9ugm7c7nay6hzI+qjb+r5ubw5GYu9N25FHh1DQo3Hr7pdo6if0aUue+MxxvOxxuactNdXrMSjrzsqPDbpY4W2OaZH/W+a5S8VNqfl6L4/H+PUr1WQGqfFkZ+X2O3M1uOAPO7pnu/M8bxGtmnDc2+WsrSwoh9D6tgdVA+ZMpZTS4/7v0Q4tR73dU9/Sd7UaKK+Ge1xCxE15OMOPWe6PW8nw8MitZaflqi7U8tPjF45MR5jcPcrtIhslecVNqfWYwAnjuljUDZq1PyxhG42okdsr1e+zxuxyc3H2IeXeIx9LCe45NeOhz4/HruzQqsfkMdzZ31WomwC/DGCEr+kaXpaIr97TMtmV2R7jf46psuF6NMxLZsTK/cU8f20wBf7MrEv+9Md8X7q7Uo8MiYuIWM8v4SUvjuxNLbjcXSjxmNs9GONsbs363FvJkuFdvuXVPukgpV4dMs+z++adhfDuL95DHAv6Zs+Xtjr5rimx+h73KM8xrBpJSl/vLTX8v4+rfXdfbr9LdkW2Z2b8Rizbs9/yy5Bk5KgfSxb8rHF1k2EPsYpo8bjQYzW8o3fUkbctj1GgtPz37K7wkvcPj6GWdkfj0T5UKPtrvC2OMlsc48r41Lj43a0tL3185PsMRpWntfYbYe9pDVrrLexv9TYnKd1xHY8uo3H0xr7IyNHNLvH0ZWnR6a13V6NM+QxwripsTtTZaQ4y8rxvMbuTLVXQGaNXPprNWqtcbkfzxOk7RK1+u54dFlxbRgfz1M5drflnWet8bzE5jSV1MmgdjyvsTs9zk+U+oacH+R8XmVzoj56+/2wPHr7l9PjYwbJ9vE9xy7V2p+W2O2P3DT2R98cls1Jms7XFeMq9ejOfVple6pr3EU98Hlz2TbcUmKnpvIYoXtaRcbugtnpG0qPwYUn4a7H73p5eAwXx1bUNZY//xbNv+sl9zFiGWf7Y3Dy+WVKd3enhcf69TEyf+qh0PbuPt1uRU0RhbUeT7did0uWU41fkjQ9vSXTvnsgjqenoksfxeP25naNx+i8X/gfw+zH0xr9eP+mrqe3z7DtHo1Hl/Na9fwmd1cjF2psjkp/u+epv93z1N/uedrviR6t5NHv8nxP7B6gyogrbV0vLJ+uLH3sbghznOOl6/Ma2we5uCY8mtrzGmO3P0r0MefH4PXTGtt9KjVyQz78lm+coRL7NOuH7fhYY7x9ho63z9Dx+56hGheUPDbtfez6nw6lw6SsD8Yfk2tsztDzU0XR8976SzXOlSN8h8r6CPephq3T/m4M2wPF75jDthzxdVxUXjvL7bO5VzdU7k9r2FLubw4BHPL2GMChv+eJ/vizI54AS97sjLF9GI1n0fLhTNdvFBktLo9Hr8+LpN1pKiXGGx/c153yaUhiNxrQY4yoLxfq8ulmct9TedBTufSAy/3BlVpihzwucPJ8cGU30FSOaPwlfRjXkG8UyYf+9yfJ5yL69tCGrfr+3tjGvsStjvC0G226ObqRcnp3eCPtTrG74xv3j4pujsq2Fyl6XkreXWDy+yOi+f0h0fwDY6Lb3dEiDcv2ept3F36NE+T8ONjTUdF9kR6DmvqhwXwuUtL77XY7+nSv3b4/gJW2w083221pb7fb3aDL7XZ7+6hs2u3+9JA4x/p48RzrKUYIelk25JcidfeQ30q0O1ku2r+M4G/b3YiJBGXo5lK370q6d7bvxqFunu3bEvfO9treP9t3o1A3z/btINTds/32UXn1KjWiC+cx7CnPT492vH967Iahbp4e2xL3To/dINTd06PVt0+P3QjU7dPj9lF5+fSI9HicHv21G+V6pOjwPOruHNsk6s1pREl+4DyV989Tef88lR84T+X981R+4jyVHzhPt2fHDzxYavbHuao6nj9Y7kagJEdPjNSyue7vhqDGwWjpcqb/ctnf75DMDsn64k69NUcr6e5ErXRNPYain9eo7zdbbW83222Je81W9f1muxs+utlsdfxAs719VDbNdn92xPyVx9khr9Vo9JA1eX5h6GXXBcuE/iPVl2q0EXPytzX2v+XWlMbU5e0zfVvi3pne+/tn+m4g6uaZPo7dXI2YYN/yMm78y5m+HYi6M0FzvzfuzRK1Fd3f24rdzqj2MZp5hRtLS/l1Z9wu0l8r0o6Y/9KO7WHZFpE4tsc6Mel7RaJ7rD2GNl4skqLLoKXxvIitfv+8p/+IyY3pXHqMMqm/GiFPJwPn3YiU0gOim2eg/a3DnSnJ+ajvPzbsi5RI9sf9WN8U2c5wEmY46fNXGI73O/pthdr3on1f4t5bDOn9jv6c3u7oz+kHOvrvH5XNmwz7s4P90Z9f+Lc1Sj4YcHx+u/5VjePtGjXFVaYuI/zfqsEclEe55zXSePuGbFvj5g3ZF/tDJX7L6G/XaEd+cZ/Gw+lj/PP5sd29wPToQ44pllo3rW67IcptiI7nUbgbTrp7cHc1fuTgcpEqu4a76+h/DN4z43Sd5/2tncqI1GNw/vlZthv6qDEYXfPm2JbtJNwRswTq8fzWbr8dJa6366szv+yO7TU7hgprWUdgPl+zd0NSNzse8m5M6u41u+jb1+xtiXvX7N1LUXev2bvhqJvX7O0ko9svH8r71+z92XGr42Ff417HQ94NR92Nsf123Oo0yPX9s7T+wFl6+5c8z8HdqMetZ5d9/NR4manKMqnvl/hp+d2JG3k3FnVv4sYXPyUxWWr39LPdjnuzP/YbMkrnMTtvNkTf36f97X26LfEDu6Ox7kNLdbM7dsNI75/prcaFtrWxecKW/Xt7/JQo8ehf+FRiNwXl1vshef9SVvQ3LNPef92K3Wu/KZ5bal7vse+XOMdrlsVp2vFaEeZ8PljSi0W420/ryP53dmpM9259c2g1/a4l0qHclx49Pf0p+yI3j8y+yM0j80WRe0dm23Ilpga1sU4N+k7fmKT4NfLxPfdvFYn2/9imzc36bkAqOj6XCUr1G3kqNSaeSzte3R1FSxTR5zMU7TWdN69R/f3rfv+dL9nSYjtE0m537GKojRKd2m20pyd731z3ReLFvcfY/uZquRuCqZlboTyej8znvp+NH+M4R3n+6LEdQLn3oL4bkEr9YAGC/jjET4cKvjo4R+HgLLe632g1WuKeXR/dfc8Pzqjvd7DvXpC6+7A+3h473Ze49xg03h87zePtsdOyG5C6/bB++6hsHtb3Z8e9DvZdjbsd7F/UON6ucbODfVvjXgd72Q18LB0PbQx9qcbNfty727HtANnvU97WWldj+WUtqfT+/rhZ443fcm/A4W6N3YDD/hy7NeBQdkvp3R5w2G7IvQGHsnu76fbB7e+f7De34/UT5N6gRdm9I3V70GK7IfcGLUqu794Lld0bUncHLfbbcW/Q4qs73brc6T7rxSi7xfnu3i5vi9zsx9je57K0aVJ5fpL9wBtS5f03pMpPLPH3/htS5f03pMpPvCFVfuANqS+eguLpI68vBfxyZH9gcH77JHWz1e7Gxex19uvQ5vLS7sgpepZyWp7YP++O3ZtNN4Nwt0bf7SDcbse9XfpF/9ZydTmWOXXf6SR7/MVBkfw0CGt/v6dtW+RHeoVv7pFtkbt7pOUf2CO7Ivf2yBcTJlO8zJPyq/M/08GYUk7Pi2zf9uSC++hl1qfdQmW/yN6tuQal9fcvl7tZlzcvl9sS9y6Xu3Gpu5fL3Up9Ny+X21ek7l4ubx8V3RwVfXuuwb7GvbkGRX7gcV3ef1z/4rfcW7d594rUzTN9W+LemX7/lzy/EdrN174313ofYbEui65Pt79EmLb37/j1/elSRfX9A/v2RJSi70+XKv3t6VKl/8B0qftHZRNh27Pj5h3/bpG+u9Gx345b4y+ly9u32rsBqXt3yfutuFdiu6rmvWeXL2rce3YZb888LeMHZp7ut+PWLv1i2Y5YnK6nvvnqxnaNq1tv3m6/bHDzfnK8/75JGW+/b7IvcSuM6/H++yb1ePt9k3r8wPsm94/KJozT+7eT6e27yXq8P4l/W+PuJeEHegjfP73S29f6ul2j7/brf/e/ifL0Ql3Tu3ek2y+BaEw/edxlrcuEfv5+xnZ1PQY5y3pufKME7xF8WMj2cwl9t69juzNkxKBxP9pmZ2wf7O/MKqp5uwT/rUUxtyVufiSmv3tItp93iVX11lXkfvm8y66C8DmD/rzCdpgmuq/ONbqWGnK/Ro1xvEeN9rRG3X0OKo0cnxp78Hh6jr/dnbf/To1IrFjyGPRdEvCX79Qcb7f4bYl7Lb68vzt2FxRlhWNdM/hjhfruOb6tcOsc33426OY5vv/00M1zfNtQ7p7ju6GzHF3FHxaq/+W7QbsajaXEW9vU2H6fJsdDyoNl8+WgXZmbLWVb4l5L2Z1jPxAcn3bHeL47th9S4oZYyvoBo/JiDX2/xjLd5VsfdDok7hYO2XwEabvwm33HfO7V3sumyPYTufEkvMzq/F6JWDuuN32xRI2tWFaReLWElNd2aG58o2J9lv5mES4LktqLh3akeH4cm+Oye5+rSDytlHVZ0W99rKvEBeYR3uW1Gnzwq47+/Oje/njZpsbtD7Hp83Zb5d2Hpu1WKGvn92OTYrv1+LRFy9e2vjn9+TK3XWqgc2VYhxP0U43dwMhYFitaX/f7XKNvB7zju2MPXr6Q9/nX7PZqzyP26nrR/k6u93jueaA8r7G90rUaUwAeSbC50u0+CjXoIjjWjgb9eF+3HbNK7JHU+mY7dktHxnDASJuduiuxTIlYRxR+rbHrP7r3Jba6Gy26+Sm27W9JR3yoL63LWf36Y7azqniIGmMTAP14PwB6ej8Adq9B3Q2A3UtM9wNge2wKH2MrI792sn4sMp7f2m2/5shlJvfnd/77GvRVPh4CXqtRhMGF4/kXIWU7dh73VP21zzlWetMfD4n9pRqPvs6Y1p36848X1t3Qk0g8gjwwvVZES3TQaVmmZn2zSG9RZPQXi1Q+blBLebFIj/EBXW+av3VwakxXa+tLKt+qobFHWj/SizXiiar1vPnC5XZtvnLEC/sP3uyStv1cVGby/oMlbcrsbiZaYxZfk+N4eWt4JfqxNWNTZrsObG98c65rf3UX8y3jB7dXz5h13UF9rQaTDNpYPmb8ra/VHnHmSkqvbYekeHKVtGuF+e27m+1Hc6VFzD54ef/2W5/eFe5MHtxfrSL0BYoe+mIVzfyi9ZN+36wSQyoP3gT2vkqPcdQHp/Tqtix7t6fne7ft3k/6Rj7tRqvOfFrmHozxepmbMffFj7obc9t3ph733YmY2+3iL8rcTMsvjndbzj15+dyLZYkf3F5tTYOTRobUV6vwaW4ZOl6rojm+GXpye7UKn5HWxzPm8yq7CRI/8oFuZRSma0svVum8OtB7Ol6sMpZtGZtb5f3HwvlksG5GCrc1OhPf+nIN+F6NRseQPH8K2nfqDNpPWd/r+GVLyvbN0jvf/9yXuDVguC9xa8Twi6+vLy+XjOPZ6jhtt09HUrqWno5L7UvkWE1q5NxfGZcqjQ6dss6j+d437flwcCqanldpVd4d7NuXuDXY195/DeobuyO/vlNpc1pebLnnx9up0jY9Ke3tcdh9iXuHpv2+47Afd8duHPaLQ8NDsurxtMqui/telG0r3Jv7sL1JK2X5jPqmk6ztesnuTQTZlnikYeFD6lJfLKLL/cx6tn+vSAxQPbjLK+fZ+cXe2K+tPL/87z88I3Fn9eCRXqqSbYWlqyt1uYnIx3itxvJE8K0aLVYbfXQQp5dqFKaOlvWLUb/UeH9Zy12JeqQY0E1rZ0M+7tdI0dP+yLX6tEbbvVN1M5e3Je7l8u7dinu5vN0ZufBqxYeb5c87YzeFdcRz66PTVzZFdiuXsDTe8vjwqRfpi80QNmNZ4uubv4XFRj98pP6bRfhuTHt5r8YbK+2Q42mRvl+/ID5wUnY10ruXy22FW5fLvv1O7b2pgtsaN6cKtv4DUwW3C6e1eBzrLT9f/bmNt6ey7kvcC6Dx9lTW/c6QZQqXbnZGfXdn7JaNLzneIiplfccsjU+bsV3b784c+rZ7e+feHPp9iZufUj9+osb2YZ2Hsfzh40r6aRR4c1xGdCuNZf0F/fSpy/1bL/da7L6IZGVUIC9vnDyGZb9ThqUsH7xcXr5dJlOm5k2ZXS9GPIGsy0CVT3e4X20Jr1XKh/cqv/eDamW4pK6jAt8r05bd25Y3Iz+Xkd2rVj9UJh+8KHWsfZmfZ0Fsi7CM+6Pfub1YJEfG5qzPi2ybc+YzZ/kR+8+bc3p/rc4vatAUWypPr+P7IjdvKL7Yknt3FLIdg7qbT9uDUzlN2ujPD07ezqeICdntwxLX5XOR7cjGrVUeJJebZ8nzF4tlt97evbc29yVuvVgsu29I3XzzU3ZvYN1781N26/XdfbH4/lHZtN3t2XFvlQcp76+B+sV23FrlQcrbC6rJbtm/+6ts77fk1rIE2x1yc6WHL2rcWulBSn9/p+4C9eZKD/vtuLfSwxc3NcvsjbpMHv7lNuL9N7Hk/TexpNbftcTNRd2+2KVMT3/s3vZ0l+4e024+3OyeWh893DGRUtLzz9psn3yZfNVLri8++d47LrsXXG4el+3aFxILkvS1k+jzT0nH28My+xK3Opq2P+XujeG+yN0bw/YDb15v1/lv0TOb16nHnw+MtPeX6pXt2M7NW7rdbMWbt3TbEvdu6eT9xTxk9zWqm7d0u/ewbt/S3T4qm1u69v5SvSLvr1r+xXbcu6XTtz+cIvojH07Zb8m9W7r2/sLDX9S4d0u3HaS6uVPlB27ptttx75Zue33RmHLd24uXqJhFK/35VKz+/u3Lbj3pkmNJ2kfH9zoC0e/X0Lhel/Fh1Zn7NeoRNeqxTpH53FT6253/+82IG/Watpvx/iKIX9S42bW1/0zAza6t/ZbcvIMZxw/cwWxvpRqzU5I+PTa7GpkZLllEXqvRYoJLFq3Pz5FR3x0gkt3Xju4NEO1L3Hz+2e7RZY7tIZu98QOfopCxfak9jm05PgzcfdwS3b0ZdPfLbbq96b93A6K7q8O9a6Ue5UduQL44OLe+3Fa2nzvt8WS53j18XphMj+107lsfbtPj/ZUq9Xh7pcp9iVtPH5reX6lS09srVWr6gZUq7x8V3RyV7dlx68Nt2xo3P9z2VY3j7Rr3Pty2r3Hvw22a7n04Zfctq22Nm2t33t2ObY39Pr314TbdDXzc3R83a7zxW259uO12jc2H2744x259uE23n6G6+eG2/Ybc+3Cb7tbzu3twdzXunuw3t+P1E+Teh9t0OyR188Nt+w259+E2LW8voq5F3+822G/HvZ6Yr25073y4Tevx/t3ytsjNCcPb29x7vcFa3x/g1/r2AP++xL37sfr+AL/Wtwf4tf7AAP/9o7K7H0tv9wZrSz8QhfndVrv9KTf7T7+ocav/VNvb/afafqD/dL8dt3bpdh74re7TfYU7vaf7l2HimfSByzpL33mhRngpR0Z5rUaPBQzy2n36vZdyuBE78vPf0nS7Hui9N3u2RR7HMwZvuz59LXdbYkRzk5H1tRIMIa9fWpP7R0XjQp11XWbtO0f2Q436Yo1MjbI5wzS92zG+L3FreoG+/5rTtsTNu5bt/pT/9j3J7x2Tpc9zvJgc63a8WoPblnOJgRdr1HyrxtuDYfr2WNgXb+LHYMfI+cWX+WPp3Qc+fXN1u7LBrV3xRYlb+2K73gRLCH+4Jf7WmhWJJWI378/va8T9bF7X7vteDdpJH89f8/5iTZLKaiK9bZa3ul9ltzbVF1UqVfT5qjE6dr1I91Yj1d0Y1N31uvbrtGSW/x6b1Qi/2Cc8bzwO8strxqzbUl6uwhN6H/XFFYYeXYC8wJ5rebWKLGsDvbxOEa9+PjjnV6vUpUp7dbWjUtYq8mqVpc+w9Jf3iy5VxvFilbqsAlXzq0e6HmuVl886lo59POA/P0Z9+7peXd5Nq7sT5qsyLCfx2Jjnazj17Uzf24uYfbU18WDy4M0Sh9/5UW+UURanWJcK/nXftP8X+2bpFViXIHnjR71RpiaW3NitK9u3b1P91L7h+4gPru1HflR9NT6Pgzkw6yfVv7n83TiWKs9Pvi9W/401xB84XiwiienzWV8s0mJykbbx6s/R6DjV/vLazOvPeb0I33cQfXVtZo353o/n+vrqlsQSGI8i7dUtaXyuotUfODppEwnlR1YP/mLF6iR3zpT9wuiFxdXbZmGx7Yem4jMPeZ27+fkjUX37kbx7cybf/85er8fvWuLmymS7/VlYHano849u9d3Qya3Fa7ZbUelcWsf2f92K9vbjYd9tyN2PVWw/Y5b5QmhuT3/Lvsb6/djn+6PW7ZzNm99T2xW517W9L3Gra/uLEne6trff67vVR7WvcKeLavtdzFvbsK9wZxt28yx4cGsfntv6cbtEi76C1uqLJaKf7VEtvVLiMbTI8OR6cuf2jRIxypCWofxvlWAoLC9rBnynBP2vj2tbfqkEs4k+Dsh9o4TG5f0x4vLa7szxHYhHV/RrJUpMun3slfTaVjCwWI6XdmeLtevba3uiDT4r0F4pkI7MZ6jktRKJDz+uSwV+q4TwdaD+2laUZS3Z8dpWLCsFt6qvlRBmdvTx2g9hge914aJvlaAPvLTXfogInzLQ17ZCld6y8VL7SKxKlUZ+qYTG+Nv6cYhvFBhx1zraS/thxLSStQP/OwWicQxtb/6E1wo87ulimcW2fqnjOxfi3LgQHy+VqHFCtbp+deR+iQ8TOdab7na/ROJ1vLyu9PipRN8+48ZJyc6s5f4ltC/flxyv/IqkbVkBeH2p8NMcod37TVljdfas+dlky337jtAeH1au+0bK9Lh0rNOKf/0h21dO7rwu1nevR917XWxf4t7rYtubxM536ZYXGz7vjHHsP0jCURF9vtjkF0XK+lWT8rTIdgoZEwPb2ovzy8/ZdeIvn/z8uFs/LWSym2fd+TzdY8RAN0X2c0GWN+jK5ufspi+kwi3fMnc0HekbRSS6tkTWJeK/VaRHin142P6lSHp7nuEX2yHLQ3/fbMdu5hPfIamP3jgO8C9vru46QCUvq0UuKSDf2a18GPYxeLA5Nmn3XsBR+Pb4cpbUTy8EjrRbmzTF9OCRlg8y/1pkNyW/tOVbcGNZ4f3XXbvdlujqGrlttiUfP9CKt7s2xzSID9f/X7dk+9m/Hl/uTG2MtilTfiKW+vYOOUYh+pqyn0+4vEtZe5nS7yeWIu3Tu867Rfzawf3dsSmhP3Di796Zun3i5/EjJ/72B9093Ur6kdOt5B843fJ27WbeBSnPD3LZTy2Pnhc9NmuTlfZ7/xgmhBxLL9Kvv2b7Fe/KTVvqm1/Tf+LXtO31Kx63tW9+znas6YhnxUdPxq5I+oEjXH/idN3+nBQjoyUvnUK//pz6A4e4tt877AdfN16/7/dL2O/eo6q8hlmP5c7vlzDZvUmVamZSzPJW2Pj0gFB3S+Ok6I5+HKfl/rF/KtL2fQLxXsbaf/kYr/1UJP3EubZdLYjeibJcd379OeX33pKaeJt76Wr5dUt2o6RH4uMca9ORb5xqtJzHbYo8P9V2swF+5OntcW6w8MCxebbeLvN1N9fk+L1/Ti7k2roSy+efI/kHck1+4oTd3pV3YnqdVZzSp0a8W+rvO88qu23htcqa1m9a/rItP3HObm8eb++V/wc3snf3iv5IzOpu1C36tx6d0rLZkvL+5Wv7WuHdy9dutb3bly/9if6t7c+5e/nS/ntvyd3L1+4zRj9x+WoSSw+3D487n0+1/gP3sbvZWxpfQnoMooxXOtqrxJcPqtbnHe2jt3c72sd2VcZbHe3jBxZ2/KqDe/lU9vMPMY7deoi3e8m3iyre+zTUto98ZMZh2st95JGIPa0Tlr9XJGYu9Zw2W7J780pHPILqWF9H+6XILldbjsvV82HbfVcuHVrSlq8qfa8rlzdIy5D06t3EzWOzL3Lv2KRjtwTg3YPzqJJ+16Oj0peJ089HUh4bsn3rOo5OXT8a/rnE5nRtzIhqHz61+2k494tbvZunyf726uZpsi9y+zTpP3KajLdPk22ndFwsPnzvp33+QNtulKsyC7yW/HzAft/rSe9clppe7fW8eYT3Re4e4d3bVfeP8DYe3z/CvNc6lvcu/5sjvFtYPcU6Ei2tCz3/coR3d4uJcy1/6E4+vtMTfPcI9584wrtRrvtHeDfIdfMI7zpxM/PI8jqL69djnLfrA9Voxcf6PePPh2fbs323Fe97tm8e432R28d4/MQx3i3K9wPHuKSY6V0e99KbY7wb4qo97upr721zjOsPtOP6E0ldfySpdyvzfeMY69vHeNvpUgqTfJcBqvH5kzG7NxtqzMVfv2uUpH+jRoul+Zq8XCNej2/L0gPfrDHiZZWj/ECN/mINif0hL+8Pif0hL+8Pid+iL++Ptcar+4OlG/Xl/aGxP/Tl/aHxW/rL+2Ot8er+4NWuLq9uR4/3oddXS79ZI/rDx8v7Y63x6naMiOWxyaAv+n2F2YTr2iXl8+Nr275cGm8Plw9rdHyvSo1ztbSjv1qFFQOLrGvdfK+KRh/juUzvf73YH373QfgH+rLSIT/QmZUOeb83a9upzneJy/oZvW9279/dsT/ydCI/cueqx++7Y2vc1TxGK9LTHZuO3RpvJcWoVlk/YP3LlwG3N1hLp/aHK5d+LrJ7fXX5vmB5sURnWnB/tcTx390K6P0BoDqi16Z9+GjSL3t0931Tbq+qrLMaXy9Sng5F3R8Tk81Z1rfLBfFuQC39+c/ZDWjJUVl3eGz2Sd+dqolh3AevE1ffKfN8nG8/Gnz0O6PB27HCGjcWrdXnA+SP37Nbij0dvI25rinyy0W07064GA+q6yU0H59rbCdnkWp5V2O3HSnSdV0q7pcau08o3c/53Rtbd3sodge4aeSJrL3Avxzg7YdoG5/6Kc+fgPdDW/9dibPT5Btj0jev4/1HeqDGj4wUjPdHCvbvKMQk65GPzbTI/TsKN3fsvsjNHZt2Q1u3d2zaTjS72UG/fVtiGZ9+XArTZteWn9i15Ud2bf+RXfsDo1v9J87ZbZF7L+c8gu4Hprl8VeXeQf6qyt2j/CMjXOkHRrj273/cbkDlJ0K//MiuzT8xiyDl92cRbKex3+ySTrtQudklva1xs0t6X+Nel/S+xr0u6ds1+os1bnZJ72vc65Le17jXJX27xqv742aX9L7GvS7pfY17XdK3a7y6P252Se9r3OuS3te41yV9u8ar23GzS3r/Js3NLum0G5e+3SW9r3K3S3pf5W6X9L7K3S7p9hNzs9pPzM1K9UfuXuv7d6/bEne7pNtPPBa0H3ksaD/yxNXq77tj73ZJp93HJe52Safdy1t3u6TTblDoXpf0vsStLukvStzpkt5+Guxml3TavbV1t0v6G0Wed0nff8tw0yWdtm9t3eySTrvvUtztkk6iP9El/a0ym1dP+u/bJV2P6B14VMubB/vdhODbXdJpN751s0s6bT+Rda9Ler8d97qkk/5Ix4C+3zGwf72Wbx6mIrsDvB+4v9ElbYtqvNkl3X7iHYf2E+84pP4TE19Tf3/i6+0lp+rzJafOVTc3Dbgv3+xZXjH89O3V/ZvPd+e9yk90jsuPdI73n5g9kMb7swd2F+Lbk03lJ+6B5UfugX/i5a1Hlfa7tp3Cd53K+nmdX5drq7srKPOJD8mbBrgb4vqZKvcWWP+ixq0V1r+qcWeJ9f1y2vHRurQcmU959LiNKrtojHWVjqcldhtx74PUj43Yzc++9UXqR43dJ9UGH5Z98Low6qf383cvO8cnqdqH79u2Fwp8+Jzr7QISt6trR8t3CizPeOmlArHOrnz4EML9ArdW3d8WeHPR/XvvAu+WU62xSsOj82YZhPv04ZTtGtgpHthbqS+V0OVjePW1reiyfPNQXiox4o2SNNY1Ib9RQlhmV/S1HyKDZbSP137IsSxT1l/bihyv3ae8vnf/jRKFry3W5eMt39qKeAMrZXnth7DwfypJ3t0XL5dogx+yBG76zlYoRyS/X0JeKlFiCegH9tdKCCOoyxoZ3ymxRk59bV8UvpFa18/Ev1ritYO6riqzfK7kWyVYub+KvFiCH7J+X+M7JeIG/DGU8NpBrdHD+HiWOV48L/gcQ37poNb45uKHHsr7BTg1W36+Hx7JVre5V4mL5Ubx/v1d5WM8+tLP0Li7qi8di9aY/FhfKhALvbdRXisQsxtGfa/AOrXhWzuRTuaXslKi83FdX/q1Lfh8GP/n4//+8V///Pd//svf/vWP//jz3/7674+/919nqb//+Y//8pc/Xf/3f//HX/91+a//+P//zf/Lv/z9z3/5y5//zz//29//9q9/+l//8fc/nZXO//bbcf3P/+jnDJPeRvqf//Rbevz/x2BH/qfHM+Dx+P/F/vtjPKk3kfO/n39Bzq9IPf5nnP/i/Bv9/GTA43/G//yvc5P/Lw==",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n        offchain_messages::emit_offchain_message,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n    utils::{array::subarray::subarray, remove_constraints::remove_constraints},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash,\n    address::AztecAddress,\n    constants::{PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_SIZE_IN_FIELDS},\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note_unconstrained`, except the note is emitted as an offchain message instead of a\n/// private log.\n///\n/// Like `encode_and_encrypt_note_unconstrained`, this function uses unconstrained encryption. The sender can set any\n/// message contents, potentially preventing recipient decryption and resulting in note loss. Since offchain messages\n/// inherently lack delivery guarantees, constrained encryption provides no benefit and is not offered.\n///\n/// While delivery is not guaranteed, message integrity is still protected via cryptographic commitments in the note\n/// hash tree. For guaranteed delivery, use `encode_and_encrypt_note` with private logs instead. See\n/// `messages::offchain_message::emit_offchain_message` for more details on delivery guarantees.\npub fn encode_and_encrypt_note_and_emit_as_offchain_message<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n\n        // Remove the tag from the log\n        // TODO: This is a tech debt. We should refactor this file such that the log is by default computed without\n        // the tag.\n        let message_ciphertext: [_; PRIVATE_LOG_CIPHERTEXT_LEN] = subarray(encrypted_log, 1);\n\n        emit_offchain_message(message_ciphertext, recipient);\n    }\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let note_nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = (packed_retrieved_note[2] as u1) != 0;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, note_nonce),\n    }\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u64, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u64, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u64)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u64\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u64, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_timestamp) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical timestamp (timestamp of\n        // the historical block against which we are executing the private part of the tx) as this one also takes into\n        // consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by scheduling\n        // immediately after the historical timestamp, i.e. at timestamp `x + 1`. But if there was a delay change scheduled\n        // for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value change was scheduled at\n        // timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier than what we'd expect if we\n        // only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_timestamp);\n        let timestamp_horizon =\n            value_change.get_timestamp_horizon(historical_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the timestamp horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(timestamp_horizon);\n\n        value_change.get_current_at(historical_timestamp)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u64)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_timestamp = header.global_variables.timestamp;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_timestamp)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        smv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "205": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "206": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "208": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "209": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "218": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "225": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "243": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "286": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "303": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "305": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "318": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "320": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "321": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in\n    /// private with historical timestamps. This function can be used alongside\n    /// `ScheduledValueChange.get_timestamp_horizon` to properly constrain the `include_by_timestamp` transaction\n    /// property when reading mutable shared state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'timestamp horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the historical timestamp that is used to construct the proof).\n    /// Reading in private is only safe if the transaction's `include_by_timestamp` property is set to a value lower or\n    /// equal to the timestamp horizon (see `get_timestamp_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_timestamp`\n    /// (timestamp of a historical block at which we are constructing a proof), since due to its asynchronous nature\n    /// private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the timestamp horizon\n    /// computed using the same historical timestamp.\n    pub fn get_timestamp_horizon(self, historical_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The timestamp horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the timestamp horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the timestamp horizon.\n        if historical_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the historical timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the historical timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `historical_timestamp + 1 +\n            // minimum_delay`. Our timestamp horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    historical\n            //      change       timestamp          timestamp horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the timestamp horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         historical\n            //         timestamp                      timestamp horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the historical timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           historical                         timestamp horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because historical_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                historical_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "339": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "356": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "380": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "381": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "393": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 180, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[utility]\n    unconstrained fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<11> for TokenCommitted {\n    fn pack(self) -> [Field; 11] {\n        let zero: Field = 0;\n        let mut out = [zero; 11];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[8] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<5> for TokenLockAdded {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable<2> for TokenRefunded {\n    fn pack(self) -> [Field; 2] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; 2]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<6> for TokenRedeemed {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<11> for TokenLockedFirst {\n    fn pack(self) -> [Field; 11] {\n        let zero: Field = 0;\n        let mut out = [zero; 11];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[8] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable<6> for TokenLockedSecond {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
