{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19B5wct3X+7BWSd+SRyyKR6mySKFKSt97tuVJW782SJUu2tXe7SxVK7GqUxD2SEimSImmJRVR17457r//EiWM7idMTpzmJncQpTnXi2ImdPyDN23333ZvZ2ds3x4V0+P1wNzsAPnx4eHjAABhMwnvRze7yvEu7XrxOGN/p/+8wfiHco//8uluI1yvcmyHcmyncSwr35gr3jjF+JdxbYHwV7h0n3DtZwDtFuLdQuLdIuLdYyGOJcG+pcO9U4d5pQh7LhHhnCPeW+3LhLuH/p/vZVH8uVx7IlNPZdDGVGRwq5FO5/FB/IV1I5wv5UqaQzZYLucLA4NDgQGowncuW05X8YLaSetHN7KxjpVpymeE4ec4aP8883rDc5hjfxbhaOfzCvz7dq18vY9ez/DiULml+zzZ+jvFzO+v3yXWCDFKtufQZiljJTr26maemQ6lUnPJbrog1W1F+xyjKT9LteUy3j2HXc9j1XNDtY83v+cYvMP44Qbc7lOvmNE9PnsfryTPN7bHFXRizHI5X1KsTYpLDCb4cukAG3CWU5ZLw4rExni7PwRpgl+8nQjjLPAeEk06luCxO9K37STgitQH3wj0baRqQ0u4duBDH2/LKFetS6RMVW/FJir3DpFIiy9FKebKvVKegUp4sKOUpjinlyYpKeYqjSnlyp3tKudBXqkWolAsFpVw0AUqpoUiklAsVlXLRpFJOmFIu9pVqCSrlYkEplzimlIsVlXKJo0q52EGlXOor1amolEsFpTx1ApRysaJSLlVUylMnlXLClPI0X6lOR6U8TVDK0x1TytMUlfJ0R5XyNAeVcpmvVGegUi4TlPKMCVDK0xSVcpmiUp4xqZQTppTLfaVagUq5XFDKFY4p5XJFpVzhqFIud1Apz/SV6ixUyjMFpTxrApRyuaJSnqmolGdNKuWEKeXZvlK9ApXybEEpX+GYUp6tqJSvcFQpz3ZQKVO+UqVRKVOCUqYnQCnPVlTKlKJSpieVcsKUMuMrVRaVMiMoZdYxpcwoKmXWUaXMOKiUOV+p8qiUOUEp8xOglBlFpcwpKmV+UiknTCn7faUaQKXsF5RywDGl7FdUygFHlbLfQaUs+Eo1iEpZEJRycAKUsl9RKQuKSjk4qZQTppSv9JXqVaiUrxSU8lWOKeUrFZXyVY4q5SsdVMpX+0r1GlTKVwtK+ZoJUMpXKirlqxWV8jWTSjlhSvlaX6leh0r5WkEpX+eYUr5WUSlf56hSvtZBpVzpK9U5qJQrBaU8ZwKU8rWKSrlSUSnPmVTKCVPK1/tKdS4q5esFpTzXMaV8vaJSnuuoUr7eQaU8z1eq81EpzxOU8vwJUMrXKyrleYpKef6kUk6YUl7gK9WFqJQXCEp5oWNKeYGiUl7oqFJe4KBSXuQr1cWolBcJSnnxBCjlBYpKeZGiUl48qZQTppSX+Ep1KSrlJYJSXuqYUl6iqJSXOqqUlziolJf5SnU5KuVlglJePgFKeYmiUl6mqJSXTyrlhCnlFb5SXYlKeYWglFc6ppRXKCrllY4q5RUOKuVVvlJdjUp5laCUV0+AUl6hqJRXKSrl1ZNKOWFKeY2vVNeiUl4jKOW1jinlNYpKea2jSnmNg0r5Bl+prkOlfIOglNdNgFJeo6iUb1BUyusmlXLClPJ6X6neiEp5vaCUb3RMKa9XVMo3OqqU1zuolDf4SnUjKuUNglLeOAFKeb2iUt6gqJQ3OqqUimfETphSvslXqptQKd8kKOVNE6CUXIitKuWbFJXypkmlnDClvNlXqjejUt4sKOWbHVPKmxWV8s2OKuXNDnbfb/GV6q2olG8RlPKtE6CUNyt2329RVMq3TirlhCnlLb5SFVEpbxGUsuiYUt6iqJRFR5XyFgeVcshXqmFUyiFBKYcnQClvUVTKIUWlHJ5UyglTypKvVGVUypKglGXHlLKkqJRlR5Wy5KBSVnylWoVKWRGUctUEKGVJUSkrikq5alIpJ0wpb/WV6jZUylsFpbzNMaW8VVEpb3NUKW91UClv95XqDlTK2wWlvGMClPJWRaW8XVEp75hUyglTytW+Ut2JSrlaUMo7HVPK1YpKeaejSrnaQaW8y1eqNaiUdwlKuWYClHK1olLepaiUayaVcsKUcq2vVOtQKdcKSrnOMaVcq6iU6xxVyrUOKuV6X6k2oFKuF5RywwQo5VpFpVyvqJQbJpVywpRyo69Um1ApNwpKuckxpdyoqJSbHFXKjQ4q5d2+Ut2DSnm3oJT3TIBSblRUyrsVlfKeSaWcMKW811eq+1Ap7xWU8j7HlPJeRaW8z1GlvNdBpbzfV6rNqJT3C0q5eQKU8l5FpbxfUSk3TyrlhCnlA75SPYhK+YCglA86ppQPKCrlg44q5QMOKuVDvlJtQaV8SFDKLROglA8oKuVDikq5ZVIpJ0wpq75SjaBSVgWlHHFMKauKSjniqFJWHVTKrb5SbUOl3Coo5bYJUMqqolJuVVTKbZNKOWFKud1XqodRKbcLSvmwY0q5XVEpH3ZUKbc7qJSP+Eq1A5XyEUEpd0yAUm5XVMpHFJVyx6RSTphS7vSV6lFUyp2CUj7qmFLuVFTKRx1Vyp0OKuUuX6l2o1LuEpRy9wQo5U5FpdylqJS7J5VywpRyj69Uj6FS7hGU8jHHlHKPolI+5qhS7nFQKff6SrUPlXKvoJT7JkAp9ygq5V5Fpdw3qZQTppT7faV6GyrlfkEp3+aYUu5XVMq3OaqU+x1Uysd9pXoClfJxQSmfmACl3K+olI8rKuUTk0o5YUp5wFeqg6iUBwSlPOiYUh5QVMqDjirlAQeV8pCvVIdRKQ8JSnl4ApTygKJSHlJUysMxVS4qYas8n9TjmY6T5xFH5PnU+Hlm8IblNsd70SARV1tfv/CvT/fq10fY/af8a0r3tPn9jPHPGv9c54v3re9m5Q+TSao1l35ase443+c7YyRcA1dUji6fq2tC72Y83+7L5R3+/3f6/9/l/3839gzvEnqBDmXBJhQF905HLM17xs8zhzcaWZq3s+t3sOv3gKV5r/n9PuPfb/wHOuv3yWn3/opKnn6vYu//QWWLh3XzQVYH72PX72fXH4C6+ZD5/WHjP2L8Lx2FXuBdaiO1Spnz/WhnjIQtuJaxIvIfVVTajykqbVwytBy1jB/J8GOOGOmP6/HMxcnzE+PnmcUbksH6ODNM1tP1h9j9T4DB+qT5/SnjP238ZzpH403qqF7df1aPZ1aq+8+yOn43u/5kSN1/zvz+vPFfMP6LwkACbXKqNZc+QdGOfknRvvOBtMVd2EAOGn2AFve3O6L/X1bjmRmKk+dXFHiWK9lyf7oSa1/y1XHzzER6MPkysxtfCZgO+SrYk6+Z3//P+F82/lcm4MFE8Usg6a8p2qavx9QmteWn+M2p9P9TlN+vOiI/xa8bpn9ZUX6/FvOD8deZPfhVdv1r7PpXwDZ8w/z+deO/afy3JsA2KH6jN/0Nxbr5tiO6rfg1+PSvK8rvNxyR3/mK8vumovx+M2bb8G1mA36DXf8mu/4W2IbfMr+/Y/xvG/87E2AbzlGsm99SrJvfdUS3X6Mov+8oyu/3HJHfoKL8fltRfr8fs234XWYDfo9d/z67/h2wDX9gfv+h8X9k/B9PgG3IK9bNHyjWzXcd0e20ovz+UFF+f+KI/M5SlN8fKcrvT2O2Dd9lNuBP2PWfsus/BtvwZ+b3nxv/F8Z/bwJswxmKdfNninXzl47o9qmK8vtzRfn9lSPyW6Qov79QlN9fx2wb/pLZgL9i13/Nrr8HtuH75vcPjP8b4/92AmzDSYp1833Fuvk7R3RbcStn+geK8vuhI/JTfGkg/TeK8vv7mG3D3zEb8EN2/ffs+m/BNvyD+f2Pxv+T8T+aANug+Opb+h8U6+afHdFtxZes0/+oKL9/cUR+isd5pP9JUX7/GrNt+GdmA/6FXf8ru/4R2IZ/M7//3fj/MP7HE2AbFA+lSv+bYt38pyO6rXj8YfrfFeX3X47IT/Gg3fR/KMrvJzHbhv9kNuC/2PVP2PWPwTb8t/n9U+N/Zvz/TIBtUDwuPv3finXzv47otuKHSdI/VZTfzx2Rn+InsNI/U5TfL2K2Df/LbMDP2fUv2PX/gG34v84XfySM7+iK3zYofsgx/X+KddPZ5YZuK34yOO116cmvyxH5KX6cPp1QlF93V7y2weo32YAudt3Nrju6RtuGKeZiqvHTjO+ZANvwVsW6maJYN72O6PZNivKbqii/6Y7Ib7ki1jRF+c2I2Tb0MhswnV3PYNc9YBv6zMVM42cZn+yqvzDYwepFcitVypF54V2SJTHlgfvgtd8pOt3Tbw/aHG/sbH+O1znA8WoHOF7uAMeLHeB4vgMcz3GA42sc4DjoAMe8AxzTDnA8ywGOZzjA8VQHOC5ygONJDnA87ADHJxzguM8Bjrsd4LjDAY7bHOC4xQGOmx3geI8DHDc4wHGNAxzvcIDjKgc4DjvA8a0OcLzJAY6Kc/Gh58OkWnPpvpjWNmquQ5nwlxQXzWfrFX7UYUYWd6H34oKCvz9hjNOuyIT38lY4bZ5f6nSDZ6c3wQ24nU7hWhFT4bXLrNg402c6UuYOxTKf5UiZFRtj+uwJKnOqNZd+haL8jnXE6KY8N3imHeGZcYRn1hGeOWWe2jbDnoyrebqzxbKnqmrzzHt6HD/U6YY971cs8wmO2PMBzw2eBUd4DjrC85WO8HyVIzxf7QjP1zjC87WO8HydIzxXOsLzHEd4vt4Rnuc6wvM8R3ie7wjPCxzheaEjPC9yhOfFjvC8xBGelzrC8zJHeF7uCM8rHOF5pSM8r3KE59WO8LzGEZ7XOsLzDTHxbOf11OsmqMyp1lz6ekX5He/IvOwbPTd43uAIzxsd4fkmR3je5AjPmx3h+WZHeL7FEZ5vdYTnLY7wLDrCc8gRnsOO8Cw5wrPsCM+KIzxXOcLzVkd43uYIz9sd4XmHIzxXO8LzTkd43uUIzzWO8FzrCM91jvBc7wjPDY7w3OgIz02O8LzbEZ73OMLzXkd43ucIz/sd4bnZEZ4POMLzQUd4PuQIzy2O8Kw6wnPEEZ5bHeG5zRGe2x3h+bAjPB9xhOcOR3judITno47w3OUIz92O8NzjCM/HHOG51xGe+xzhud8Rnm9zhOfjjvB8whGeBxzhedARnocc4XnYEZ5POsLziCM8n3KE59OO8HzGEZ7POsLzOUd4Pu8Iz7c7wvMdjvB8pyM83+UIz3c7wvM9jvB8ryM83+cIz/c7wvMDjvD8oCM8P+QIzw87wvMjjvD8JUd4ftQRnh9zhOfHHeH5CUd4ftIRnp9yhOenHeH5GUd4ftYRnp9zhOfnHeH5BUd4ftERnl9yhOeXHeH5FUd4ftURnl9zhOf/c4TnLzvC81cc4fl1R3j+qiM8f80Rnt9whOevO8Lzm47w/JYjPL/tCM/fcITnbzrC87cc4fkdR3j+tiM8f8cRnr/rCM/fc4Tn7zvC8w8c4fmHjvD8I0d4/rEjPL/rCM8/cYTnnzrC888c4fnnjvD8C0d4fs8Rnn/pCM+/coTnXzvC8/uO8PyBIzz/xhGef+sIz79zhOcPHeH5947w/AdHeP6jIzz/yRGeP3KE5z87wvNfHOH5r47w/DdHeP67Izz/wxGeP3aE5386wvO/HOH5E0d4/rcjPH/qCM+fOcLzfxzh+b+O8Py5Izx/4QjP/3OEpwV0gWfCEZ4djvDsdIRnlyM8ux3hOcURnlMd4TnNEZ49jvDsdYTndEd4znCEZ58jPGc6wnOWIzyTjvCc7QjPOY7wnOsIz3mO8DzGEZ7HOsJzviM8FzjC8zhHeB7vCM8THOF5oiM8T3KE58mO8DzFEZ4LHeG5yBGeix3hucQRnksd4XmqIzxPc4Tn6Y7wXOYIzzMc4bncEZ4rHOF5piM8z3KE59mO8HyFIzxTjvBMO8Iz4wjPrCM8c47wzDvCs98RngOO8Cw4wnPQEZ6vdITnqxzh+eqYeHYAz2yqP5crD2TK6Wy6mMoMDhXyqVx+qL+QLqTzhXwpU8hmy4VcYWBwaHAgNZjOZcvpSn4wW/GxE4plfs3LsMyvdaTMnYplft0ElTnVmkuvTOjJr6/LjTKfo1jmL3W6YWtf70ifcK4jPM9zhOf5jvC8wBGeFzrC8yJHeF7sCM9LHOF5qSM8L3OE5+WO8LzCEZ5XOsLzKkd4Xu0Iz2sc4XmtIzzf4AjP6xzheb0jPN/oCM8bHOF5oyM83+QIz5sc4XmzIzzf7AjPtzjC862O8LzFEZ5FR3gOOcJz2BGeJUd4lh3hWXGE5ypHeN7qCM/bHOF5uyM873CE52pHeN7pCM+7HOG5xhGeax3huc4Rnusd4bnBEZ4bHeG5yRGedzvC8x5HeN7rCM/7HOF5vyM8NzvC8wFHeD7oCM+HHOG5xRGeVUd4jjjCc6sjPLc5wnO7IzwfdoTnI47w3OEIz52O8HzUEZ67HOG52xGeexzh+ZgjPPc6wnOfIzz3O8LzbY7wfNwRnk84wvOAIzwPOsLzkCM8DzvC80lHeB5xhOdTjvB82hGezzjC81lHeD7nCM/nHeH5dkd4vsMRnu90hOe7HOH5bkd4vscRnu91hOf7HOH5fkd4fsARnh90hOeHHOH5YUd4fsQRnr/kCM+POsLzY47w/LgjPD/hCM9POsLzU47w/LQjPD/jCM/POsLzc47w/LwjPL/gCM8vOsLzS47w/LIjPL/iCM+vOsLza47w/H+O8PxlR3j+iiM8v+4Iz191hOevOcLzG47w/HVHeH7TEZ7fcoTntx3h+RuO8PxNR3j+liM8v+MIz992hOfvOMLzdx3h+XuO8Px9R3j+gSM8/9ARnn/kCM8/doTndx3h+SeO8PxTR3j+mSM8/9wRnn/hCM/vOcLzLx3h+VeO8PxrR3h+3xGeP3CE5984wvNvHeH5d47w/KEjPP/eEZ7/4AjPf3SE5z85wvNHjvD8Z0d4/osjPP/VEZ7/5gjPf3eE5384wvPHjvD8T0d4/pcjPH/iCM//doTnTx3h+TNHeP6PIzz/1xGeP3eE5y8c4fl/jvD0OtzgmXCEZ4cjPDsd4dnlCM9uR3hOcYTnVEd4TnOEZ48jPHsd4TndEZ4zHOHZ5wjPmY7wnOUIz6QjPGc7wnOOIzznOsJzniM8j3GE57GO8JzvCM8FjvA8zhGexzvC8wRHeJ7oCM+THOF5siM8T3GE50JHeC5yhOdiR3gucYTnUkd4nuoIz9Mc4Xm6IzyXOcLzDEd4LneE5wpHeJ7pCM+zHOF5tiM8X+EIz5QjPNOO8Mw4wjPrCM+cIzzzjvDsd4TngCM8C47wHHSE5ysd4fkqR3i+2hGer3GE52sd4fk6R3iudITnOY7wfL0jPM91hOd5jvA83xGeFzjC80JHeF7kCM+LHeF5iSM8L3WE52WO8LzcEZ5XOMLzSkd4XuUIz6sd4XmNIzyvdYTnGxzheZ0jPK93hOcbHeF5gyM8b3SE55sc4XmTIzxvdoTnmx3h+RZHeL7VEZ63OMKz6AjPIUd4DjvCs+QIz7IjPCuO8FzlCM9bHeF5myM8b3eE5x2O8FztCM87HeF5lyM81zjCc60jPNc5wnO9Izw3OMJzoyM8NznC825HeN7jCM97HeF5nyM873eE52ZHeD7gCM8HHeH5kCM8tzjCs+oIzxFHeG51hOc2R3hud4Tnw47wfMQRnjsc4bnTEZ6POsJzlyM8dzvCc48jPB9zhOdeR3juc4Tnfkd4vs0Rno87wvMJR3gecITnQUd4HnKE52FHeD7pCM8jjvB8yhGeTzvC8xlHeD7rCM/nHOH5vCM83+4Iz3c4wvOdjvB8lyM83+0Iz/c4wvO9jvB8nyM83+8Izw84wvODjvD8kCM8P+wIz484wvOXHOH5UUd4fswRnh93hOcnHOH5SUd4fsoRnp92hOdnHOH5WUd4fs4Rnp93hOcXHOH5RUd4fskRnl92hOdXHOH5VUd4fs0Rnv/PEZ6/7AjPX3GE59cd4fmrjvD8NUd4fsMRnr/uCM9vOsLzW47w/LYjPH/DEZ6/6QjP33KE53cc4fnbjvD8HUd4/q4jPH/PEZ6/7wjPP3CE5x86wvOPHOH5x47w/K4jPP/EEZ5/6gjPP3OE5587wvMvHOH5PUd4/qUjPP/KEZ5/7QjP7zvC8weO8PwbR3j+rSM8/84Rnj90hOffx8SzA3hmU/25XHkgU05n08VUZnCokE/l8kP9hXQhnS/kS5lCNlsu5AoDg0ODA6nBdC5bTlfyg9mKj32aYpn/YYLKnGrNpf+xQ09+s7vcqOcuRfn9kyO63a1Y5h85UuYpimX+Z0fKPFWxzP/iSJmnKZb5Xx0pc49imf/NkTL3Kpb53x0p83TFMv+HI2WeoVjmHztS5j7FMv+nI2WeqVjm/3KkzLMUy/wTR8qcVCzzfztS5tmKZf6pI2Weo1jmnzlS5rmKZf4fR8o8T7HM/+tImY9RLPPPHSnzsYpl/oUjZZ6vWOb/c6TMCxTL7HW6UebjFMuccKTMxyuWucORMp+gWOZOR8p8omKZuxwp80mKZe52pMwnK5Z5iiNlPkWxzFMdKfNCxTJPc6TMixTL3ONImRcrlrnXkTIvUSzzdEfKvFSxzDMcKfOpimXuUyyzgXphv8v3/QKvMP5M488y/mzjX2HzMD5tfMbKwfic8Xnj+40fML5g/KDxrzT+Vca/2vjXGP9a41/nl/sc419v/LnGn2f8+cZfYPyFxl9k/MXGX2L8pcZfZvzlxl9h/JXGX2X81cZfY/y1xr/B+OuMv974Nxp/g/E3Gv8m428y/mbj32z8W4x/q/G3GF80fsj4YeNLxpeNrxi/yvhbjb/N+NuNv8P41cbfafxdxq8xfq3x64xfb/wG4zcav8n4u42/x/h7jb/P+PuN32z8A8Y/aPxDxm8xvmr8iPFbjd9m/HbjHzb+EeN3GL/T+EeN32X8buP3GP+Y8XuN32f8fuPfZvzjxj9h/AHjDxp/yPjDxj9p/BHjnzL+aeOfMf5Z458z/nnj3278O4x/p/HvMv7dxr/H+Pca/z7j32/8B4z/oPEfMv7Dxn/E+F8y/qPGf8z4jxv/CeM/afynjP+08Z8x/rPGf874zxv/BeO/aPyXjP+y8V8x/qvGf834/2f8Lxv/K8Z/3fhfNf7XjP+G8b9u/DeN/5bx3zb+N4z/TeN/y/jvGP/bxv+O8b9r/O8Z//vG/4Hxf2j8Hxn/x8Z/1/g/Mf5Pjf8z4//c+L8w/nvG/6Xxf2X8Xxv/feN/YPzfGP+3xv+d8T80/u+N/wfj/9H4fzL+R8b/s/H/Yvy/Gv9vxv+78f9h/I+N/0/j/8v4nxj/38b/1PifGf8/xv+v8T83/hfG/5/xtoEljO8wvtP4LuO7jZ9i/FTjpxnfY3yv8dONn2F8n/EzjZ9lfNL42cbPMX6u8fOMP8b4Y42fb/wC448z/njjTzD+RONPMv5k408xfqHxi4xfbPwS45caf6rxpxl/uvHLjD/D+OXGrzD+TOPPMv5s419hfMr4tPEZ47PG54zPG99v/IDxBeMHjX+l8a8y/tXGv8b41xr/OuNXGn+O8a83/lzjzzP+fOMvMP5C4y8y/mLjLzH+UuMvM/5y468w/krjrzL+auOvMf5a499g/HXGX2/8G42/wfgbjX+T8TcZf7Pxbzb+Lca/1fhbjC8aP2T8sPEl48vGV4xfZfytxt9m/O3G32H8auPvNP4u49cYv9b4dcavN36D8RuN32T83cbfY/y9xt9n/P3Gbzb+AeMfNP4h47cYXzV+xPitxm8zfrvxDxv/iPE7jN9p/KPG7zJ+t/F7jH/M+L3G7zN+v/FvM/5x458w/oDxB40/ZPxh4580/ojxTxn/tPHPGP+s8c8Z/7zxbzf+Hca/0/h3Gf9u499j/HuNf5/x7zf+A8Z/0PgPGf9h4z9i/C8Z/1HjP2b8x43/hPGfNP5Txn/a+M8Y/1njP2f8543/gvFfNP5Lxn/Z+K8Y/1Xjv2b8/zP+l43/FeO/bvyvGv9rxn/D+F83/pvGf8v4bxv/G8b/pvG/Zfx3jP9t43/H+N81/veM/33j/8D4PzT+j4z/Y+O/a/yfGP+nxv+Z8X9u/F8Y/z3j/9L4vzL+r43/vvE/MP5vjP9b4//O+B8a//fG/4Px/2j8Pxn/I+P/2fh/Mf5fjf834//d+P8w/sfG/6fx/2X8T4z/b+N/avzPjP8f4//X+J8b/wvj/894O5hIGN9hfKfxXcZ3Gz/F+KnGTzO+x/he46cbP8P4PuNnGj/L+KTxs42fY/xc4+cZf4zxxxo/3/gFxh9n/PHGn2D8icafZPzJxp9i/ELjFxm/2Pglxi81/lTjTzP+dOOXGX+G8cuNX2H8mcafZfzZxr/C+JTxaeMzxmeNzxmfN77f+AHjC8YPGv9K419l/KuNf43xrzX+dcavNP4c419v/LnGn2f8+cZfYPyFxl9k/MXGX2L8pcZfZvzlxl9h/JXGX2X81cZfY/y1xr/B+OuMv974Nxp/g/E3Gv8m428y/mbj32z8W4x/q/G3GF80fsj4YeNLxpeNrxi/yvhbjb/N+NuNt9+Wt99tt99Et98bt9/ytt/Jtt+gtt93tt9Ott8ltt/8td/Ttd+qtd+Btd9Ytd8vtd8Gtd/dtN+0tN+LtN9irBpvvyFov89nv31nvytnv9lmv4dmvzVmv+Nlv5Flvz9lv+1kv5tkv0lkv/djv6Vjv1NjvwFjv69iv11ivwtiv7lhv2dhvxVhv8Ngv3Fgvx9gz+a3597bM+Xtee32LPS3G2/P8LbnY9uzp+25zvbMZHsesT3r156ja8+otee/2rNV7bml9kxQe96mPcvSnhNpz2C05xvaswPtuXz2zDt7npw9q82eg2bPGLPnd9mzsey5U/ZMJ3tekj2L6GvG2zN07Pk09uwXe66KPbPEngdiz9qw51jYMyLs+Qv2bAN7boB9J9++727fJbfvadt3oO37xfbdXfterH3n1L7Pad+VtO8h2nf87Ptz9t00+96XfafKvq9k3wX6S+PtOyz2/RA7zrXvNdh3Bux+fLvX3e4jt3u07Z5lux/Y7mm1ezztnke7B9DuibN7xOyeKbuHyO6psXtM7J4LuwfBrsnbNWq7ZmvXMO2anl3jsms+dg3ErgnYOXI7Z2znUO2cop1js3NOdg7GzknYZ3T7zGqf4ewzjR3jd7w4dPDsfl3rVnh155sVC/1CuN3favd72v2Pdj+g3R9n94vZ/VN2P5HdX2P3m9j9F3Y/gl2ft+vVdv3Wrmfa9T273mXXf+x6iF0fsPPldv7Yzqfa+UU732bnnxYav8j4xcbb51f7PGefb+z+8dONX2b8GcYv98a6qez6ZP//MT8457h133rf+TzewpAwO6ax7tk5d1dPv8vWdt0t9sO+f8zVTz80fdkveFg6EYyZ8cOeuvIXS47bufPfeVg5IN0U///001783+P/JkI2ma2flf7vVGsu3cNwtfELqWKmxxvtlPlnexhmDPgZwu+KBz9Fuvv26mh8D/Lt838nmCwpDYVxpX2HHzbND6frLf51D+DFUe+ck7bc5gr8O1jZrDu3GkfemWHCP8/H90ZhV3ID2dJAsX94qFAayg7nioWBXHGgmB/sT6dLxVRpcDA1lBlOFQcqBTPJU66kh8rl9PBgsZIq5ItZwj6fcVd8tyJF+BfEg1+zJxfGg1+zJxdVJdlny0MDqWy+2F8YSleK/ZXUUG6gkC1WBgZKxdKgmWvLp0rp4f70cCZdKRSK+XxxOD+YTlfKg/lKoZ+wLxaxy4XC8ODQQCVVKVYGM2a+LpUZGi5V8mYSb6BQKQ/nK5VsbjCVzxZKxeHSwHB6cDhbyFSGy4OV1GCtXi8RsUuZfLEyXCoN5VKVwexAcaBgdGdwYMgAFNLZ/nRxeNDoVCVdLg4PDA8VyymTVzldLA2kSwPZPGFfymSup+91/Mtiwa/rzOWx4GeGCP+KqiT75rjiDcK+Mhbu6Rr+VfHUbU02V4uyKaSLxn6VSrl0oTRcyqbK2YqxXIVirtSfLtimlS0MlbL5gbIxeOlCcSCTL+f7i0XTxorD6Vq9XiNilzMDuVx2MD2QSw/0l7L95VKqMFwplMxceDo9lC6VKhVjN4dMo630Dwz2m3ZVHi4PlAtD/abx1trTtSJ2a46w38BknvD09f26ePBrNvL6ahw6k6rJ/o3VsbJPF7KZzEDWrlcUSql0rjScKWQy1rAZxRnOlAdz6cFKLpPLDpdMB5krFNPWoA4PVgovghP2DfFwr8nmxnjwc4T/pmosdVuT/U3x8K8Q/s2x8M/W+tg3x8I/W5P/W3x8T082tX7wrcHY41Z/wr5FwM4Us8MpM4oo5o2JLZtFwlTZDB/LQ4VypT9THBrOpTKldDpdzpk/mXIpNzhkzPNQv1lZzA+Z7GptqhiLzNO18fCQMn5/MTVY7u8fIPxhZfyhof6BopEn4ZeU8bPD/eVKdqBmc8rK+MV8rlLJZ4uEX1HGz6dT5XxmoKabq5TxB4dS+X4zqib8W5XxzRg/Wxos1sY4t2nLZ6icGi6lB+n5+nYfn/KwjvK+Qzlv3w0mID/PGz1/4EH+vcBVeyyfgPw4Hy4felYn2a2ujuWaFMK4jcGwTuEe5SNhDStilRSxyopYFUWsVYpYtypiUbuOt63lav3o6ljwswXCvzMW/FSZ8O+KAz9dH7uvYfieHv8a/lqGn4gBf1088q/hr49HPrXnyg0+fhzYG/Wxa+OjTfHIvTa+uzse/NozzT3x4NfGv/fGg1+zO/fFgz9I+PfHg18b/26OB782fnwgHvza+PfBePBLhP9QLPjpmny2MHw9u5yp2c1qPPg1+YzEgp+t8d8aD37NNm+LBT9Xw98eD37NPj8cD37NPj8SD35tXLUjFvx87fl7Zyz4/bX6fTQe/Fr/vise/Nqc6O548Gtzinviwa/p/2Px4Nf0f288+LXxyb548Gvjk/3x4NfGJ2+LB7/WPz4eD35t/PBEPPi1/vFAPPg1+3kwHvya/TwUC/5ArX8/HA9+zX4+GQ9+zX4eiQe/Zj+fige/Zj+fjge/Zj+fiQe/Zt+ejQe/Zt+eiwe/Zt+ejwe/ZPeb2r1r0497EU/a86c43krRfjrae0d58Ly72X3FZ6lSlPl8nn8vcI1jPp/nR3xQPnw+34ZNEbgmhTCswylCPlOEfJJCGI7PWsE6rIj1mCLWQUUszTI+oYi1XxHrgCLWXkWsLYpYmrLXbENPtinWTkUsTZ3QlL2mfu1WxNJs25o6sUsRS9NGP62I1a79I417ezx5fLDS/51q0RH+tHjwsySLqSGy4PnTWImPrRIB/wkLwyivXsBSLls6rGycP9bzVMaHyyAIa2qTWD1CWBx1OiWk3Jh/UHxpvEzxe0LwefxZ3lgd7gFZ9MYji0xYvfH3yCj/GYxnqTy0adVla1Z54ILG/ydCPFqT7/DGyntaAJYHv0+Ee50MjzvLe5Z/XSlvHL71DcVVq8olw34DxByT9LyqfB8fi3icmFU4M15TEpMZTkcxk9aRytvqmO5fr15TLJ1bXLth0+pyB4iSPwGjODkcFhurKsEoeSHxzquO/k1vx3R6wY5ESXjTWJgkAsKkVh+k9VhdXUK+dK9DiD8VsKYK6Yh7Z0h6jsHToSqFNYco6krlsE6aVcC3JsNmcuJpdunseJtd3DM5YXXF5RrvaCmdCWsD0wT5UF32CGGERT1Ptyf3TNNYGbGn7GU8uuHev/j/k4BpHb2BFNaT83skX6uvfw9l43WDehpPPeTSUfWU8u/1Yu2u0mF6IY0Oe7yx9ay56zNKvXK+VJe9QhhhUXfG9ZTH52/98/j8mtLzez/3/ye9sTqNetorlIff43r6E/+6J6A8K/3fqZbcwAC2ccqD5x3P6DY9HLUdUP69Xpx6V28HUj1J9oRkN13gmhTCcLQ8XchnupBPUgjD2YBWsA4qYu1SxNqjiPVkm2LtV8Q6oIi1VxFriyLW44pYmnrfjvIK6webxbJOU1ePKGLtU8TS1FXNMu5UxGrXtv2cItaIIhbtssBxJuFb1+ONbXvaz248PyoHv8fz7wWuunzqYyVJrtKYluQzIx751PjMEPjMEORDddknhBHWTP83f2bg8WewMvL4/JrS83sX+hWWBEzr8JmhTygPv8efGc5JjC4brxvU0zjrgedHvPk9nn+vF2e7SYXqhdT+e7yx9awon1SUeuV8qS5nCmGERTPnXE95/D5WRh6fX1N6fu860FOu06inM4Xy8HtcT68EPeV1g3oaSz2kK5H1lPLv9eJsN3U9lfRihiDHHm9sPSvKJxWlXjlfqstZQhhh0ZvEXE95/JmsjDw+v6b0/N4w6CnXaXxzdZZQHn6P6+mbfdyegPKs9H+nWnL5nFSXevgD6T6hnNjOuKz19DobuZ1R/r3eWL2Io50lgU+QHpDsZgtck0IY6shsIZ/ZQj5JIQyfa1rB2qOItUURa5ci1uOKWDsVsfYrYj2hiKWpE7sVsXYoYj2phCXZ51Z4HVbiZd0RRSzNtv2cIpamLdRsjwcUsTTr8XlFLE2d0JS9Vtv2lMuoqRMHFbHa1U5o8no5jJkm+7SjJ3vN9viYIpZmGZ9pU16a4wnNMuL6AH+2TPj/e7yxbU/xOZs+blHLj8rB7/H8e4GrLp/6c7Yk16QgV5LdHIFrUgjD5+w5Qj5zhHySQhj2Ga1g7VHE2qKIpVnG/YpYBxSxjihiacr+OUWsyXpsDut5RSxNnditiHVQEUvTfj2piKUpe01d1ZR9u9ovTV3V1K8nFLE061FTvzTbkKZ+HVbE2qmIpVnGdh3LaZZRczzRrvXYrmO5ZxSx2nWcoznGnBxPvDTakKad0OSlpV/2GudVW+H1lBIv6zRlrzkGoL4W97sRvnXxzqFlIu+xxTm0WPZgNZhDk/bW9Xhj9VBRPuko9cz5Ul3OFcIIa57/m+8J4/HnsDLy+Pya0vN7b/SFkgRM63BP2FyhPPweydfuCbva/9ETUJ6V/u9Ua66A86GUB8+by0lR7yJ94Ybn3+vFqXf1diDVk2RfSHbzBK5Jb6zuoD7ME/KZJ+QzidVeWG9QwgqzYRRuXY+QTtve8vyoHPwez7/Xi9UupMPkKtlLks8x8cintkf5GIHPMYJ8qC6PFcIIa77/m/dHPP4xrIw8Pr+m9PzeZuiPjmVxsQ0cK5SH3+P90aaO0WXjdYN6Gk89RH/ng/Lv9eJsN3U9lfRCav893th6VpRPKkq9cr5Ul/OFMMJa4P/mesrjH8vKyOPza0rP7z0Kesp1GvV0vlAefo/r6Tb/xywvuH1Gac8cV7LbKEOeDttDLPWdLqeitgfKv9eLs33W28OxEeVK8pkfi3xKlSj6w/lSXS4QwgjLP6h6VHvg8eezMvL4/JrS83tPQXvgbQfbwwKhPPwebw8HwG7zukE9jaUeUqlKVD2l/Hu9OO1kXU8lvZD6vx5vbD0r8ilHqVfOl+ryOCGMsI73f3M95fEXsDLy+Pya0vN77wc95TqN7+odJ5SH3+N6+k543sXyrPR/p1py5bRUl3r4xdpJpMfFgp8Z7BHqSw9/qED4J8SD30/4J8aCX6jV70mx4Odr8jk5HvwS4Z8Sj/7U+C+MBT+bJfxFseCXa/wXx4Kfq+EviQV/qNZ+l8aCP1jT/1PjkU+tfk+LBb+SJ/zT45FPjf+yePjX7P9yhq85F0H4Z8aCXz8VeYVXd51CmSh/GoucweInAv4TFoZRXr2AFde4Tyob54/PfSsYHy6DIKwVTWL1CGFx1OnykHLz/PtCuGI5rMMzcMYrE+t2K2I9ooh1WAlLGtu2wmurIq8FSryk8W8rWMcrYnUqYVm3varH6wQlXvb6xDbFOkkR62RFrFMUsRYqYi1SxFqshGUdfs2uFV5LFHkdqurxWqrEy16fqoil1XfY69MUsU5XxFqmhGUdzp22CxatIcc735UbjHe+K1uMd74rV4p3viufjXe+KzcQ73xXLhfvfFRumJ4FqI+kPLjuLmT39Z5bcpHfNaX8e4GrLp/68+NC4IPywf1BiwSuSSEMbcAiIZ9FQj5JIQz3CreC9bQi1k5FrMcVsfYrYu1WxNqiiPWEItYeRawn2xRLU1f3KmJpyd5e47igXXRVsz0eUcRq1/b4lCKWZhtqV9nvU8TStBOafa2mjdaUvaa82lW/NMcmmvWoKfuXg514TgnLXuMzciu8tlf1eB2vxEsTy7ptVT1eJyjy2l7Vw9qhiKXFy17jXH0rWJ1KWNZp6YR1jyhh2Wuc32mXetTkpaWr9rpdbWGfIi9N+6VZj5q82lFe1mnqKs6ttoOuWqdlv6x7XhFLc/z1mCKW5pyC5phc81lBc+6Rxvc0j30SC0v4/+NdA0iNew3gpHj4hK4BnCTIVdoPq8inFKWeOV+qy8VCGGEt8X/zdwd4/EWsjDw+v6b0/N4X/IpLAqZ1+O7AYqE8/B7J17478KnO0WVbyOKhnsZTD9G/MUv593qxtpt0mF4sFOQo6QWlTQphOKaPWl9S3ePeulawDipi7VLE2qOI9WSbYu1XxDqgiLVXEWuLItYhRSzNNqRZj08rYu1UxDqiiKXZtjX1S7MNadrVl4Psn1DE0rTRZAvp/fhFXh272xudzyIhn0Uh+fD0FC/e98HymXjfB8v3x/s+WK5C466lTK4JkB3fp6k3RixEPk+D8u8Frrp86mPW04APygfHrKcLXJNCGO6vOl3I53Qhn6QQhra1FaynFbF2KmI9roi1XxFrtyLWFkWsQ4pYhxWxNGXfrrp6RBFrjyKWpn5p2pyDilgvB9k/oYilWcYn2xRLs23vVcTSkr29xr2T7aKr7ToG0MSa7Lcn+21X+o7Jfnuy357st1+asm9XXX1KEUtTXpo2R1P2+xSxNNuQZr/drja6XccTmmXUHPtq1qOm7F8OduI5JayEN3YPRStYixSxtObJ7fViJSzrtlX1ePUp8tpe1cPaoYj1iBKWvV7i6WG91GVvr3F/eytYxytinaCEZZ2mvE5V4qWpq9ZptqF21ft2LeNL3RZq8rJusu9wv++w7mElLHutuedhe1WP18lKvOz1iYpYWn2tdZr9o5a8rNte1cPStF/PK2JpPvM9poiluaajOQ+gOT+huT8H30Hie8MS/n/pzHCbz0r/d6oll4n8bgfl3wtcdfnU98lJcj1NkCvJbpnANSmEoT1dJuSzTMgnKYShvreC9aQi1i5FrIOKWE8rYu1RxDrcprx2K2JtUcR6ThFrRBHreUUsTXkdUMTSbI9HFLE09V7TFmrW42OKWJo2R1MnnlDE0pT9zjbldUgRS1MnNMcmmv22Zj22q/3S1C/N9tiuNloTS1O/9ipikezxvR7Ct076fpPis14uAflROfg9nn8vcNXlU3/Wk+QqPUOT7JYLXJNCGK5BS98IWi7kkxTC0Da3goX9dStYuxSx9ihiPdmmWPsVsQ4oYu1VxNqiiHVIEWunIpZmezyiiKWpX5ryelwRS1O/NNuQpl3V1AlNu9qubVuzPWq2oacVsTTb48tBv55QxNIcA+A5EXy8jedENDvm5+kpXp+QLuH/j/ebqoORz0Gg/HsFmcQx5l8eUa7NfK/TXmt+fxL7plawnlbE2qmI9bgi1n5FLM1vpW5RxNL6Dp91Wt9dtU5T9u2qq0cUsfYoYmnql6bNOaiI9XKQ/ROKWJplfLJNsTTb9l5FLC3Z22ut70Zbp6mr7ToG0MRq135bU/aaYwBNG605nmhXXZ3st49enzY5Jm8Oa3JMfvT0a3JcePT0qx3HhdZpyqtddfUpRSxNeWnaHE3Z71PE0mxDmn1Hu9rodu3TNMuoOfbVrEdN2b8c7MRzSlgJb+wep1Z4bavq8VqkxMte9yliaa4PacrrZEVeO6p6WI8oYdnrJZ4elpZOWLe9qoelJXvNtq3dHrXakL1erIRlnWZ7fDnoF57j0grW8YpYJyhhWacpr1OVeGnaQus0bXS76n27lvGl3tdq8rJucmzift9h3cNKWJrjCeu2V/V4aY3J7fWJilhafa11mv2j5jPM9qoelqb9el4RS3NO4TFFLM11K815Js35L839hXiOC9/bmvD/93hj24vNZ6X/O9Wai3yOC+XfC1yV+aTD5Crt0yb5nBkPn6EE4HM+Zwryobo8SwgjrLP93/xb0jz+mayMPD6/pvT83p9NefF/EjCtw29JnyWUh98j+VrIP5wyumy8blBP46mHdCmqnlL+vV6s7SYdphdS+5f0gtImhTCcw4laX1Ld496EVrAOKmLtUsTao4j1ZJti7VfEOqCItVcRa4si1iFFLM02pFmPTyti7VTEOqKIpdm2NfVLk5dmPWry0rQTmjqhWY9PKGJp2nt835CPrfB9w7DxqZQPT0/x+oR0NLbq8eQxykr/d6olV8gnID8qB7/H8+8VZBLH+O6siHIl2Z0tcE0KYTh3dbaQz9lCPkkhDNtoK1hPK2LtVMR6XBFrvyLWbkWsLYpYhxSxDitiacq+XXX1iCLWHkUsTf3S5KVZj5q8NO2qpk5o1uMTiliasn+yTbE07cReRSwt2dtrfHexXXS1XccTmliTY4DJMUCcdnVyDDA5BpgcA0yOARphacqrXXX1KUUsTXm1q53Yp4il2Ybate9o17Fvu+qX5jhasx41Zf9ysBPPKWElvLH7IFrBWqSIpTV/b68XK2FZh++ytMKrT5HX9qoe1g5FLC1e2vWoxcu6R5SwtHVCqx7t9XFKvOz18YpYJyhhWacpr1OVeNnrJUpY1rWrrm6v6mG91NujdhnbUb+sm+yHJvUewx5WwrLXmntEtlf1eJ2sxMten6iIpdVvW6fZ12rJy7rtVT0sTVv4vCKW5rPoY4pYmutWmvMTmvMmmvuZ8P2mThaW8P/TvkJuz228lf7vVGsu8rfLKP9e4KrMp7avsM8bK9dOQa4ku/kC1ySEWYfv+cwX8pkv5DNRWFJ9W7/S/51qyeXzfULeqGt8f4Ne3aYLUXWN8u/1xtZtHLq2APgE1RvJ7jiBa1IIwzo8TsjnOCGfpBCG66ytYL1NEUuT10ElLHs9zdPB0i7jFkWsJxSxnlTE2quIpSmvI4pYzypiHVLE2qOIpSn7/YpYuxWxNMv4nCLWiCIWPXvg2MK6lf7/VKqSG8iWBor9w0OF0lB2OFcsDOSKA8X8YH86XSqmSoODqaHMcKo4UCnkC/lyJT1ULqeHB4uVVCFfzMU7dsgP9Hhjbbzi2CRN+MfHg58h/BPiwc8S/snx4Nfqd1E8+HnCXxwPfj/hL4kHfyDe97/SBcI/Ox78QcJ/RTz4RcJPxYNfIvx0PPhlws/Eg18h/Gws+JkU4efiwa/Zz3w8+DX72R8Pfs1+DsSDX7OfhXjwa/ZzMB78mv18ZTz4Nfv5qnjwa/bz1fHg1+zna+LBr9nP18aDX7Ofr4sHv2Y/V8aDX7Of58SCn63Zz9fHg1+zn+fGg1+zn+fFg1+zn+fHg1+zPxfEg1+zPxfGg1+zDxfFg1+zDxfHgz9M+JfEg1+zP5fGg1+zP5fFg1+zP5fHgp+r2Ycr4sGv2Ycr48Gv2Yer4sGvja+ujge/Nr66Jh78mn27Nh78mn17Qzz4tfHVdfHg1+zn9fHg1+znG+PBHyL8G+LBr9nnG+PBr9nnN8WDX7PPN8WDX7PPN8eCn6+ND98cD37N/r8lHvya/X9rPPg1+39LPPg1+1+MB79m/4fiwa/Z/2Gv7nSw63PbpTi4pys13S+L3LPloYFUNl/sLwylK8X+SmooN1DIFisDA6ViaTBXHsinSunh/vRwJl0pFIr5fHE4P5hOV8qD+Uqh1m9VGPeEmmwKNe6rYsFP1fTy1lhkX6rZtdsE2Wdypf6hYmqgMlAsFiqmE8qUzL9+I/lKPlMczA4XTU2UhspFs9wzmBkuZUrZcsG01XJ2sL9crtv828V6bYV3qib3O7SxU9laX7taxC4XCsODQwOVVKVYGcwUzdxoZmi4VMmn+o00KuXhfKWSzQ0aMRRKxeHSwHB6cDhbyFSGy4OV1GCtPu8UsUuZfLEyXCoN5VKVwexAcaBg5Ds4MGQACulsf7o4PGjW2CrpcnF4YHioWE6ZvMrpYmkgXRqoP+PeFYsu1tcQ1qjrYuGFv/YY5E/7Gy/oTL61LK8pUK51/m8659m6ddV6nLUsnMf/1KwX/1u8z/v5RdlD16Ve7hfkOpiA/DxP3tdE+U/UHrou4IPywX1N3QLXJIRZh+vc3UI+3UI+EtbzilhbFLEOKWLtUcQ6oIi1WxFrvyKWZhn3KmK1q37tVMQ6rIh1RBFLU7805fW4Ipamfmm2oYOKWJo6oWlXcS8+D8NxBB/HKPbbmajjCMq/1xvbb8cxjpjiRZPrDOOn+9er1xRL5xbXbti0utwBouTDMBQnh8Nic7HwMBzyYbyLqqN/X1Ydm84TsDsZXg8Lk0RAmDTs5WXqCUjHZeEJ9zqE+FMAa4qQjrh3hqT3vNjVuTbt0BsPfjasbniZKP8+b6zMEwH/CQvDKK9eT5b5SiXZhZWN80eT1sP44OOWhNXTJFaPEBZHnU4JKTfPvy+Eq1QOPBZe6jKkRySK3xvCi8efJeRNaUmG01mYdjcSJEPeFil/a7bpdYlSeWjTqsvWrPLAdYIcSG4LIB7ZwQ4v3A5yLA9+L4B7nQyPu7BH/ijtmXhalxSwaCpickhQc5NDgpf2kEAytahKPd7Ysq70/6dacen6SsUUEbuQLuaKhVIply6UhkvZVDlbGU4VC0UzzZ0u2EWFbGGolM0PlEsDxXShOJDJl/P9xaJZXSgOpzMWc5EveMk8o1kiU8m/QtcjyLYb4t/MZidP9RPYZpD0w4c2rb7jmvLG9beV7y4bS7vBA9dId6+ujv59TXVsOsmFDX/a1YzFPbwK033rmjRjqEJxmzGqenJaZqxLwIxixrC6pHyt6xDih5kxnCjvDElvXZ9wD1U9phFsZFXHJ4m4nsLC6pnLp0VV5+LkcFjso9ljS4P3KQJm2OA9TD094V6jgXBYL9QZkF9PSH7UG0lNoxvivt4HirlJpOYwXCzDZK9Uc5O90ku7V+oU0iG3VueoqBzWJb3g8vd4Y+Wx0v+fSpUzA7lcdjA9kEsP9Jey/eVSqjBcKZSy6WI6PZQulSqVXHFgKFceqPQPDPbns4XycHmgXBjqz6QrOanZJjy9V4Us7nUhA3l8mMSBvHV8m0EPC+fxb/IDbH43soE8vWJ7d3H1baXixvL5d63bVN5ULl2xZmN5wzl3lc6/u3zXxqaH9RdXR/++pDo2neSsASApzGb4KAVuhDshvnXUoij+XP/+FK/OgcehtN0Q/xZfUnZGabb/trakicSnD9JTuHWkSfOA+0r/d6o1F7kDoPx7gWtcHcA84IPyabID4GqB4uRwWOyj2QEcw8IkEWAHwMt0TEA6VHm81yHEnwdY84R02AFI6TkGT4eqhM2Pzz7MEfLG5reONb95xwXnO8cbKwdsgp1CftRcj4G41lFzPRYwVvq/Uy25/EDU5kr59wLXuJrrscAH5dNkc+UqxuGvBziKw+Nydz2j5AXEk6p9SEiHDscrx0KYdaQO8RzflY5svSn/Xi9O9ayrg3QMHJdPB8gnpuPWQo83WyDIh+ryJCGMsE7xf3OzxOMvYGXk8fk1pef3dvhmKwmY1uExeycJ5eH3SL525DLSMzo/altPsrHdozCW5O2P60qQOZ8n5J0U0lM8KZ+pLeYzVcgH10atW1MdHdYbEsbXJ48FzBksHa6T8eOFroWwmQxzKmDOCsFMCpi27s6cXsez/nQWTzLFOGw4jfHhafnvbohr3Ybq6DCK+36mV8+CXvFuCOv7mAa8w+qb4pGsuJ5gnfL2jHXK7QTKX2qPFHaKUC4KWxiCuVTAtHJbMn10PC537FtOZ/cVhxr9UfsWyr/XG6tPcfQtkn5z+WDfsiwe+eQTgM/5LBPkQ3V5hhBGWMv937xv4fGXsTLy+Pya0vN7n4G+5QwWF/uWM4Ty8Hu8b/lYz+iyof2Q/hMu3sP2zWVD9SuNtahNWT5f7BldFkrH5cn7oyIL5/EvZguYXwmxYVh/p0EZG9neY4UyRrXjNwDWaSG8ljXAuh6wePplgHVGA6wbAYunPwOwljfA2gRYPP1ywFrRAOtuwOLpVwDWmQ2w7gEsnv5MwBpugHUvYPH0w4BVaoB1H2Dx9CXAqjTAuh+weHp8FXFVA6zNgMXT42uHtzbAegCwePpbAeu2BlgPAhZPfxtg3d4A607A4ulvB6w7GmDdBFg8/R2AdWcDrCsBi6e/E7DuCsGy13T05CwhPaXtE7DIzsf3+t0LQ4TIz8OUfy9w1eVTH7Os8cbKlcsHX0NbK3BNCmH4bLZWyGetkI+EdZoi1umKWMsUsc5QxFquiLVCEetMRaxhRaySIlZFEWuVItatili3KWLdroh1hyIW9j9h42d7TUcTh42fKR23QTjfic+NPD7HCBqf82WK0xtwPgE4j3ecbq9PBqzxjtPt9SLAGu843V4vBqzxjtPt9RLAGu843V6fBVjjHafb67MBa7zjdHv9CsBqZZz+UHU0Vivj9CJgjXecbq9T3mis8Y7T7XUasMY7TrfXGcAa7zjdXmcBa7zjdHudA6ywcfqaBlh5wOLp1wDW2gZY/YDF068FrHUNsAYAi6dfB1jrG2AVAIunXw9YGxpgDQIWT78BsDY2wHolYPH0GwFrUwOsVwEWT78JsO5ugPVqwOLp7wasexpgvQawePp7AOveECzrLq+OxuLp7wWs+xpgnQtYPP19gHW/F17G10IZefr7AWtzA6zXARZPvxmwHmiAtRKwePoHAOvBBljnABZP/yBgPdQA6/WAxdM/BFhbGmCdC1g8/RbAqjbAOg+wePoqYI2EYFn35upoLJ5+BLC2NsC6FLB4+q2Atc0LL+P53mgsnn4bYG1vgHUBYPH02wHr4RAs61ZXR2Px9A8D1iMNeF0IvHj6RwBrRwOsiwCLp98BWDtDsKy7qjoai6ffCViPNuB1MfDi6R8FrF0NsC4BLJ5+F2DtboB1KWDx9LsBa08DrMsAi6ffA1iPhWBZd0d1NBZP/xhg7W3A63LgxdPvBax9DbCuACyefh9g7W+AdSVg8fT7AettDbCuAiye/m2A9XgDrKsBi6d/HLCeaIB1DWDx9E8A1oEGWNcCFk9/ALAONsB6A2Dx9AcB61ADrOsAi6c/BFiHG2BdD1g8/WHAerIB1hsBi6d/ErCONMC6AbB4+iOA9VQDrBsBi6d/CrCeboD1JsDi6Z8GrGcaYN0EWDz9M4D1bAOsmwGLp38WsJ5rgPVmwOLpnwOs5xtgvQWwePrnAevtDbDeClg8PaXtE7AS/n9aM3oHu6+3RpNLJyA/Kge/x/PvBa66fOprRu/wxsr17ewerhm9U+CaFMJwzvGdQj7vFPKRsJYpYp2hiLVcEWuFItaZiljDilglRayKItYqRaxbFbFuU8S6XRHrDkWsOxWx1ihirVXEWqeItV4Ra4Mi1kZFrE2KWHcrYt2jiHWvItZ9ilj3K2JtVsR6QBHrQUWshxSxtihiVRWxRhSxtipibVPE2q6I9bAi1iOKWDsUsXYqYj2qiLVLEWu3ItYeRazHFLH2KmLtU8Tar4j1NkWsxxWxnlDEOqCIdVAR65Ai1mFFrCcVsY4oYj2liPW0ItYziljPKmI9p4iFc46N9snd4l+H7ZOjdEHvY3WyONLeOI4RtA+vk3FutB+vCJylPKX3G9dXR4fx9xtxTz5/5xnffeTvMOP7Vvz9xrdD2EIWhu+6LWVhVB7p/caekPLw83rxvV7+fi6+wz2DhS2AsD4WdhKE8fdzT4GwWSxsIYQlWdhSVlZ6P7cbyvoK/37MJ7yIR4+FvR+dCPjveWPnxa3DdsvPIUpAPvMU8+FYdDRe2NEc482Ht9EOKM+xivnguxw8nwVCPqQ3vN0q6k3kd2ko/15vrI2JY11EOvtggSDXiEeN4PEOXJwcDovNxcLDOuEextM4GYgfIyGJAF8z5WU6JSAdl4Un3OsQ4p8EWEHHZnQG5CdVJU+HqpSA+0EnA81n4Tz+pb4+2JOB5h9Xjx+UF5cHHg5G3IMOB0MOFP9KxmH2cTJmV0C5FgRgDk2vc7lmuozpCZhSuU6BciGHk4ADxb+elet4OHXpFCG9F3CP5O8JafG3pDNzIP7CBuXBeqL4N4fU03yBA2+TKNOFwAHjnBLA4RaBAzdrw2vW3uebNQ8cnp6YgN8ocjwBab6AE+RIDLZ4pIqdgIsmCvPhOMjJFplGbKXy6vLGckCh0VYnAjLr8GSHQ2jPG9vdxtS9Re5uKf9eT9bFlTp8Qo9O4vLBIZF0FFJSCOOKgQoYls8Mrz6037BxzfogXYjaDycEPpjea4BFvyf1Z/z6E3G4hmrDxcnhsNhBVdZITTQO3Q4b5nBMGq6FDbF4dc0V8qV7HUL8BYC1QEhH3MOGYxyDp5O6RexipS6YH/TI4z/Euj86yBHT0O8yu8aDGif+6SkdeVfZS/TpKQlwFIfH5S7JKHkB8SSVp8MtojTHeA+E6i+Rut0pcMBDMbjsKIxvksEJq7UsrJtdo+sUyk7ltc3opOPquBgPufKmjROJvNmsgTA+Ql8LYQtZ2DoI45OF6yGMvzS9AcL45CttdumGMhyGybaYej1xso3ymuWNlSufwET97hTu4aQRTz83JJ+ZLeYzU8gnZlmm422v9Q/thY1QeP7YLihc+k9YGIajr7iP0Q7rsq3DepZmg8KwFjSJFfMoOItDDqnckn2VuErlwNkPWpxY4j+S2Efgj4QsbuDwI54Pg2YjH95I+fcC17j0Ufr+jPQBTmmBh9Ki7bPu4Wo9HoZ1Cvc6QrAOKmI9pYh1QBFrtyLWFkUszTJq1qNmGXcpYmmW8QlFrEOKWI8rYu1RxDqiiLVfEUtTJzTbo2Yb0tQJTXntVcR6UhFLU/aPKWJpyv6wIpamvDRt4U5FLE15tast1JSXps15OYyZNHVCs9/Wkr29nubpYFmnqfeast+niKWp95pl1LQTmmMATXk9p4j1PGBFfa6n+H1CfGleiuYy+WZOSktzKHxuUntFNUhOfAMp5W85kj0olYc2rbpsDT9vsZaey4Hklod4tCTY4Y21OTMCsDz4nYd7nQyPO/4xyShLZvHMx2Yjr2BT/hO1ZCZtNpfmPaUPfFDapBB2KrvmYTwf6cMbSSEM++1WsJ5QxDqkiPW4ItYeRawjilj7FbE0deKAItYWRSxNndCU115FLE15PaaIpSmvpxSxNHV1tyLWy6EeDytiacpLsx/aqYilKa927Yc05aVp7zX1S9PmaLZHTZ3QHDNpyd5e4xxMu+i9puz3KWJp6r1mGTXtRLuOv55TxKI5GOmFYdwmHfaRSikfnn5ZBCzpeZjirxDih831SB/86PF/8wP04pjrkepjBcuT8h/PXA/JLQ3xcK6H27blAVge/E7DvaC5Hty3dMifTCL5xrQfTdwXifsV+V6opVA+aX6R30P95el7Q/KZ3mI+04V8pA9LU7ljlnMpAflROfg9nn+vIJM45tDmRpQrySemOb3hhDfWXnUKeRJfqssw20rtlb/ewOPjB+F5++b2phvufdBvm0lvrN3Fj/ZGte92rvfdM0aXbbz7WTmu1G9EaQ/jzYdj0QeApddn0I40u4eVp18QgEX1bh19nNSG4wcVqT66BEzr1lTreDz+Z/36sv3NdrZ/38bh+1z5h5A/PyOcK0/LuXZD/BXsQ8hf8jElOVO9S3qAbwH2CvlKmGibm6276QKHMCxeXzMgPj+8RIqPb2ZT/F9jdXc8vEWMH6e2juvPggAOXH/4B/OC9Odb49Cf35gRzhX1Z4Y3Ou/aATJMf74D+sNlHKY/MyCM6w/JSOrb8Z2HZvt2nj5sDHEMhHHux0LYMUK5EhDG+R0Twm+GwIH6T/xY4Ur/d6ol1/w7TjMhjL/jNAvC1rKwJITxg3qxX+EH72K/zQ/SxcN8+MG4CyGMH3Q7A8L4wbX4+il3nfCb14ttizuaeBeL6w2+i8XbIR60TLLiJ0pIbR6fC37E3mf4dt/o/MLGtfyAJEW9y0YZJ/D8J2pcOwv4BNkU6ZAoSpuEMOu2VevxMKxTuNcRgrVFEeuQItZORazDilhHFLH2K2JpyutxRSxN/TqgiHVQEUtTJ/YoYdnrKZ4OlnVPKvGyTlMndiliaerEE4pYmnZVs21r6ap17WpXNXVC035ptiFNndCU115FLE157VbE0tRVTV6T/fbRk5fmeFXTRmuOAZ5SxNK0X+2qE5p2ol37Ic1nGM0yPquINWlXXxr2S7MeH1XE0pRXu9qcdh0XPqaIpdkeNftazXps1/FqVRFLk5emXd2niKVpJ9rVRmvy0pR9u9oJzTH5y+G5VrPffloRS5OX5nOtZj1qtkfNZxjNeV9NLE2dwDZE6578aHnau2IdfQCoG+J/y1+H7oE8Ep7qWnMubF8c5b0wprwTkJ/nyevclL90riru7eRhXS1wHSwP5LOZcildHC4MlYdqeykXAle8h/vBTxPih+0Fjem83gztu+is1vH5h6+s62JhCyGsm4XxM3ZvWzSaf0x7cTJR5M/zTwrxcR9pGJZ1VDdzvNG6xtujtGeE75PAthRPO85G3jNC+fcCV10+9T0jki2dJci4L0TGSSHsRHaN9qtTuBe0d9c6HO+3gvWkItYuRayDilhPK2LtUcQ63Ka8ditibVHEek4Ra0QR63lFLE15HVDE0myPRxSxNPVe0xZq1uNjilia9ahpvzTldUgRa6cilqa8NNuQ5nhCU16PK2JN2tWjZ1e1ZG+v8TyBdtF7TdnvU8TS1HvNMmraib2KWO06Xt2qiEXjVZwrtNf8/ZN459NSmXjnkOrfG5HmtHiZNL8hQ3lN1DdkpLKF6QGf71rIroOwTmsSK955tXqdLvSCy83z7wvhKpUjqSiTkwAr6txSs3U7yxtbn5Q25jZWm+c8KUROPP/xnM1BcstAvBuqdTmgvBcGYHnwOwP3OhkedyRjPv+IH4WXbPIMdg8/Jcl1bS5gHdsA6wbAmhvC66QGWNcDFk+POrywAdaNgCXVSZh+c6xNgMXTB72/H4R1N2BJuklYZzTAugewePozAGt5A6x7AUs6X4awVjTAug+wpLN6COvMBlj3A5Z0zg5hDTfA2gxYPP0wYJUaYD0AWDx9CdKVWBg/U0B6V5a/X79q5mhO0vkM/N3VoC/av3tmHfP2maN58/Q93uiwHhY2DzhzWZCNIhvPz73WtvE8P8+Txz6Ufy9wVeZTG/tI55Rz+VD/GPFzqXikBRcnh8Nic7HwsE64h69m90C68Xy9eCYLi9LlSEejYzouC0+41yHE7wOsPiEdce8MSc8xpGPVsfz8aAu6P0fIuxviP+AX3g5F5sPRH1JeXB4kU9QTOn4E4yAHil9lHGYfJ2N2BZRrRgDmIWZyts2UMT0BUyrXTCgXcqgttUP8Haxcx8OXobm+YhvYUB3NbZaQlxdwj2PztBgWlm+jtPZ6NrvGMElv50B8vgwfRV8p/v4QXZkucODlxXpFDhhnZgCHAwIHblqH16y9zzetHji+m0gyhViVWAXTBZwgR2KwxTs0U8ah32Hqx03YDCGPGQEcedoZ7LpUXl3eWA4QEPYtvQGZdXiyw09yUjrrerxYu+PIwwPKv9eT9XalDp802nHig/LBrRwzBa5JIYwrRjP5zGBxN2xcsz5IF6KOG6T+CtN7kDYh3LOOf2Zkoo5qk/KZ0WI+MyLmE8fxZVI+M1vMZ6aQD2JJjyXW3VGth/P4n2R2fOMiGbMjAJOmCij+KqE80rFYFP9WIf4qoYwkywoLu9VrnDeXJfZ7tzXJ9XYh/m0szirgyvnd3iTXGyaY6wKBa5+QN/YhvFxHow+h/HuFMsbRh4TJ1bomHzG5qqM4ORwWm4uFh2FXMQviXVwd/Xs8j5h3sDBJBPiIyct0R0A6bBJ4r0OIfztg3S6kI+6dIek5Bk+HqiSls79XC2miNJ07AH+l/zvVkkvnozYdyn+imk4jvcHh150C16QQxh8LeRjP504hHwnrFEWsiiJWUhFrriLWsYpYJyliLVTEOk0Ra5ki1hmKWMsVsVYoYp2piDWsiFVSxLpVEWuBIlafItbpgCU99gQNo8bziIzzRbcH5D9PSO9B2gTcmxeARTj2Hh/L4GMH9QtTvPBHnm6IT4Xi06idEAf59An3qDw9Qt5HYwhP+U/UF0IbPXrhOORWgWtSCMP+vhIxHw0dt47G9gmBD6b3ACsh3ONhko7zaQDScVxJ5Wn5Sqq06k7jEmkVvRf4SCvyPP58iL+ccZDi869C8PhzhTYnraZPD8iP8+P3wqaPlgdgBZ3mflwA9+MYd5zWkXYOSFOUFF/aHcD7eeIjyQb78BVCeXh90op+N8Q/RShP2FuhNC3axcIU7UnJ8riH8UC5dldHlztMhtahzIeF+FyWJLMkxOfyl3ZMr4Aw3rZwfCrtyOE7QrHdS1+p4F8oCPsaRTu1+3TEdr80ID/OL6zd8/TNtHvraBcNch9ost0vFfi1U7t/TcR2Tzo12e5bb/dSfx+13fP+/vMBXyYhXI5lw3E+gXhxneFjhiEWzuNfHtIGJBsSNpUutWn+7I1fxeGyXA5hnDs9Ex29PizfL+nyqK9cVaPLwjqUnWRvuI2g+k56Y23LMgjjz5A49yH1U3zHLOor1zPeT30Rljz50irp6+TSes01vbQecVkEu31c0W51WQTjXVQd/Xs8yyJ9LEwSAS6LhO2Wkz5U6An3OoT4MwBrhpCOuHeGpOcYQR9h5OXnO5Xofo+QdzfEv5OZ6nnHBeeLuyOlJlgW8jt6G2XT6ajN1fGNsthcCT4JcBSHx+UuySh5AfGw2q27sjo2HToSZbzf9Gz+m1uopmtYGH7Lai0L62bX6DqFslN5bTM7qYlvWfHmjt+y4s1mDYTxjSprIYyv2K2DML7StR7C+GbLDRDGN03St8LQ1OzwMyYdiOl7U+L3c7GeJ0cPL5nRw9XV0b/HM3qQXhWLOnqYG5COy8IT7rXD6EFKZ39PEdJEaToxvV4b+Xgyyn+imk4jvcHFjHkC16QQhu1inpDPPCEfCQsXEhuNlFtdGEnA7xkB+XcI6b0QLJ4mIfAOWxhBWzTFC28f+H7Ku0MW/6T01k12NWPbS7N7wKVN/0khDPuc3oj5aOi4ddQHJQQ+mN5rgJWIUBb+NIY6TuWc4jX3JPgJQcdJ1p1Ceou/CCZs7mXx8HN797HfnRBfKsf9UA6Mcy+Ug+J/npVjNpSDcyI+fZCewq2jdroZuK/0f6dac5HbKeXfC1zjaqebgQ/Kp8khIVcLFCeHw2IHNY1GzfG86ujf4xkSPsDCJBHgkJCX6YGAdKjyeK9DiL8ZsDYL6Yh7Z0h6jsHToSph8+MTSvcJeWPz+1bIhBLP9z5vrBywCfYJ+VFzfQDiWkfN9UEo00r/d6olly9Eba6Ufy9wjau5Pgh8UD5NNleuYhz+jQBHcXhc7t7IKHkB8aRqXyCkQ0ei7AbO3/fVz1r63/evZ3ljVb0L+HAOYRYvKaSneFI+U1vMZ6qQD05IWUeHwlPYOqGsFLaepVsH6TawsGshbKNQLgrbFIJ5dwjmPUKYrbsrZtfzCjJjXMXRHEsmMGpzwcNcePoHAeuhBlh4mAtP/xBgbWmAhYe58PRbAKvaAAsPc+Hpq4A10gALD3Ph6UcAa2sDLDzMhaffCljbGmDhYS48/TbA2t4ACw9z4em3A9bDDbDwMBee/mHAeqQBFh7mwtM/Alg7GmDhYS48/Q7A2tkA60HA4ul3AtajDbDuBCye/lHA2tUA6ybA4ul3AdbuBlhXAhZPvxuw9oRg2WvaRjhLSL8HsB5rgHU8YPH0lLZPwEr4/2kYtZfdV1yXizybR/n3AlddPvVh1F5vrFy5fHB2Yp/ANSmE8b6Ih/F89gn5SFibFbEeVMR6SBFriyJWVRFrRBFrqyLWNkWs7YpYDytiPaKItUMRa6ci1qOKWLsUsXYrYmFfFjaut9cn+NezvLG2FKdGuD3DaQ1p+kR6Dgh6buBTIw824HwycB7v84O9XgRY431+sNeLAWu8zw/2eglgjff5wV6fBVg8PdrcrQ2wzgYsnr6Z5wd7/QrAauX54aHqaKxWnh+KgDXe5wd7nfJGY433+cFepwFrvM8P9joDWON9frDXWcAa7/ODvc4B1nifH+x1HrBaeX7oB6yw54e9DbAGAIun3wtY+xpgFQCLp98HWPsbYA0CFk+/H7De1gDrlYDF078NsB5vgPUqwOLpHwesJxpgvRqwePonAOtAA6zXABZPfwCwDoZgWXd5dTQWT38QsA41wDoXsHj6Q4B12Asv42u90Vg8/WHAerIB1usAi6d/ErCONMBaCVg8/RHAeqoB1jmAxdM/BVhPN8B6PWDx9E8D1jMNsM4FLJ7+GcB6tgHWeYDF0z8LWM+FYFn35upoLJ7+OcB6vgHWpYDF0z8PWG/3wst4vjcai6d/O2C9owHWBYDF078DsN4ZgmXd6upoLJ7+nYD1rga8LgRePP27AOvdDbAuAiye/t2A9Z4QLOuuqo7G4unfA1jvbcDrYuDF078XsN7XAOsSwOLp3wdY72+AdSlg8fTvB6wPNMC6DLB4+g8A1gdDsKy7ozoai6f/IGB9qAGvy4EXT/8hwPpwA6wrAIun/zBgfaQB1pWAxdN/BLB+qQHWVYDF0/8SYH20AdbVgMXTfxSwPtYA6xrA4uk/Blgfb4B1LWDx9B8HrE80wHoDYPH0nwCsTzbAug6wePpPAtanGmBdD1g8/acA69MNsN4IWDz9pwHrMw2wbgAsnv4zgPXZBlg3AhZP/1nA+lwDrDcBFk//OcD6fAOsmwCLp/88YH2hAdbNgMXTfwGwvtgA682AxdN/EbC+1ADrLYDF038JsL7cAOutgMXTfxmwvtIA6xbA4ukpbZ+AlfD/0/rTV9l9vfWeXOT3wij/XuCqy6e+/vRVb6xcuXxw/elrAtekEIZzjl8T8vmakI+E9ZAi1hZFrKoi1ogi1lZFrG2KWNsVsR5WxHpEEWuHItZORaxHFbF2KWLtVsTao4i1VxFrnyLWfkWstyliPa6I9YQi1gFFrIOKWIcUsQ4rYj2piHVEEespRaynFbGeUcR6VhHrOUWs5xWx3q6I9Q5FrHcqYr1LEevdiljvUcR6ryLW+xSx3q+I9QFFrA8qYn1IEevDilgfUcT6JUWsjypifUwR6+OKWJ9QxPqkItanFLE+rYj1GUWszypifU4R6/OKWF9QxPqiItaXFLFwzrHRPrmifx22T47S8XknfFWwE9Lw+BwjaB9eJ+PcaD/eEHBuZT8efqlJ2o8nvTe2vjo6jL83hu8KrGdh+C7aBha2GcL4e2M4/7uJhT0IYXezsIcg7B4WRmWd4tXfG+uGsl7t34/5jW7x8CGUB5d/IuC/542dk7YO2ww/lCoB+WxWzIfLC+ehH1DMh+s0ludBxXw41nnVF/9L7RC/7ifZoYdC8uHpKZ6Uz7oW81kn5INY9Cq3dfSOJm/X3RC/4rcZ+yr3Y4tGY0q2bR27h+9jSraN2mKVhWmuqxD+1njwsySLEUEWvEyUf58gu2b0mOfV642183GsSUll4/xRD0cYnyq7DsIaaRKrRwiLo06rXnC5ef59IVylcgS1TZ5PjyATir81hBePH7b/nWS4jYUpyjATJkNpD709lmCaf10qD21addka/BrdqLbA5XYCxCO70+GN1cGRACwPfp8A9zoZHncTZcelfHpbzKdXyKdPSNeMfZLykThLJ+5Qf2THcDvg3X/Sb34UCX9PBz/BQfF/uqCOucvHlN4jCmqTVPe8j7QOTyri489OIQ72rxR/H+tf8SviPA1xOC6EM2Hycyk4ZzofAjkcgHFx1Rtd9pX+71SLThoXU16zgK+9XgthfJy7GcL42BTftZXeL+P3UF/Dzo2g30HjKD7O4vGfaXIcFfWYIUorPfOhHKR8wvrx+yPmM73FfKYL+bQ6TpLykTjjM6913A59AOyQHzSqTfK0dB5AN8T/O2aHPhxih/CZH8d2aJvRDlF+QXYI9ZPifzzEDknPDldWgzkTJrdDnDPaIYr/GbBDIyx93HaI8pL6WTy9stl+doYgh7j7WTy4uqqYT5WFUVuRxppof0YgH7wXZn9GoDxB7fXrs+U8pfbKdbcb4n+UtddvQHvl+h42PqtCWFXIF9uM5419frQuzJZVA7Ci9lEU/zshfVTVG8uP2+awZ/1qAL8uT25Ta6v1MgdhecI9is/7R5z/GoG41ZC4VeDNdXvYv453fqGQJX3f5o11FLZd4Exh/D3iN1br8dB1wm9eJqsP+xfVcTEe8uFy2h6AKdmEDdXRcanMHQLuVsDl7RzlRWeKYRv/Z1/fbRv//mwZD/XEurf4P+J9hi7ksH65w/pF+aCT6pd42/r9ahP1y+vwYQjjdhnPo+P2nDCs7P8b+v12a0vjaS/NyFNqL5I8cZ1G6h+5PLsB44Q59Tg/A32nONgnWEfth9osya9LSG8dju8o/i9Y/zJ9sZx/WHvzPNkucDngOZLbPZmLVGaKu8CXE+kjb2N6+phLUz0+Apx53jtiyjsB+XmePNdM+fcJfIh3rxDW1QLXfHpgINOfK+UrQ/2FfL6cAHziivdwnlQ6XyIpxCdZPxqLrLMl6fNyO5lcretiYTsgrJuFEUfbhm5bNJr/zpj4R5E/zz8pxN9Yrcdrpi6TQj74XNEKVnWcWHO80W1A6gtHWDrsC/n4hZ95OjCnfl+yi2G2jmwb2n1eTrSDObB1vP9T1KGcNB5FW/dITHlHtXWUf58XXLe9Qlgrtq6Uz6VzlcH8UKmSLZcGKglvbJ/QKdxDWyfp7Swhfsy2IiXZOrRnXSzsEQjjto44SrYunn4xm4oif55/UoiPti5qXSaFfNDWtYJVHScW2To+DsJx6ghLh+PUrUJ5uK3D57JXgk2K6UsH4jwg2lTO1zr+DL2VyQnlizj8Hh838zQ4L0PxX8/G7a+bI/OjMlwr8JP2dfFynTcnON5WIZ6dWyTbsqq88dpbi+vLpWvLw+vLGzs9mR4WEYuPj1MexLOuC+7dA79x+mYd4FAX3OU1dlwlOJZUdRwbu96LfJFZEzbTf+SRtp9Zt9L/n2rRSY+O2NVW2X29JpWJ/FhB+fd6Y1Uuji0sVeCD8sHucSQe+aTsEzBOb1t3V3WsbJAHbiGUPlYTRf68vNJUO+oN5SuZwKDlzhIzWdfPqcdHGxBl2xhvJ2FbZxJC/AqEVVlZEiH4OA1yM2vHx8O3O/lQh8oR71fDM2npq+Hc/vFhVJD+8/gkc1zi4TIJWx638qQ6D1uSl5Y8+XdKUa+l5XDU3ZlCPnG3kZlQHq6XuGWg2eVCSR8bLXutDWhjQcteWRbO47+dLXttgPqUhg9HsQ1kmm0DUj1wWdOxnkkh/s3V0WFSG5DkhLqwTuAg9UOSLqwLyMe626vjzwfT4/eAw8YR8QzNo3+2m/KfqHHE/RHlSvJ5KB75pKLYFskeVoUwwhrxf3ObweM/xMrI4/NrSs/v7fPtSNj2gbB+it8j+Vr79Cg8tsQ9HgprD+PNh2PRp2rou+L0THGEjaUOzwlOT5+nmcLSSFsPsDxch3if8gz0KXy5RNK1Kgvn8VexPuX5cY4R0I42O0YI2x4Y1i9Yh5/9ibJtdLonb1Ol77dTHdNUyQdZHb8/4HHcOl4/H4H64bZQqh/8dnzQdMBH2LQM5/hxxvGjIW2Pc/xkQDx7vcYbGw9tkefJ4xesQz5NIcXnto3H/2zEcT3pQ7xjmrQ4ruf1j2OaRv0R6W7Yliqs599k9fxVaK+SXRxvmwwaTwbZ8phf2xuMOuZohw+xSmOOoLZjHY3vpPjS6yRSvdm5C7TbSYZF+U5j97bCPexzwsYo1nFb8ttzZAxePmmcQ0fsc4wotrxZfZbK1A7tJopeS/mEjYHieq206l/H/NpejmS/jfGUxry4XW07K0MnYEjxR4A/4uMRfJS+y5O3yFJ7wH5s7twX/7+wlQ360rAyWkeflEwInDqFOCPAmZaFpgRwvhE4U/wfsr4Xt5zzvgnlbB1us6f4/8gwNy6SeXpeNDsqLY/xJTDiI219fgTS8WU4rHMJG5fCJRw8chHL2cHuzRawpaVg61f6v1MtOsKjpVK+3XenwKcb4v8U9HgXyDRMZtY/KuTLj0qcDfk+Cvm+oJeLR2MSNz6+5/WOdTICeSDPVRBO8f+PjcF+Dv0e7695/9g9V86bPw/sCOH6iMCVt5kt1dHhNR33833ha9+LZa6cD+d69OYP5bE2cXyhnNXR8pHsB48/XvshLdVvhTBp3J7wxtqwKH0MrwcpPm6LpPizWT3Ts1LYPKXFp35JmocIerWuUT8lPb/ydYj5c2XcoFe26NOyuIZ1A5u3OH6unLd1vA2e2GTeNwTknWR5nwIylOYyNMd/Ul3N9UaXqwpYeA/HeDx9FThXFTgnQzhL/TOO9Ue8seUZCcmHpx+B8owI5Yl5PBv52ZXy7xVkEsezq/RsKb16S/G3CfEfCom/XYgv1Rt/duW21YN8+bPrdrjXymtp/U3aBT4XzOP/YH4dcxDsAuflJxdtxjxP5uJ54XWUFNLjnoS4ngvnQXkeCilPs+utPP1EvZ45D/IJ0puLQG/8oKZfP/5VpjeXhuhN2Gv1Ya86RplTD6uD+yPms6XFfKK+uvlS1qmblHTqk0yn3hIyznupy3lEMR+Oha9W87FDlV3zMMoH74WNk4K2iXIOto7vnCvnGVVvKP7TTG/WRtAbqQ6qEDYi5DtRe3Mmyh6GYVUFLIo/IsQPG4NFXQ+QXqck3Y73dZLo+0Mo/17gqsunPt6V5gi2CbKb4dXnPorlDelM4bzy8Pr71m7EyiDAJAh5OwBSfA9+YzpLqgviPCTkYR0/44MrUhLS44Aa8aNwahS3UbjUCLcFlNPzojVCnr7Z8xTxvVOKv5NNokQ5Y4ErT5QzFsI27qCs6X5vQDo+aczDeJkvCykzxd8XUuYRL7zMN0CZq4zTCKQbYWHVgDLT/WmevEmCMCQZH+ON5t6sPvH0EzVYOQbyCercnw6YPA7aQHorC+fxd7LO/Tno3KXBd9zlDzpPiZfrVhanCvGpXF0CpnX44gfFf59f9pgnfsR3mIIGdLx8L5xtNbexbMLqnOLfz+r8wxHqPKz9SOeEhdkKpwcy6XIqio7z/J0fyHwvMVrIUQcymC5sIINxqxCPFKnVgYzEKShuswMZ/gSAA5lmd4zw9BQv3t1UmTE7lPmqDm9M+ES2hZVB6qCDdoImAvCxA6D0XQGywx0WFP9rbBAzf/GL11JdHRvAz/Oi1RVPP1G7e46FfOKYxbUOZzQmerAepIP0NkyjQdJ3muww8W0yir+cdZi/Cx1m1F1kUWZqUec9L9oMf1h7i9p+UEZdAqZ1QYfS/jMMoKosvZ6dyqeO3qpdPnLnjwM6aVdFrxDW0iE8A5V0qr9/IFvJFAvlfD/2kcQV70VZ0TtFiB/vjFFOPIRnG5OrdV0sbCuEdbMwvjKIB1PEMzDLlaLIn+efFOJvYGVopi4lrMvGiUWHSYwwzj7UUbNlQZM497NwHv/HIRMa0uHH0oG9YYc548MQlhFtonUr/f+NNKnSwFF+VD9TBS5VkAvF/R++Q2jx6LJUhbKQjeoMycMT7iW8YNlhHh1C2tu80dxGInDj6UdYXp1CuipgTNQOFCmfk1rM5yQhnzhXvniejcZjffPqabi9CVqRerBaD+fxF7DxWNLHlN7m5RyxDqSxENpISk877zAO2huKf4zPSdopfT+UmZczTM/4eIxzDprQOt7ncDQntLDMXV59dy+3j+dX5TI3OhCZ4ktjlrATKqT+F7GCJs2DDv35iT9za3VlEej5Wi+8/BdUR2NS/JUMc2mTmBcGYL5uXh3zdGg7/IMN8z05P+s6hXtoH3h6ike6GNdb34S/IR782oeG1guy4GWi/Fv9eBzPq9cbW0dxTCRKZQurZ/4BEHxTSsJa3yRWjxAWR52uCyk3z78vhKtUjirIRMpnviATir8xhBePT22Y6z6lJRnyDzcqyjATVt/8Q5KU/3g+HkVymw/x8ONRXPYbArA8+D0f7nV68sejrM0c8SffZgnlWwG4Ut3xe6j/PD3Fk/LpbjGfbiGfMKwVAhb27Tx+txCfysE/EDoxc9t1/dwkcJXm6MajnyS3EyEejVs6vLFt8O4ALA9+nwj3gvSzU8gDP0gT1i6tmyVgoF3fFJInldU66Q1YiocH25ZhvBqPrSoM4IdqKQ+e9/0x5R21zw9aR+C8pbfZW5k/zBQrueHhbCo9mM5XitnBsPYtrYdQfGm+50whPsk6no9hvvgxhhc4VOv4fPe7dV0sDE/I6mZhxFGaP4zHZhVyUeTP85dOKcT5w2bXtsKejaNi0fwht/vUtifK1oRhSXN9CeA8xZPXNtGWUfzV7Pmf3rzr9ILl4An3OryxduqK6ov/pb4U+5C7hbLyeyg3np7iHT1bmco3ayt7A2SyUodP6IliklxxbZanldZa8aMdzc6btzsW1238kDyFS/8pH7yH+eB4gecT1zp8lHYy3nw4Fo0h417vp7nEmPvmlPQmKTmcq5b0hs/f4VhpGwvD+pH2sUgfZrqDXaPrhN84PjhpcR0X45GTNtthv9fsRzmlj+RJ8098Pv7IPDlPPh/P50CC9kcsY/OUz4TMKQbtHeJz25xr0F6Dd8CzQpWlj3tum/LqEcqnl/dARfqgKjnp1CRsI7z9YBvh7QfbCG8/eOI5d1I7IFnYdnB9E+1grVCOsA/kSpvLqRxSf7AWwrgN3wJhfPxQhTBuK+n0tQTkZ53UXnENIqzMcY+He4SyHk3dxdOqRlh8PiZHJ+kglcnq4N4IOohjEeSGMhzPcwPGQTtK8X85ZN3wbpaGMB9gmEGnlHHbyscUaFsp/jfAtsY0Jyfa1ign5k/EXCHPz/Pk5452OFVQet62c5f0sezVa4qlc4trN2xaXe4AUfKmL5l6jM/jekJYJ9xbD/EuqY7+Tc0BmzBid7J8pS2m0hRF2LYkaQrlbiFfutchxN8MWJuFdMQ9bMqGY0jT4oQhpbO/7wxIEyQr3k2grMJeYN3SAAvf+Qp7n6faAOt6wAr7bvJIA6wbAYunHwGsrQ2wNgEWT4/bHbY1wLobsMK2I2xvgHUPYPH0eJDUww2w7gUsnj7o8LEgLDyEOezgtx0NsO4HLOm7XoS1swHWZsCSvodIWI82wHoAsHj6RwPS8a7auiiH9sfznct0NmpXR/lP1KH9ktylgx9JdrsErkkhjC8N8zCezy4hHwlroyLW/YpYDylibVHEqipijShibVXE2qaItV0R62FFrEcUsXYoYu1UxNqkiLVWEWuDItY9gCVt75Ns7gzfW7dh45r1Zf/5wgMX9jxgf28OyH+OkN6DtAm4NycAi3DsPT7Gx8d1fgCmNB4nPPxQxkn+tKe0zLdOSG9d2JbAmLcvRn60pfx7vbE6HEd/vwH4oHywv98ocE0KYTglsi5iPho6bh098yYEPpjeA6yEcM86aQtalcXBMle90XzxXth0IcXD6fezmN4HvU4jLSFYh1v6KX6KYeJB4FWhDM18UAFlRHykZ0xKG+/SQiEtTXWSk6bpcXqfjzVwep+PHXB6n48FcLqN9+1cJuikadeqfx11CQz1hXBRX8hWo93kaflSlrQN9nTIU7I3/B62CZ6e4kn5dLeYT7eQTxjW6QIWxZe2f4Rty5S2Jca8xaO2LVPacirNh41nWybJbQnEw22Z0nZIxPLg9xK41+nJ2zIlXVkXwJPybaQr0usGiMWXCmiOzobj8gPFL/s2mOp9I5Rtpf871ZIbzIZt/4h3aWow8pxH0NYOzlvactTSFsxCNp0upNLlciqXKpZSYW1Z2nJE8aUtSsuE+PEupQympC2YuM2yi4XdDWHdLIw4Slsw47FPg5Hkz/OXtu7gFsxmt+XxsBvGiUVbMLmNx9cL4rZN+Hri7cIYcqK50BhqTch4VuqbpA8ChL1+I73CgeVq9hWOdRHzWd5iPsuFfPqEdImA/5QP3sN8JM6Nti89cEw9DdfvoGcPmvvvhvg/YNuXtvjX0jYNnPNttC0A2yul59sCwvplir+d6SduC9gIZebllPSMytwllMs63BZA8R+FsUFM22zFbQHYF0/8uCH63Am+nhHTK3fpsD5A2g4UcVsAqjgXJ4fDYnOx8LBGUyQXVUf/Hs+2AGm4E7bULXXd0jLdRiFfutfobS7MB4fSnSHpOYb0WEIYUjr7uxyQJkhW0uO29FiIy1SbG2Bh1yhtgSCshxpg4baAsBNnqg2wcFuAdCwvYY00wMJtATz9CGBta4CF2wJ4+ijbAjhWq9sCOFar2wI4VqvbAjhWq9sCpKFB2LYATMe7V+uiLOXzZSrFpfzI56tT/hO1lC/JPWwp/1GBa1IIwykPacvAo0I+EtZWRawtilibFLHuV8TarIj1kCJWVRFrRBFrmyLWdkWshxWxHlHE2qGItVYR62gvmd8dkH9SSO9B2gTcSwZgEY69x8e/UZbM+Vg1aMn8u5NL5ir96kt1yZyeBxMCH0zvAVZCuGcdXzKneNJbNNKzC8XHty8QA5e1Kf4PQ5a1pWexsGXtsDcAOB/pORdPH5aec6Xpev7GkHVdLExRr4elb/ty+XRXo8vCOpRdVYjPxzH4hliVheGbZby94LiqkV6FLWdTWj61KT3vLoQ8m30jm6cPO5W6u8V8uoV8wrAWClgUX3pGDVvOlp5Rqa/Ab7Wv9H+nWnOZMF2TnnPHs5xNcjsB4uFydpWl2x6A5cHvE+Beo+VsXqcbA3hSvo10hacP08l1LeYjfYMal4NO9vuKmE94yYZ9Tzne07ULkZfBKX9pa1HVv+4VwlpZBq8UMqnhbKWcymeHhoZTtZO0pTkvfi+KzVgqxI/XLhTEZfCHmVyt62Jh2yGM933EUVoGfzgm/lHkz/NPCvFxGTxqXUpYl40Ti5bBq4zz0bI1I/7vJb6tkZbB4+YS8xbHrPSZJnKSPcG3wHn7bfYtcD9602+Bc5njXEuzb4H7PyO/BU7xM0wncLlX+oxh2FvghMmXezlnXO6l+APQB46w9HEv91JeE/U92HjL2Hw7wG0W3K7jNmDeZ+EyOZ9HWwthfB0CT7aV5salV+3wlJndLAy3Fu9hYfhMz53UlqlebHvYcVwdF+N5kCfXGxzHVFkYyVfa8nEau+ZhxBXvob7x9GsD0nE+1sV8Wm863tOd6icqh21NkPRnvNuJeF69gKUtu7CyhW2jkraPhmFF2RLIsWLe/lKr000h5ZZskMRVKgfO00vt7DRBJhR/SwgvHl+aG6O0Mfd1oacQS6+gjGd+gOS2AuLhKdlB+1Y4lge/V8C9oPkBii9tNdwscIqy1W5TAyzcaxK0byaovXEs3GsiySpM7zgW7jWR9I6wRhpg4V4TSWcIa1sDrFb3mnCsVveacKxW95pwrFb3mnCsVveacKxWj6DgWM0cQSE9T1onzbfzbbYPwtoJpeVrIXwevMrCefwvHlvHrLJrfJ2R24EHvNFhfOz4IPDna2Jkk+J9lSX6+iDl3wtclfmkw2yvtE0+4rZQPDmDi5PDYbG5WHgYLgPi0u46SDeebaFSl7FBwAzrMjAdl4Un3OsQ4m8ErI1COuLeGZKeY0gfucDy41tg9t59Qt74FtgTbPphPkw/SHlxeeAUiLTjncdBDhT/cMgUCMXpCijXhgDMjzCT89SxMqYnYErl2gTlQg4bgQPFf46Vi7Y/eN5YfcU2QNOn+HiA3KV7HJunxbCwfBultdf3smsMk/T2PohP22uCZIq6QvHfF6Ir6wUO0tbwIA4YZ1MAhw8JHLhpHV6z9r6AHRFd7FoyhViVWAXrBZwgR2KwxaPmgDj0O0z9pN0kXsA9rAZKyz9EXyqvLm8M2jKCfcvagMw6PNnhB5sonXXtun0opo9dhW4fkj7MJR2OituHpK0kzeYz3u1DQeMGqb/C9B6kTQj3rLON5dPTRscLGwJbd0e1Hs7jf4XZCdwORHE6AjDpsZTiS6f/SFPfFH+3EJ9P51L+NB7i08C7vcZ5Sx9cpPh7muT6mBCfTyHvAq6c32NNcr1hgrmuE7j2CXmjjeLlOho2ivLvFcoYh40Kk6t1TT7CcFVHcXI4LHaQWUBThI8FF1dH/x7PI8xeFiaJAB9heJn2BqTDJoH3OoT4jwHWY0I64t4Zkp5j8HSoSlI6+3u1kCZK09kL+Cv936mWXDryN2oo/4lqOo30Brv3fQLXpBCG0wD7hHz2CflIWFsVsR5VxFqriLVREWuTItbdilhbFLFGFLG2KWJtV8R6WBHrEUWsHYpYOxWxNiti7VbEWqeItUERC99Skt7gCBpGabyl9FhA/vOE9B6kTcC9eQFYhGPv8bEMPnZQvzDFC3/k6Yb40/0PAktvKT0qpLcuytu/OFZa6f9OteYiD+Ep/4l6+7fRoxeOQ3YLXJNCGPb3UQ8M13pLicb2CYEPpvcAKyHc42GSjksfucBVO55WWrXbKuCGPbJT/8mnODjGndV6OI9/Ims7OMUhrSSHPVpLq8W8LyY+s4ADTyutJI/419LObIoX8xtPZemNJ17e7upoWUir3Tw+yk5a0ebjBfxmPe//t0HYCAvjO9fRhlB9WP3rmzc6XpXxSQT8J654D/u7Kguj71NKB6q2mg/HWgP58J0ffLU8M7+Oy2XC2xEfM2dZOI9/xfw6Zt6/Dtv5gQfqFlg7/NXFwemr3uiwKgvD761xPcBxmVROLj+0FxT/tYznr8NObd4u/cu422VFapfc7mG7lGwUj4/tMqwdc5klvbFtFp+1pN1HXOaNdqRjnfLDm3n8i4XxEPHj/c9W4L65Se5SfyTZGX7w73fmvng9Czhgf4D1ElZXSSH91gCsDoE/b9dY751C3lJ80gm+zC3Z726Ifz2rq9mLZUwvgMOWAM5TAuI/DBwo/psEfQmzE1z/twMmxX8zw8RDGhth3hqAeUvIWEVqp9vYvWb7WxyPcDnugDDOvcpwOWaHEPd2yJ+HcT3HfL0QvtjnNuI74l+jXt7D+rM7/OsewFO25dmwujxDKE/UutwSUn7EonRd3lh9DWtDXF7r58uY3U1ibhLGBNJYh75tOoXxCLOh0ndOcZzE0/JxkjS2CPrO8INCe5XGCoQV61ghXU5JYwUui26WbxTZoU3ZJsTn9YxjeB5/bXV0WNhH+bT64g/MHY07EoJrr48DHmFjSHtdYuE8/p4QOy7JMEzm0jMqHwcQH8mOb4cwSafbTV+5fFBfw2RhXbPP66ivUv8k6SuO48L0yrowfaW0Vl+fDhk7Uv7S3MII8GmkMzhX/DDjIMXHMRDFf0fIuErq46rs3njnB5rp43i75TK5sjq6PBT/fRHtOdVLvM9+6bTUPrhcsX2EydA6lLn0ZgCXJcksCfG5/KX28QiEcf2M8gwUte3w/vtOsPXViLjYhrnOVFleaOsp/mdDbL12/1r1r8PekgmzHe2my+1i60cgTLL1kv5V/WurfzdFGGuEnQgl6cqIwF+aF8N5Z56Ov/n8AnZ1bLmPRt2HzWGFtQPrmh0jYd1Lp8ZIc0Q4x1IV8uE25UooRyObgnOtFP8PmrQpYXqlaVOqLCzMplC8l7NehdmUZvUqrA+ktNYGXQTjR54nngwn6VHY2lfUZ78wPeoUeI0w3B4B17qV/v9Uiy5sTabHG1u/inM/kffmUf60Js7lGMeauFSvXD6kB/GeAJbKzfbGthXr7qqOlQ3ywPb0EONOMr6R4eDJPvwNVr529uMIa2fS29U4H/AzNnf2E8CUTk6K2vYprcXtnytz5bhhJ9dsY1hSfF52Hv8XIc+Akv2UdIviNxrD4elYUdfXqwH5SHsJpH65Fn9Bvaxhz4cTs2afSR/tNXucIwlbs6+yMNxzKOmqdDIDtleeVmqvm1m5pLbFbQLnSDysu5PFwXkT0uUge0CnB+D47hhBj8JkMYfda7ZfxjbD+5Moz+JSPYTZDKluxuzJYeVHm7GNpZHGaChTin9KiEwlOxQmU419PlFliq/7UD5RZUrxTwuRKZ+/iyJTin9GiEwlGYXJtNE+A5QplzfuK24kU3w1TZrfDJMpxU+FyJSfoBhFphQ/exRlysv8CKTjNmOEXXd6Y+1db0C62SGY2wIww8afiBFUl5JNw7p8TUhdSuXaFrFc25XKtb3JclH8c2Mq1+aAcm1uslzbGpQr6NTji4VySX1Y0HOtNOdiHc79U/zLI47tKO+X+txG1b+W5jY2Q5i05ypMX8bzfHMizG1w/UQd8CFH6YA0T4f7ym6OqAP8xFrrulhY3DpQrRdjjA6MsDBJ98c755wU4tNzsqQDVchHSwfmzx0dj5c3EfCf8sR7HVC2EaFsKCf+HMHnKPA5gp9wL7VFjE/tju+t4+0N959Q/DVMX2lvnfTeB5/TWLdAzjuoreCcBsXfvqCOudG/ll4pJ7mO13ZzOQfZ7vsmbfco200yk2w3tukw2y29+yGdMC2dcMvf/XhmTmP+0lwyxZfGfNIYDMd8O0PGRtIcEJdTLgDzMab3uxeMLj+vR9rvZOMdXKCT9/6QZ4dGpw82O7eDe4ek/RZYbqyrg2AXpPURlAkfq/L4OFblYc08W0h7e1GGUwLi4xic4j8j6FmUvQ8Sv6j9Ih9Xo02vCrhhujAixK+yOLi2I63fhL2vcfTWCDMZyRbz8qItDhsTWae1J1Ky09wWY/uQTpaPqiuU1urKWt8WS3NX90coG7/XEcIf2wqV51OsreC++RGWJsq4neJ/NsQuSmUIWy+PuuYrjWe2h6TjOtQj5LXS/59KVVpylB/ZrakCl6D+8qvcji2WuSbG8G3NSX1nAuTEbbCibUglID/PG/usgH2T1N+sVOFTX5OV5gGldhfvl4LSFb4my/WXr8nyupHGD9L4lz+PfBP6LskGcHuaYeE8/nfYuOw3AjA9r3nbSWkt7tdnj8bV3qMWto8rbH0T9wZL7+sQB2lvLI9fYuE8/h8x2xD2XuSErH2mK0d9byzuf+V7Y0cAS9I/rgtBX5AKGofyNsLj/3XIODRsf261Se5bBe7YzrHtfDPCGLWV/bnHsXAe/x+bXGudqL10PB3/8sgL2NV62OT+3LF76fj7QpRno71xHwDbLb1jJJ1rgfrK9Y/zOJ6F8/g/D9G/EYFD2Bd3G83X4nuAVRYW1rcc9XeBUunM0Z4zo7qPskdY2hclnX/C30Xb4etfnHIcKKRqY1qqQ9JXdF0snMdP+oa0l5WD/ne1wLMyUExXssVKMV8slXLDRfzSmnVUZ9NjyD9TKPQPZoZSuYHScKWUy050/sND/UO58tBwfzrXn82lShNe/lKpnM6lBwYL5VyuNJif6Pxz+eLAcHEgnR7Mpcu5dMP8rT2Y7usi2VSK2+/ft+1qIfsCWwLw6Jqek7hNUHxuG05Afp4nP0dS/r3AVZlP7TmyA/gkAuTdwzjEwGcoAficT6cgH6rL6UIYYdG5Wbw/ng78qYw8Pr+m9Pze2TBuns7i0tk+CSGsU7hHnK2eLgM97WLx8CyfbiFPCpsSEjY1JGyaN5o7D+th6dZBul4B84UvwsN6ilS3XP/wbGDUfY41vQEWfl2Lp58OWDMaYOHXtXj6GYDV1wALv67F0/cB1swGWPh1LZ5+JmDNaoCFX9fi6WcBVrIBFn5di6dPAtbsBlj4dS2efjZgzWmAhV/X4unnANbcBlj4dS2efi5gzWuAhV/X4unxPMljGmDh17V4+mMA69gGWA8CFk9/LGDNb4B1J2Dx9JS2T8DC/nkBu380+mfKvxe4xtU/L/DGypXLB/vD4wSuSSEM7dZxQj7HCflIWH2KWDMVsWYpYiUVsWYrYs1RxJqriDVPEesYRSy0W43665uqL/4P668pHdddHq+TxZH6aI4RNB7gY/NG44IrgbOUpzTGpDOUcIxJ+fKwKcCNh01lYdMhjI8x0e73sLAZEMafNak8fIyJz3a8bFhWzlHi3Ath/LmiG8K4jKZBGO8/pkAYlx+VO45n6qFS/3BqMJsuFYsDqYH+QjPP1PiMxdNRf4x6vnKcPEe74XRC4Cn1x5R/L3DV5VPvj6VnBel5juTTF498UmH2q0+QD/GZGQufVJZ0JSnkTVyp3+PP4zx+H5Mhj8+vKT2/9wzoq/S8kYQw6/BZXXpG4vc6jhKW9LzF5UZ1am3K20AWXF8TAf8JF+8hR16faNenK+bDsWiuQWpP1q/0f6dactkMlWOmUA7Km+uVXtvJD0S1dZR/rxdrW06H6TCXDz57JAWuSW+sDm+r1uM10m+ej4R1pE2x9ihiPaGIdUgRS1Ne+xWxDihi7VXE2qKIpVnGg4pYmrx2KWJptkfNetytiKXZhp5UxNKsR01dfVoRS1O/DitiPauIpan37WpzNMv4nCLWiCLW84pYmvLSHJto6le7jgs19b5dx3I7FbEeV8R6OYzl2lXvNccmk31ac1jtOpZrV1uoOZbTtIWa9agpr3Ydf21VxGrX8ddjiliabVuzDWnKS7Mf0mxD7Sp7TfulOS/XrnNDmvqlOfZt1zFmO/Yd9hrXrDT6jlkB2Pw6bG1YyichcJbWlPlekx5vbHk115UJf05M+FRuaR8qLxPlj2vMFC79JywMo7x6AUu5bOmwsoWtRfN1dy6DIKzZTWL1CGFx1GkypNw8/74QrlI5+hRl0q2INQWwpPYvrd9SfGn/tKQnYfunqW75XkLFus2E1a20B9vuWaB9WaXy0KZVl61Z5YHrBDmQ3K6HePQeQIc3tm3MDsDy4Pf1cK+T4XE3Ufa9T0hH8WLeM5SJai8p/15BJnHYy5kR5SrtN5oJMuftZ2O1fs3j0n6msHdzpP4m3r63Pxu1fij/ierPwuy6dVg/Uey6ddur9Xit2GLrnlHEOqSItUcRa5ci1hFFLM0y7lbE2qKIpakTOxWxNHXibYpYLwedOKCIdVARq13btqbsNeX1mCKWZhkfV8TSrEdNvd+riKWp9/sUsTR14jlFLE2dmBx/vTRstGZfu0MR6+VgC59XxNK0OY8qYj2liKXZhjTlpdmnteu4sF37tHZ9ttKUvWYb0pSXpo2e7DteGn2H5rOVpi08rIg1Oadw9NqQpuw1y/isIla7Pg9pyn6/Ila7zhdqjnMm7cTRG09M2omjJ/t2tRNRxl/T2D08e1Ha20BYcxpg4dmLPH2Uc/Y4Fp69KO3xoHTzAvLh541IZ+tZ1+eNLVvC/98j4GvvV+L5UZn4PZ5/r1DGONbZpXMLpW8Nk+yOEbgmhTCuWzyM53OMkI+ENRs4cD2foPrLjLf+ZsfDJ7T+JPvRbP0FnWVF4V4by3zKUZD5lBZlbt2G6ov/pXM9cd+fxGGewCEppKd4Uj5zWsxnTsR8ZreYz+yI+cQhN/wt7e2iuqQ2wut5pf8/1ZrLkX4dC7x4vjGdXRq5bVL+vcA1rrYpnVHL5YNtc4HANSmEHQNyjaE+s0fxbNzI9flSORuX6m+WIFc8P1TisEDgkBTSLwjJZ36L+cwX8ukR0q30/6dactkcypjy5vkez+4fDf2k/Hu9sXUeh34eD3xQPqifJwhck0JY/PWZqvQJZcD6PCEe+UWuT8q/14tVv2r1eQLwQflgfZ4ocE0KYeOoz8xwJZ3Nlwfyqf5iLl/qz2ZKmYFUKZevpNOFdGYwV8hmK8O5QqmQyVYyA5nhPqEMWJ8nxiO/XNT6pPx7vVj1q1afJwIflA/W50kC1ySEWUfju4QQ1inc6wjAwj6hFSzr6BsiMfYDedR94s7z5eU7GnaD8u/1YtX7dFidcfmgnp0scE0KYQsgHa/PiZF5dmi8Mo9prBoqc2m81IzMrXu4Wo+HYZ3CvY4QrJ2KWPsVsR5XxNqjiLVbEWuLItYRRayDiliaZdyliKVZxicUsQ4pYj2liKWpX5rtUVO/NG2hJq8Diliaev9y0Il9ilia+vWkIpZmGTVl/5gilqbeH1bEmrQTLw07oVnGZxWxNMcT7Sr75xSxJttQc1g7FLEm29DRk73ms7vmMzKeNcbnkHAdrNl5SZ6e4kn5zG8xn/kR85nTYj5zIuYzu8V8ZkfMZ0qL+UyJmM+k3EbnE1VuL7X281Irz3Et5nNcxHyObzGf4yPmc0KL+ZwQMZ8TW8znRCGfHiHdSv9/OptNp1KlgXSlVMnmBwYzQ+n+bH9/JVcZ6C/kSpV8rlgaKKdzxWxmsDyQqqQLZbNqmh0e6K8Mlob7K9I37Ombc7YtX3/i6PLQN0T5nmL+zc4OFs7j//6Jdcwb/Wv8ZqnHrnsAL+FprpNkIn/vmvLvBa66fOrrNh3AB+WD6zadAtckhFn3cLUeD8M6hXthWAcVsZ5SxDqgiLVbEWuLItbTilg7FbEeV8Tar4jVrvWoqaua7VGT1y5FrD2KWE8qYmnqxGOKWJo6cVgRS1NemvZLk9cRRSzNetTk1a59h2Y9aspes21rlvE5RawRRaznFbFeDv22ZtuOo6+lZ2X+PEffU58F6ez1dAjrYmEcg4dxfl0h/Hj6roB0WA56Ho3r/TnCnxYPfu2bAFMFWfEyUf70fNnN4icC/hMWhlFevYClLbuwsnH+qAdTGR+c95SwpjaJ1SOExVGnU0LKzfPvC+EqlaMLZCK1s4QgE7o/LYQXjz9LyJvSkgx7WJiiDDNhMuRtkfIfz/cUSG4rIB6dOdDhjdXBqQFYHvxeAfc6GR53swBDsqPYnoPqNxmQ3rq+kHz6hHRUvumM40IWPg3yWOiN5bgwhCNPT/GkfBIt5pMQ8kEsac7Uujuq9XAe/8/9eVJbho2LRmMuEvhJdUX3FwvxF7E4xEeSzeII6azrE/IiTtSOl7D72raQ50d8+T2efy9wjatPWgJ8UD7YNpYKXJNCGNqFpUI+S4V8JCyqz1ne2PrF769IercoJJ8+IZ94dSGTQ1lyR2GnCmWksNNYGNcPdJ3wm5fJttlvL67jYjzkw2VO3NpNTosg7DQWn86pobDTWRi9dzUeGX6vCRnyuiLeZFPpWzN/42/weKGvPWl0HDqzYMpJ9TgdJ43OY5FQrj5vbFvH79csFcIs/l/5fKjtcd3Dvo/Lu1O4F9b3nRaA1cWwehgWnWHUDfGX+PIg3Tyd4erpZv8AyW0Z44R9yRkx5R21L6H8+wQ+xLtXCOtqgWtluJDKpvr7S+X+3FA+V0kAPnHFezgeWC7El74hRLJe4cUi60ztO4vVOv5yJlfruljYGRDWzcKIo9X72xaN5r88Jv5R5M/zTwph/AycZuoyKYTdUNXB4vZAA2vqOLHmeKPbE7c5ks3E/VjN2kye/rSQfGa3mM9sIZ94bWqmINlUcpINw29+Lg8oPzqpT6cy2bZ55pI6LsZDPlzmxG2WN1ZOOH9zOvDBe2H71ige1QfXPcX6GESZe0L5lwtlpDBuk7mc0En1QWWy9bGyifrgMidu7San0yGMz5HcWB0ddiYLa3acymW4epw6jTKMZ0yTKaKcPIHXCkEWKCd73ewzEZXJyunz49S1FRDGdY24zfKCbdh4+7A5QjmkfGa3mM9sIZ94xy6ZIaneyUn1jv3BWQHlRyfpBJWp2f6AyxzrXbKVCW+s3ncK98L6A2yj8YyF62fUcJuE5T9LKCOFnc3CuJzQSfXBx87N9Adc5sSt3eS0HMLOZvGxP3gFC2u2P+AyXD1Onea8OfcuTx7bvKn64v9uiL+JzWFsgDkMPqdDedt4n4Z4ywXe8dZt9Hlcyr/Xi9NG1udxVwCfIPsh2U1KmxTC8PvnZwr5nCnkI2GF9U/4fkKz/dOxQj7t1s6PhTBuD7l+oGvUlpuZx5XacrvJCeetuD3EeVwte9jMPK7Up6DeRrWHFP8QzFvGZL9Sc6BcPC/pOabd7Wo8zyPhdlWyQ83aVf580KpdJX2Uxpn4Plaz48z5Qj7tZi/mQ5jWOPPbLdoEl8aZ7WBXpb4p6pgw6nj0uuqL/3E8+gU2Hv3cScG8TmV5/2xyPIrOqfEo1eUsb6yO4Xj0VCGfU0PyOVbIZ3I8OpYPl3m72s1TIcyl8Shxj2oPKf6fttF49FSh/PGuRUW3q5R/rzdWn+Owq9K6kWSHpDUYSpsUwnA8KtnvFUI+EhaOR3kd4Xi02XWw+UJ5Yl7faWptgnOU+jauH+gareE0Y1eltYl2kxOug3F7jHb1LBbWyjrY98bZNwU9IzcaE54u5BFvPaTKUW0X7gGKyZbWbNcy4BPU1u0edjrnaFV541WbhlbfNnxp+b4N59xVuqq4fuNtxdXnlErryxs28NLwHPqE0qK2YBy6Tgr3OcbyBqXAL/XxWl4OWCsaYOGX+nj6FYB1ZgMs/FIfT8/T8t/d3lietDuwIwIOtlyJ143Ai1tLHM2c3QBrE2Dx9GcD1isaYN0NWDw9T8t/d3tjeaK8wnCsTzfgdU91NK8US58GrEwDrHsBi6fPAFa2AdZ9gMXT87T8d7c3lifKKwzH+lwDXvdXR/PKsvQ5wMo3wNoMWDx9HrD6G2A9AFg8PU/Lf3d7Y3mivMJwrB9owOvB6mhe/Sz9QEC6IFvGbYPUdgdYuKSrvO55mfuEe9i7Fth9xd6sFLV3pfx7vbH1EkfvWvDGyo/LB58MBgWuSSEMnwwGhXwGhXwkrOWKWKcrYp2piHWWItYKRayUIlZaEWtAESuriJVTxCI7Jo298CS7Zp+8eXp80uN1rmdzsrW3H3hfQo7CCkIZJdvD7SI66WmOymSf5rYtreNiPOTDZU7cSE5cn4+mnPApk+sX9csU9koW1uwTMZXXyvBjTciQ61MBwlYIaeOVb/RZOsq/1xurC3H0xdIYXmrDJLuMwDUphKENDxsz8XwkLBrXSc8ReOplSsgnFZLP8QLnmNtaBmXJHYVlhTJSGLf3XD/QNWpPzczScZkTt3aTUwrC+PMWztLx8WYrNqmZWTpeV1mGjzLk8fib7tLzs8QrIeCkIC6FdQhp8VRWHoanv0r2g9/D9naCwLdPSId2mduDo2GXKf9eL06dr9vlTES5Su0gAzKX2kgCwng+WSEfCQvHAGH9ajzju+hfBKX8J6pflfoh6YugE6HfQfWcDuGTi4dP7S1Paf5KGnfYtyGmeGN1SJprQ955hk/3oox5cF682XlLjoXz4s3OW3IsnBeXZIDzlO9lb+kfOnl0HJrTfYrFedK/lvoskoON926Ih/PD1vV4Y+vnaLR9yr8XuMbV9qV65PLhuj3VC9cxXsdB6w1nC2VFnT+rASfUeSkvSSconqQT0qqkjff+kHhnCvEQg/SXr3/hKRUU90M+hh2r/XypnC9hWBfzLpLIOou74OLerSHN5YTt1jiau4c1sNp1Rwbu4JqInQaU6Xh3a9hVcNpJYlbBzfr39cXVt5WKG29bc9c15XWbyhs2dgHsqQF06DduUKWsOI4XQte6Dgg7HcL5cpTkomyM4Cp1NB5LKP+J2hjRaOkezcRZAtekEMY3qQR1V2cJ+UhYpCvSy1v4UZFmX946UeDcbptAT4QwPjzg+oFOc7Ps5Mtb9Tjj3SzL6wqHYItY/PXV0WFLWLrTIB0/rI7w+eFZFI8fWLoIME5mYUsg7BQWtpTh/+vCF69nCRzxcC4Ks65TuIdtcprAB7GCDueieu6G+B1+QXq8sXLT09n64VxhQ9HTYso7ah+DOsT5EO9eISyOw7miHg5E8aVNu2GHc8UzDJQP5+KbSq3rYmGnQVg3C+NDNzycK6ZD5DJR5M/zTwpheDhXswc9SYcktorF7YEG1tRxYtHhXPwxj2yOZDPxMJZmbSZPvyQkn9kt5jNbyCdem5rJSzaVnGTD8DCW0wPKj07q66lMzR7GIvXZs7yxcsLDWJo9rHaKwJXqI54phkw/ytwTyi8dQEZh3CZzOaGT6oPK1OxhLNI4Kd7+ODMgPW96IbJYCmH8uQUPY+HP082OX6m8zR7GwvVpGYSdJqRt1xel4qnv8BelpD5C0gHsb3kYlz8P4/ksE/KRsOb619ILqGiTmn0BdYrAud0OcESbxKcimz0wkB/gON4XUHHuoV3khNOX3O7gM7V0SN54ZNjMM7V0CGY7HbrIZYFysteL2TW6RtO8nx+n7cbDGKQpYOkVIhyjNmt/5gjlkPKZ3WI+syPms6TFfJaE5MPD0J42O+aeInCW8lnaYj7SBxbaqS1JY6R2O8CU1we2s6VC2phfyIw8RsIXMuN5lgt/IVN6zpH6JEorHaaNbbqVg7lxjBR3m3bpUGWuH+gatadmxkhSe2o3OeGcubTFR9smNTNG4nWFS+58Pp3u8bE9HhpH8bf78+lWR7aeMjq/RSwPvmbwdYi3RODdrvZwSTx8Qu2hZD+atYfd7LpVe4jzl1yv8NCiZuexjhXyabd2jocWcXvY7DzWeO2h1JZdGqO1gz2U+hTU26j2kOK/B9YXY7Jf4qFFOBc3Oc6Mf5yJrwC3YlfDnunw0KJmx5nzhXzazV7goUWT48yXzjgz6pgwqv3FQ+Mo/jfZePQbAeNMzsPG61ko86e41k3aTV27qTkepbqUPs6J49FFQj6LQvI5VsjHpfHoRNlNLvN2tZuLIMyl53PiHtUeUvx/aKPx6CKh/PHuUYhuV3G/26J4+KSluguzQ9LaMKWV1nNxPNrK2nDYcz6OR5t9zp8v5BPzfpWm92HgeFTqc6LaBL5fZbzP+cSt3eQUtl8F7Wor+1W4DL83zr4JbZLGmDAm2xX5EE20XXGPCSXbJbX18R+iyXcbYGlRWzAOXTc6RPP0BqXAFyd5LUexshwLXxbm6ZcB1hkNsPBlYZ4eP5tCv7u9sTzx0L4wHGy5Ei88RJNbyyiHjnIsPESz2UNHORYeojlRh46e3YAXHqJ5Fksf5aBQjoWHaEoHfBJWqgEWHqLJ0+NhI/QbXzy3DuUVhmN9ugEvPESz2Zf3ORYeotnsy/scCw/RPJqHjnJeeIimdJgCpguyZdw2SG2XH84g6Sqve17mPuEe9q4xHVoZ+RBNyr/XG1svcfSu0gEa0oFaJLt+gWtSCMNdo9LhsP1CPhLW6YpYSxWxzlDEWq6ItUwR6yxFrLMVsXKKWClFrLQiFtkxaeyFh2g2++TN0+OTHq9zPZuTzZEN4X0JOQrLC2WUbA+3i+ikpzkqk32aa+YQTS5z4kZy4vp8NOWET5lcv/AQTX4wZ7NPxFReK8NmDtHk+pSHsGVC2njlG32WjvLv9cbqQhx9sTSGl9owye4VAtekEIY2PGzMxPORsGhcJz1H4CGaZwn5nBWSz/EC53h1IVNBWXJHYdJBoRTG7T3XD3SN2lMzs3Rc5njYaLvI6SwI489bOEvHx5ut2KRmZul4XaUYPsqQx+OHaErPzxKvhIBzFsSlsA4hLR6iycPwEE3JfvB72N5OEPj2CenQLsd08Flku0z593qx9hPpMHspyVVqB68AmUttJAFhPJ+wQ4c5Fo4BwvrVeMZ30Q8lo/wnql+V+qGwQzTj1O+gej47hE9Mh8TWTmOQ5q+kcQc/RJPrkDTXhrwzDJ/uRRnz4Lx4s/OWHAvnxZudt+RYOC8uyQDnKT+98MX/VobvWTg6Ds3pfoDFeZ9/LfVZJAcb75MQD+eHrWvXA3RjOvks9ABd6XA/fohmkI7xOg5ab5AOOkWdX96AE+q8lJekE/wz0agTi1i8ZSzeZ0PinSHEQwzpEM1FEEZxv+Bj2LEaHqK5yBuNb13Mu0gi6yzuglsUD5/QXXBcPuPdBYdzsq3sgtPcidyuOzIWQdhE7DRo5hBNaR1lHIdoLgqgQ7/x4ErKqpVDNJdCeNRDNMM2RnCVOhqPJZT/RG2MaLR0j2ZiucA1KYQtYddB3ZX0ZXsJK+wFdTxEc4mQT9hLBicKnNttEygeojn5ksFL7yUDbgfxEE1+yCUegNjokMtuwO9e9OJ/qrtFLL3i8kMJ9Yby4HkvjSnvqLYWNwFKh0hIdriVwyQz5aHh/mKxkh2upIaLlXLCG2tzw+wwxZc2tC0Q4sd7UFi2SHrPD5PErXBdLGwphHWzMH64Fx4mGc9wLluMIn+ef1KIv6Faj9dMXSaFfPDQxqhYdGgjt9O+CEUbg20xHjsQfdxD+fcC17jGPYu8sXLtEuQatulWOkwHXxJqdjzCscjuT/RLQpyDYn+ek8bf5CjsVKGMFIYH+tI1OqnPpjK18pIQHgjXLnLCdi4dTis9tjY77uEybGbcw+sKD2VbJKSNV77RbRKOAWKykekwWyG14bDxitSnLGbXrfZPVJezvLF1iy/YdAn5dIXkM1/Ip93aGr5gw20S1w90mjZJak/tJqcuCGs3myTZdeTeLcRdCGEU9/V+JPvsVfGvpTYywxsdtpCFTWfXPF++ZYDiW3dHVeZ5oX9hZfLri2XMjgBMXjfW8XE9b5PWdbEwPV0bTlve9yyq80Db2F0dXSbJnkljLIof9jIQl1HSG6vXaEslG7eI3aNlGEmefL7Jui4WFrc8OUeU5+IGZUJ5SvLnciIZSf3JyYB1soDFZRwmT+J4NOTJOUaRp9QPho0DuDxJRtIzwymAJclzIbt3GXCl9FOE+ByvG+IPM5tz/HGj+c1g6VEXpgvY3IaGtbNeoRx9EMbTWtzrT6zft25qdTTuC//ZvW6G+0L5eHwI62FhXdXR+fT6v7tYPhyLeHRD/A2sL3mhDCwNpU8K+U+B/EfxFu5xHUSsTuEexbcyXe1ztHXZCzgk/5X+71STbjjfPzScyxdT5bT9mcGX9jkXm78kJ24jrCNZ87qYIpStG+JvZn38g6z9vxBXyM/G2xMSLxHw/wUM4V5XdfQ9qY647lJ8yru3OpYjhU1nYdx+WTfD/83lxbGIRzfEfxR0l+sbpU8K+U+D/EfxFu6h7k4X4k8X4r9wAKTPkfSWl137Ge+FPAGf30Nue2JsV+Wh3ODA0OBwPlVKDaYHs43albXr0327HjafGFWX8dmPY9F8Kj3T8ANnNbeuEf5U4KeEnyY5dXtj5UR5T4ulbJVKlHrg+fcC1zj0n+dHfFA+uG7RE498ynarFuketx9TBNkgj6nAsTcmjtIYlzhJayvEw8a5/NTRHDti4hhvG63U1hH5s/+66ov/X9gCuaieL68b/szM9Z737Tz+B1nf/n7WbxEupSc7NZ2FTxXC6TfVV4cQF9d6poIMJbny+KSTUwLKOgXKSvE/5pfPcpt9nIzJ5cd5dQRgfpJhboQ64eP0sDZP8acL8XkbIz6zvLFtczqk49x7vNGO35PqJwFxsQ/m635TIe7UgHxQHhKHaQIO9pOIiXmiPliHz0idQj68TfE+v0fIX7F/yEt9JTkKw4PreRgv+1ur9XjopDlEKpMt7/5FdVyMh3yktqY5NqL73ew+5tsJcadAXFyP5By7FTgmhXymAO7UEP4JwOkS0vV5cnuU/kflmxD4Sn1Nq/lwrFuqo/Ph9cz7tO8uquOiHe8U0j5UrYfz+H/B+rQ/i9inoS3hZShW6/fQZuM4FtskzjNh34VxeD/O43+f2abZ8DwyRcjP3vsbkKc0RpDGfThG6F5cx/whyFMaA8zyxsoGdbgH8uLjY+pfUAb/yur1R4uC8yK59oWU0d7790VyPM6Bx0MMqe8kDKldU7pZAi9se2g7poTkIfVnUh7dENZq/Uj9Nh9rSGMYKZz35zwfvNchxG80/ugNwJZwpwg4kp2fBmEJIQxtGC8vt2E4NpGeybhtlNpdUN2Fjb0l7lHGVVNCuEvy43ZIey4nVUilU8MD+UolXeovDuUazeVo55/JDxaKg0OpdKaSyWQL/ROdf3+uP10oFAvD/cOVwdzw0ETnPzzYXxnMZofS2cFSeTA94eUv57JDlXTFzOdlK6lsIT3R+ZvZ+Uw5lx4ayqfLxcHBSjNziZJ95n0Fb0P8Pm9/tGcA++slfn8d71ybfJBwlD5OKp9kX64PKN9r2Xjk9MWN8wuzmVJf2AFh3C5iHdXmzyOWgeKf7fPm8wbSvBefc7Ouqzq6fCv9+6nWXE5a2+XP693V0eUOm6uwDsfJM4T4fA0UxzR87RSf5boFLKlfQj2b4snjXsJDPRtkdYRru1zne4E7LzuOFTqFfMPmOCzP66A9x7QuMCDNKZDr8+TxDQ/j7QT37OFcMQ/jetDs/laSheV1fYR9UJKdQFsgzftJdoLv9XqBX3Usr6PRbvkYG9utNCfJ41PbSXpj6w31VRo7Sm0Ax5ydIflJz0u8DQStyXGbwOcUboR9YNKcAk+L9prir2V9zs3Q53D7hPoi2Rnk4nmyHYsy1yQ9u1K9SOt8mnOXCciPysHv8fx7vVjtVxrtPZdr2FpbTOOjHPGRnnmlerZrczO9sXUmPV/zeVY8zlma+5RsG46PJNsmtXW0A9Iza9jcRFhb5+tLUcaOUjvGds7jb2TteHfI2DFons/zwuswrM65fHEuRlqvCZunCbPn00J4NVpjQl7SGpMn5N2oDGF6J42vj2Kfmpf6VF527FPDxrbWYR30CfGl8W4S4nOZh809Se1yOoRFbZd8HLo7oC/l5eB2FueHpPbJ+2jeryeAC8+Dz5/Rkd4JyGOKEJ/jdUP8J4SxPmKSrbHuwepYTOTM73O54HM7xTvMONxy6ovXUd5hjGnvSuT3iWt7NwV5xNG/S89/0r7imJ+XhsPagTTuw+crrDvehoP2IeA6J+8buN3Hefv3+LqVBEzr6PyQhBAmrWnxvXrPLx5dtrjWVvG9mqB9MR8EG8Xbu7Q3gOwHtsWPsnHCR2CcIOn+dC/cZkl7cVB/gvazoM2i+J8MsVnScw7n9WBVxvyMMC8VphdS/aEu8/hh64XSOp30LhFvTy9gV8dixjxGKEljBC4fHCOEycK6ZsePpB9JiM/lKLUjnAMN01XrwvbO8PcLqN2pz/Gn0+lKf26o0D+cSVVKwxM9x5+rDBT7KwOpfKaUK2dKxWbm+MNknBBkPCtExlHHQ4iVCMHqboCFRz4GtUFMN0Hjk8hH0OH4JJ49oeHjEy4fnBuVxgpJIQyfgZudP5LmPDWwsG/m2EFtQ3pm5zLyPHm8w2V7RfXF//HuR04NSc+AHpR5hsA5IcSX5rD5/uVhNu7HeJgnl90MCON2vg/CeD8yE8J4PzILwqQ5xiht0Low/ekOKJdGPlLfJ/XXreYjzdehvDXykeYCpXkUbN9h+26kfBJCPtKzKB97/3yxnGfQGBTn2in+giV1THrJk+KQjDpYnD7/ukfgrmgHBqX1FQ9kw20QztHzdS7UeW4/UE/5/A/q1kzGge/LRifZHYpnMUci2B1J1jH1pW0l66jyJFnYdF9owo5zfaUy8efJsHbE88V2dAJrI2csqcfn+XhetGe5RvPG+CwnzRu3az8t1T3qzEwWhjozi4Vh++RHO3OZoGs0LojaPrGeJbsfdK4A6hWf+/15k3O0CSGPKM833Q2wojyThGFFfVaafL4Z45x6vulSxEpAebjsGz37N9Jn1MGwZ2yeboJ0MPIaP+pgIh4+6ahyHa8OaupNu2PF+T671G6C5uyvgz6L0gXN2eNzA8V/Exvv3OBfR33vB8uJeeKewkb7+nH8FLaXnucl7eEIe6cjaM8wlx0vG+0VwX0RQ768Gu1HPZpr8BM5v04yk+bXw/Zt4tiwU8DkOj85JzY5JzY5Jyb/j5pPO8+J7Qp4HguaE0P7TPHfw/q2xwLmxPaxOE9Nzom94CZiTuypyTmxF5wLc2LvZ23kM5NzYoH99EtpTuwzATaY8kAbHHVObJcwhqN4+E4RH8fRfit8frl3aR37y2DjCe+Xmf5+dclonrzcb6qODpP2Ntt7m/w8Jdtl/Ur/d6olN1AMG8fE+55CbjjKuILnP1FngkV9T0Eao+KeXT6eeqRaj4dhncK9jhCsg4pYRxSx9ihibVHE2qeItVMR60lFLE15aZZRi5dkB9tFVw8rYmm2bU2dOKCINWm/Ju1XnGXUlP0uRSxNvX9KEUuzbbdre9S00e3a12rW425FrJdDP/RyKKMmL0272q79dlURS5OXpryeUcTar4ilOTZp1z5tsj0evTK2a7/9cnhO09SJRxWx2lXvDylitetcx9OKWHHaaIrL1zbo7AHr6HvruEaxHtYEYpqXL4XtBYj3Oxi5yGcb4Dq/dFZtrxDWyjunQ+lKtpwaGsplhkr5/v7+BOATV7yHc5ZRvz9Asp4ej6yHpH1kvUyu1nWxsB4I62ZhxNHKHr+VHs8aam4oivx5/kkhPp6xELUu6fvm01g+YefDr62ODpsicODrfmH71KT1T35WQXVpnStPh3rWCWl5eILlL93n1wm4z/Pl+V1XHZ0O1xyRC5a3U+ApyaJDkIW0f6ETMHg75XtRbR2/xPaPl6Pa2XbdPx7zGTIl1EfOp93OkDng67i0vy9oH7IncKC8PZ/LXmg7R3s/+pGlo9NQuqhnyFD859h+jmf868n96KPLhufQUPz3+vKyutcG+9HLlsdLeT/6ESbvyf3oY8s4uR9dLpdGPpP70YNtgPZ+9N9aKucZ9Zwwiv/3rG/7naWj45CMfo/F+QuYU+DcFe3A5H50b6ysJ/ej1+O02370f2Jt5GfQNif3o78096P/LMAGUx5og2ms32g/Otl27TPwBjLD+WI2P5gaLucHiv0DzZyBNzmGrMeZHEPK5dLIZ3IMGWxLtMeQJ58q59nsOV+Dp9YxF506Og7JaAmLc7Z/PTmGrMdDpzWGRFlPjiHrcdptDPlq1kYugbY5OYZ8aY4hLwmwwZQH2uCoY8iTWbt/4V61Hk+xDjNUnu5qnTPJpqta5z2F8bZuGgujeMS1Jx6uKeLa6+NT++R58rJ0QHy87oZ7b2V1yctI5eD3OD7Fn87CKH4nu0ccSX+nsLDp1eawpgHW1BawiFdSiD91nLwkrCmA1SNg8Xt8bepqv27iOFu8OFAezPVnM8PZymCxkCo081yFa8mjyueN1h3l9hD5XDq6N1Hn0nUCH5QPXUs2kNLiGop1uHdDOu9Q+v7IRGFJ65moCzF9kyXy+XCUf68Xq26mw+TaKchVesbGb5/x51SsP2kfgbTHyhUsSm+d9BxI+welMS3KFNs7D5PW3ifyG8k74PlmGnBd6f9OteiO1jeS38meCXaf2ji/dvxG8uM+70Z7ACa/kRzt7Fsuc9w/Mt5vJD/L6uhofiP589CeY9qv5fw3kn8vwvPl5DeS606aQ6W2k/TG1hvqK28DPRDG24DGN5I/z55VpH5UGuMQR6oLaf+oddiPUvyvQbuL6VvDYj/K7T6WTzHvfmldhJy0DoNtXuo3JXuAbV6ad4va5kkWzbZ5aRwY9n3csO+7Sm0A2wdvA9i/8X4g6Bul1tF7LAnA9Lzwvk/ai9noeZu3Cb4m8ocwH0f58TEPTxv0nfEfsXHbd2HcJq2hTn5nvP5/8jvjY/lI9Tz5nfH4vzP+b6wdTzttdPklO5oAfp4XXodhdc7lS1wnvzMuP6MexXHp5HfGWRh/lqP2EtZ/cTuLa1tS++R99CqfMOUZ17w0rgNq4hdS+WFcM1fmn4157T8d8zpFivSNxlpSWazDuUyexur6bK9+fSpLY90bGXYCwm4Q8qWwG6syD+vexMLQTt3EwkjP45zzMHo2EPf4bq7AH+f0zq3GknetjZ7n43t62CnCPp9xT8TA/YJ48DOEf2E8ss8S/kXx4Nf4XxwPfo7wL4lH/jX5XMrwPU9fPy+Lh38N//J4+Nf0/4pY+Gdq/K+MBb+/xv+qePBr+nl1PPh5wr8mHvxBwr82Hvwy4b8hHvwK4V8XC/5AjuaohvyGFbYPAP973tg5FOtqe5e8WMdmTa/TS+cb4LN6s3spePo4vonWG8B5pf871ZoLPctAKrc0b4MybHbfgLRWF/N8fCrmNb48yUKa35N0k+JPazJ+T5PxpTmYrpD405vEn9Fk/L4m489sMv6siPFxDy5hWEe6Mpvd1xxjRrEJPP9e4KptE/ogP0kWc+LJuz+qLOaALGKqm3TM5a3Z37lQXqxfyj8J8bHsPK6EZR3pvG2rZG9WlTdesWZjeUNHABavD54nxsdrct0BOJ3e2DaHaYP2mWCaaQH3ewLu9wbcnx5wf0bA/b6A+zMD7s/yZEfzExS3G8LPr4bH5+sZXkDeKN+4f3sTmJcGV9JJ6ToREqcvAN+6mOcoI9tMujdR52N1Ah+Uz3j3Up9XrcfDsChjdhewLouBl+aznTR2p3hhbWG8+fB0+L5VhxBmbeEwcCOZ8HVYnnY2C+fxT07UMSuQt/SMF/Nc90DU9o57GeJ+hpSedSQdlfY0hX2LjM9dYljYOrKEdd7LAOuyGHjF/R48vhMq9QVhewyi7CFv9r12aW055ndh+hvZtK0BZQqyafwcRx7/Txnmw95oGUo2JGqfTmPSWQKXKPNEHOsiwJLmicJsD8e6ELCksx7C2gvHuhiwgvY/Bekcly+N2SXd7mkSC9vQFAFLOvfA+pX+71RLLtcvtQ89/P7hngDZKOEPSO9kYL8ezxnX6ch7FCn/XuCqbItq/XrUd1Ck9+ZxLw8PQx2U5g5nCPkkhTBcX2sF6xolLKkdtMLraiVe1l2liHWFItZ1ilhvUMTSKqNku9pFJzRlr6kTmm1bk9e1iliauqpZj6RfNH6kuH/g/5fGE4p9Yn+U5+yemPJOQH4kPw/Ki2deSc8g2t/3GBwsl/OZSjGdymf7s+XQ/fvSM06zfTvJekY8ss5Je6inM7la18XCeiCsm4URRzuWvjUxmn9MY7dI8pfGQzz+edV6vGbqkr7vgWMNko/UPnkY12k8r0h67yHsGTVs/zR/X0J6Z43CeoVyUBivP+xHJV2W9rYnveB6QdkHPVfz99F5/O/7/22ZT0iM5h61zFguac2+N2K5egOwugLKhe9oU/x/8P9bHdiQGI0pyZ3rKc4JcE4o9xkNsHBOgKfHZ4u+Blg4J8DT9wHWzAZYOCfA088ErFkhWLy9zBLSz4Iwno633Rewq/Uw/vxvXRcL05ybtvpxd6LOA8vL7bT1SUEWPD7pTlKIT3tCpfLOOorl7WmyvJJ+Y3l5u2m3+g07v0LSdR7/QigvPx9vekh5e49iecPqt5EtvBjKK9kvl+q30Tt6+I4lLy8/axjL62L98vGSVN6ZECa9g8jHDTgW4Xl2sHtkI6VxGceltQNc31zo52dlsQfypjhRxwsUfwnDxPGCNFefFMojrQVFmavvCsFqdq6eY+HYI2yuvtE+Sxx7SGM2HMNiPB5HGlPx8KAxIec8vQFnHOM0O46TztcKG8fRMxsfSyk+s2WovfD9cuQojO+zw+f8eSys2fN/a2eRGr+P2R+Mh3y4DOdCGB+/EjdJV/HZA3WXX9eevT1Zl7D9U/yVrP2XOuo8reN2nnjFbOf7m7XzjZ4dcFwqvfd8FPtxsbzTQsrb6N18HJdKbd+l+m10PtOFIeVtg+cssbytfEsOx6VRz9+aoHPzxPJ2NVleqf+RyjsDwjoFWeC+NOuCxmE8jO9Li1NmA4X6mdNUXzSXha6LhfP4q3wA7TOLKwPFdCVbrBTzxVIpN1xsdGYx3Z9arYd3AtcX+PvX0jnfnRDGz2qm8lM+dKY29XmIRTzwDO71PoB0RjaeLc3znwL5j+It3OPjb8TqFO5RfKt7d/iJ4jiLejjfPzScyxdT5bT9mWlUr5KcuG2xjmTN62KKULZuiH9/ol7mB5jdeCGukN8LZ5yGxEsE/H8BQ7jXVR19T6ojrrsUn/LuFThSGD+XnNs962b4v7m8OBbx6Ib4O0F3ub5ReulcdH7OPOYl5Y+6K53JPl2Ib+tnBOwRL7v2vpcX8gR8fg+57Y6xXZWHcoMDQ4PD+VQpNZgezEY5432IBUrjdN43nVcdHUZJb+yol++JxOg4hPcka2cHoX/m/Oh8AzwDjnOx9673f0jnxli/0v+dasnlytL7pXr4/QVpD7ge/kDtXJ1p8eAX491nN5Ah/N545J+V1nsV+eel9XA9/ExJmvtQ5F/Tz5nxyL9Wv7Pi4V97fzsZD37/0XsHNjccZYzB84/7HdgE5Ed8UD64D3SuwFV6fxVtvPQu7Fwhn6QQhvuoWsG6ThHrakWsK5SwpP6vFV5XKvKaqshLS16aZdTkJY0D2kFXpfFDu7RtTZ24VhFr0n5N2q84y6gp+15FXlp6b6+nK/LSbNvt2B61bXS79rWa9XiVItbLoR96OZRRi5e2XW3XfhvnTdpFvzTtKs7dtMLrGkVems9W7TrGnGyPR6+M7dpvvxye0zR1AueGX4p6j/PT7TKO1nweSiryitNGU1y+r4fO/rGO3vfANcxrYc0wnjNjc6WwM3Ck9TjNvBOQn+fJawL4jp50xlKvENbK+vRQupItp4aGcpmhUr6/vz8B+MQV7+G8v7T/WlpfkNYOFWU9FLavT3oXdRqEdbMw4ii9ixrPe8u5oSjy5/knhfjnVevxmqlLeheVjzHx3VCuw/jdnSkCB74vQHpnNQH40j4/+7/YUefK03GOvHxh38PrDLjPrxNwn+fL87ugOjodD0sIXLC8nQJPSRYdgiyivB/M2ynhxbHPJVcZKPZXBlL5TClXzpQa7gsc9K97IEy3PcX9Dab6Nwq8ePhn4z2zLJOPt9+tf4PpvGodX/rGbCfEwzQ2XLJBFEfac6RXz7mY5ZTJSnuONPUIbRHJHMsUdIYAhUv/CQvDKK+JOsNSKlvYOaua30yVsI5mnUrv3Uljow4I62JhUyCMj43494UXsnhBfQ72d9bdWq1jrGB4Z/rXJL84bXdcNsO6uQJ/npd17b4vfrn/u533xS/xr6d79T20WYYX1EY6vLF40hmT/HugMbbnDHGVzouWvo1n5+GP8a83bFyzvnzxXeffWx7etPG2NXedWxy+teyB441PGtwGffydN9xO4X6HN7oz4M5WSLu/LFPwfx/tl2VO8K/dHhTnChM1KI5p0Joj/Jg+MCQOiiWDQzpMD5n8mjhRnAtZnAtZHOvCBs7SC2/nQxhvSxdAmPRiPH40lfQ+3g49VziaHTp1PGSQrXFe6F/ftWbjbZX7zr9r3abypnLpqk1Dq28bvmDTXcMvGurVqz1wOOhOwO8O+I02uUvAQcfTJVgZ2t1WH+//Ptq2Gl+Ojukg39pHTOM5/K5ui7jjL1jjB3WkiX6PcZN+d8D/sLiJENw+IYwwaXGC88WDaOj/MQw3jn51Xjz4Yl0dw67nQTm5vFcqcSA8arPdAqcOCKsN+IFfQp9f2gPXKeRFjnRmHrtH8vz/xZLqVgOeCQA=",
      "debug_symbols": "vb3driQ9cp57L3Osg2Iwfhi+FWNDGMtjY4DByBhLBjYE3/uuDJLxRner2Lmq1rdP3I9H34oni5kRmUkyyf/403//y3/79//5z3/9+//41//9p//yX//jT//tH3/929/++j//+W//+i9//re//uvfn//rf/zpcf0/jcaf/kv7p+e/Pv/tj/VvW//S+revf3n9K+tfXf/a+nfF6yser3i84vGKxyser3i84vGKxyser3i84smKJyuerHiy4smKJyuerHiy4smKJyuerni64umKpyuerni64umKpyuerni64tmKZyuerXi24tmKZyuerXi24tmKZyveWPHGijdWvLHijRVvrHhjxRsr3ljxxornz3hy/dvWv7T+7etfXv/K+lfXv7b+Hetfj3/p8Vj/tvXvM55e//b1L69/Zf2r619b/z7j+fXvdXz9Ce2xoW2gDX0Db7h+tV2gG2zD2HBFHk+gx4a24YrcLugbeMMzMl0K0g22YWzwBVfSTGgbaEPfwBt25L4j9x2578h9R+YdmXdk3pF5R+YdmXdk3pF5R+YdmXdk2ZFlR5Yd+coluk7mlUwTZINusA1jgy+4UmpC20AbdmTdkXVH1h1Zd2TdkXVHth3ZdmTbkW1Hth3ZdmTbkW1Hth3ZduSxI48deezIY0ceO/LYkceOPHbksSOPHdl3ZN+RfUf2Hdl3ZN+RfUf2Hdl3ZF+R++OxoW2gDX0Db5ANusE2jA07ctuR247cduQrB2lcwBtkg26wDWODL7hycELbQBt2ZNqRaUemHfnKwd4vGBt8wZWDE9oG2tA38AbZoBt25L4j9x2Zd+QrB7teQBv6Bt4gG3SDbRgbfMGVgxN2ZNmRZUeWHfnKQX5coBtsw9jgC64cnNA20Ia+gTfsyLoj646sO7LuyLYj245sO7LtyLYj245sO7LtyLYj2448duSxI48deezIY0ceO/LYkceOPHbksSP7juw7su/IviP7juw7su/IviP7juwrMj8eG9oG2tA38AbZoBtsw9iwI7cdue3IbUduO3LbkduO3HbktiO3HbntyLQj045MOzLtyLQj045MOzLtyLQj047cd+S+I/cdue/IfUfuO3LfkfuO3HfkviPzjsw7Mu/IvCPzjsw7Mu/IvCPzjsw7suzIsiPLjiw7suzIOwd55yDvHOTIQbrAF0QOBrQNtKFv4A2yQTfYhh1Z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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBzJwAABAMnAgQEIicCBQQAHwoABAAFgFEdAIBSgFICHQCAU4BTAh0AgFSAVAIdAIBVgFUCHQCAVoBWAh0AgFeAVwIdAIBYgFgCHQCAWYBZAh0AgFqAWgIdAIBbgFsCHQCAXIBcAh0AgF2AXQIdAIBegF4CHQCAX4BfAh0AgGCAYAIdAIBhgGECHQCAYoBiAh0AgGOAYwIdAIBkgGQCHQCAZYBlAh0AgGaAZgIdAIBngGcCHQCAaIBoAh0AgGmAaQIdAIBqgGoCHQCAa4BrAh0AgGyAbAIdAIBtgG0CHQCAboBuAh0AgG+AbwIdAIBwgHACHQCAcYBxAh0AgHKAcgUuCIBRAAEoAgACBIBSJwIFBCAtCAEEJwIGBCEACAEGAScDBAQBACIEAgYuAgACgAMuAgAGgAQuAgAFgAUlAAABcS0KBAIuCIByAAMlAAABtyUAAAIaKAIAAQSAcycCAgQAOw4AAgABAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAG2LgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAGFJigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYGAAAoAIBHAAAAKACASAEAASgAgEkEAAEoAIBKAAABKACASwQAAigAgEwEAAQoAIBNBAAFKACATgQACygAgE8EABcoAIBQBAAgJiUAABLTHgIABQAeAgAGADMqAAUABgAHJAIABwAAAj4lAAAS/B4CAAUBHgIABgAKKgUGByQCAAcAAAJaJQAAEw4eAgAFBigCAAYFA4QAKgUGBw4qBQcIJAIACAAAAn0lAAATIAwqBwMFJAIABQAAAo8lAAATMicCBQACLQgBBicCBwQDAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIggCCC0OAQgnAggECS0IAAktCgYKLgiASwALLgiARAAMAAgACAAlAAATRC0CAAAtCgoHCyIAB4BHAAgLIgAIgEQACSQCAAkAAAMFJQAAFRIeAgAIBicCCgQLLQgACy4IgEQADC4IgEcADS0KBQ4tCgcPAAgACgAlAAAVJC0CAAAtCgwJLQgBBwAAAQIBLQ4JBy0IAQkAAAECAS4MgEUACS0IAQonAgsEGAAIAQsBJwMKBAEAIgoCCycCDAQXACoMCwwtCgsNDCoNDA4WCg4OJAIADgAAA5wuDIBHAA0AIg0CDSMAAAN7JwILADcnAg0EDi0IAA4tCgcPLQoJEC0KCxEtCgoSAAgADQAlAAAV8S0CAAAtCg8MLQsMBwAiBwIHLQ4HDCcCCQQNLQgADS0KDA4uCIBJAA8ACAAJACUAABa0LQIAAC0KDgctCwwJACIJAgktDgkMJwIJBAwnAg4EDy0IAA8tCgwQLQoJEQAIAA4AJQAAFrQtAgAALQoQDQEiAAyASQAPLQsPDhwKDg8EHAoPDAAcCgwOBScCGQQaLQgAGi0KBxsACAAZACUAABfiLQIAAC0KGwwtChwPLQodEC0KHhEtCh8SLQogEy0KIRQtCiIVLQojFi0KJBctCiUYJwIjBCQtCAAkLQoNJQAIACMAJQAAF+ItAgAALQolBy0KJhktCicaLQooGy0KKRwtCiodLQorHi0KLB8tCi0gLQouIS0KLyIMKggODRYKDQgcCg0OABwKCCMABCoODCQEKiMHDAAqJAwHHAoNDAYcCggkBgQqDA8lBCokGQ8AKiUPGQQqDhAPBCojGg4AKg8OEAQqDBEOBCokGw8AKg4PEQQqDBIOBCokHA8AKg4PEgQqDBMOBCokHQ8AKg4PEwQqDBQOBCokHg8AKg4PFAQqDBUOBCokHw8AKg4PFQQqDBYOBCokIAwAKg4MDxwKDQwCHAoIDQIEKgwYCAQqDSIMACoIDA0nAggCAQoqDQgMJAIADAAABbAlAAAZLQsiABGARgAIJAIACAAABcUlAAAZPwsiABKARgAIJAIACAAABdolAAAZPy0LAggAIggCCC0OCAInAg0EIi0IACItCgIjAAgADQAlAAAZUS0CAAAtCiMILQokDC0LBg0AIg0CDS0ODQYnAg4EIi0IACItCgYjLgiASwAkLgiARAAlAAgADgAlAAATRC0CAAAtCiMNCyIADYBHAAYLIgAGgEQADiQCAA4AAAZfJQAAFRInAg4EIi0IACIuCIBEACMuCIBHACQtCgUlLQoNJgAIAA4AJQAAFSQtAgAALQojBi0IAQ4AAAECAS0OBg4tCAEGAAABAgEuDIBFAAYtCwoRACIRAhEtDhEKJwISBCItCAAiLQoOIy0KBiQtCgslLQoKJgAIABIAJQAAFfEtAgAALQojES0LEQYAIgYCBi0OBhEnAgoEIi0IACItChEjLgiASQAkAAgACgAlAAAWtC0CAAAtCiMGLQsRCgAiCgIKLQ4KEScCCwQiLQgAIi0KESMtCgkkAAgACwAlAAAWtC0CAAAtCiMKASIAEYBJAAstCwsJHAoJDgQcCg4LABwKCwkFJwIfBCItCAAiLQoGIwAIAB8AJQAAF+ItAgAALQojCy0KJA4tCiURLQomEi0KJxYtCigYLQopGi0KKhstCiscLQosHS0KLR4nAioEKy0IACstCgosAAgAKgAlAAAX4i0CAAAtCiwGLQotHy0KLiAtCi8iLQowIy0KMSQtCjIlLQozJi0KNCctCjUoLQo2KS8KAA0AChwKCisEHAorKgACKgoqKywCAAoALV4Ji4K6N7Q7maExYRj9INQvUWbJ6fE/teplqW0eCm0EKisKKhwKKiwEHAosKwACKiorLAQqLAoqHAoqLQEcCi0sABwKLC0BAioqLC4sAgAqADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCouKi8cCi8wBBwKMC4AAiovLjAEKjAKLxwKLzABHAowCgAcCgowAQIqLwoxBCoxKi8cCi8xBBwKMSoAHAoqLwUWCjAqHAoKMAUcCioxBQQqMC8qHAouLwUWCi0uHAosLQUcCi4wBQQqLS8uHAorLQUeAgAvBgwqLy0yJwItBbQkAgAyAAAJIyMAAAkGHAosFwUEKhcuIQQqMC0XACohFy0tCi0EIwAACUAcCgoXBQQqFyohBCoxLRcAKiEXLS0KLQQjAAAJQAAqLwQhDiovIS0kAgAtAAAJVyUAABMgDCovCQQWCgQJHAoELQAcCgkvAAQqLQswBCovBgsAKjALBhwKBAsGHAoJMAYEKgsOMQQqMB8OACoxDh8EKi0RDgQqLyARACoOESAEKgsSDgQqMCIRACoOERIEKgsWDgQqMCMRACoOERYEKgsYDgQqMCQRACoOERgEKgsaDgQqMCURACoOERoEKgsbDgQqMCYRACoOERsEKgscDgQqMCcLACoOCxEcCgQLBRwKCQ4FBCoLHRwEKg4oCwAqHAsOHAoECwIcCgkEAgQqCx4JBCoEKQsAKgkLBC0IAQkAAAECARwKIQsAJwIcACAnAh4ELy0IAC8tCgUwLQocMQAIAB4AJQAAGlItAgAALQowHQQqKx0cACoLHB0nAgsAQCcCHgQvLQgALy0KBTAtCgsxAAgAHgAlAAAaUi0CAAAtCjAcBCosHAsAKh0LHBwKLgsAJwIdAEgnAiEEKy0IACstCgUsLQodLQAIACEAJQAAGlItAgAALQosHgQqCx4dACocHQsnAhwAaCcCHgQrLQgAKy0KBSwtChwtAAgAHgAlAAAaUi0CAAAtCiwdBCoKHRwAKgscChwKKgsAJwIcAHAnAh4EIS0IACEtCgUiLQocIwAIAB4AJQAAGlItAgAALQoiHQQqCx0FACoKBQstCAEFJwIKBBgACAEKAScDBQQBACIFAgotCgocLQ4LHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcLQ4FCRwKHwUAHAoSCgAcChYLABwKGBIAHAoaFgAcChsYABwKERoAHAoOEQAcCgQOAC0IAQQnAhsEDAAIARsBJwMEBAEAIgQCGy0KGxwtDgYcACIcAhwtDgUcACIcAhwtDiAcACIcAhwtDgocACIcAhwtDgscACIcAhwtDhIcACIcAhwtDhYcACIcAhwtDhgcACIcAhwtDhocACIcAhwtDhEcACIcAhwtDg4cHAoZBQAcCggGABwKDAgAHAoTCgAcChQLABwKFQwAHAoPDgAcCgMPAC0IAQMnAhEEDAAIAREBJwMDBAEAIgMCES0KERItDgcSACISAhItDgUSACISAhItDhASACISAhItDgYSACISAhItDggSACISAhItDgoSACISAhItDgsSACISAhItDgwSACISAhItDg4SACISAhItDg8SACISAhIuDIBKABIuCIBFABcjAAANqw0iABeATgAFJAIABQAAEg4jAAANwC0LCQQtCwQFACIFAgUtDgUELQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkrAgAHAAAAAAAAAAAXAAAAAAAAAAAtCAEJJwIKBAUACAEKAScDCQQBACIJAgotCgoLLgyARwALACILAgsuDIBHAAsAIgsCCy4MgEcACwAiCwILLQ4HCy0IAQcAAAECAS0OBQctCAEFAAABAgEtDgkFLQgBCQAAAQIBLgyARQAJLQgBCgAAAQIBLgyARAAKLQsECwAiCwILLQ4LBC4IgEUAAyMAAA6vDSIAA4BPAAskAgALAAARxCMAAA7EJwIMBBAtCAAQLQoHES0KBRItCgkTLQoKFAAIAAwAJQAAG1YtAgAALQoRCy0IAQUnAgcEGQAIAQcBJwMFBAEAIgUCBycCCQQYACoJBwktCgcKDCoKCQwWCgwMJAIADAAADzYuDIBHAAoAIgoCCiMAAA8VLQgBBwAAAQIBLQ4FBy4IgEUAAyMAAA9ODSIAA4BPAAUkAgAFAAARdyMAAA9jLQsHBCcCBQQYLgIABIADKACABAQAGSUAABvKLgiABQAJACoJBQotDgsKLQ4JBy4IgEUAAyMAAA+cDCoDBQQkAgAEAAARSCMAAA+uLQsCBAAiBAIELQ4EAikCAAIAwdTnki0IAQQnAgUEBgAIAQUBJwMEBAEAIgQCBS0KBQctDgIHACIHAgctDgEHACIHAgctDgYHACIHAgctDggHACIHAgctDg8HLQgBAScCAgQGAAgBAgEnAwEEAQAiAQICLQoCBS4MgEcABQAiBQIFLgyARwAFACIFAgUuDIBHAAUAIgUCBS4MgEcABQAiBQIFLgyARwAFLQgBAgAAAQIBLQ4BAi4IgEUAAyMAABBuDSIAA4BNAAEkAgABAAAQ+yMAABCDLQsCAScCBAQFBiIEAgInAgYEAwAqBAYFLQgBAwAIAQUBJwMDBAEAIgMCBS0OBAUAIgUCBS0OBAUnAgYEAwAqAwYFACIBAgYuAgAGgAMuAgAFgAQuAgAEgAUlAAABcQAiAwIFLQsFBCcCBgQCACoFBgE3CwABAAQmACIEAgUAKgUDBi0LBgEtCwIFLgIABYADKACABAQABiUAABvKLgiABQAGACIGAgcAKgcDCC0OAQgtDgYCASIAA4BJAAEtCgEDIwAAEG4cCgMEAAAqDQQHACIJAgoAKgoDCy0LCwQwCgAEAAcBIgADgEkABC0KBAMjAAAPnAAiBAIJACoJAwotCwoFLQsHCS4CAAmAAygAgAQEABklAAAbyi4IgAUACgAiCgIMACoMAw4tDgUOLQ4KBwEiAAOASQAFLQoFAyMAAA9OACIEAgwAKgwDDi0LDgsnAgwEEC0IABAtCgcRLQoFEi0KCRMtCgoULQoLFQAIAAwAJQAAHFgtAgAAASIAA4BJAAstCgsDIwAADq8BIgAXgEkABQAiBAIKACoKFwstCwsHLQsJCg0iAAWATwALJAIACwAAEj0lAAAdfC4CAAqAAygAgAQEABglAAAbyi4IgAUACwAiCwIMACoMBQ4tDgcOASIABYBOAAcOKgUHCiQCAAoAABJ9JQAAEyAAIgMCDAAqDBcOLQsOCg0iAAeATwAMJAIADAAAEqAlAAAdfC4CAAuAAygAgAQEABglAAAbyi4IgAUADAAiDAIOACoOBxAtDgoQLQ4MCS0KBRcjAAANqygAgAQEeAANAAAAgASAAyQAgAMAABL7KgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQXqH6UZaDsOUDwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQUHKoPuEPeQ8DwEAgEmJQAAEtMcCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC4MgEcACAAiCAIILgyARwAIACIIAgguDIBHAAgtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLgyARwAJACIJAgkuDIBHAAkAIgkCCS4MgEcACQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLgyARQAGLQgBCAAAAQIBLgyARAAILQsBCQAiCQIJLQ4JAS4IgEUABCMAABQxDSIABIBLAAkkAgAJAAAUsSMAABRGJAIAAwAAFFMjAAAUhScCAQQJLQgACS0KBwotCgULLQoGDC0KCA0uCIBKAA4ACAABACUAABxYLQIAACMAABSFJwICBAktCAAJLQoHCi0KBQstCgYMLQoIDQAIAAIAJQAAG1YtAgAALQoKASYMKgQCCSQCAAkAABTDIwAAFQEAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBwwtCgUNLQoGDi0KCA8tCgkQAAgACgAlAAAcWC0CAAAjAAAVAQEiAASASQAJLQoJBCMAABQxKgEAAQUC3G4ngHYSnTwEAgEmJQAAEtMtCAEGJwIHBBgACAEHAScDBgQBACIGAgcnAggEFwAqCAcILQoHCQwqCQgKFgoKCiQCAAoAABVwLgyARwAJACIJAgkjAAAVTy0IAQcAAAECAS0OBgcuCIBFAAUjAAAViA0iAAWATwABJAIAAQAAFaIjAAAVnS0LBwEmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAYJQAAG8ouCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEkAAS0KAQUjAAAViCUAABLTLQgBBgAAAQIBLQ4EBi4IgEUABSMAABYODSIABYBPAAMkAgADAAAWKCMAABYjLQsGASYtCwEDLQsCBA0iAASATwAHJAIABwAAFkUlAAAdfAAiAwIIACoIBAktCwkHASIABIBJAAgOKgQICSQCAAkAABZtJQAAEyAtDgMBLQ4IAi0LBgMuAgADgAMoAIAEBAAYJQAAG8ouCIAFAAQAIgQCCAAqCAUJLQ4HCS0OBAYBIgAFgEkAAy0KAwUjAAAWDiUAABLTASIAAoBOAAQOKgIEBSQCAAUAABbTJQAAEyANKIBPAAQABQsiAAWARAAEJAIABAAAFvAlAAAdji0IAQQnAgUEDAAIAQUBJwMEBAEAIgQCBScCBgQLACoGBQYtCgUHDCoHBggWCggIJAIACAAAFzcuDIBHAAcAIgcCByMAABcWLQgBBQAAAQIBLQ4EBS4IgEUAAyMAABdPDSIAA4BOAAQkAgAEAAAXaSMAABdkLQsFASYAKgMCBA4qAwQGJAIABgAAF4AlAAATIA0iAASATwAGJAIABgAAF5UlAAAdfAAiAQIHACoHBAgtCwgGLQsFBC4CAASAAygAgAQEAAwlAAAbyi4IgAUABwAiBwIIACoIAwktDgYJLQ4HBQEiAAOASQAELQoEAyMAABdPJQAAEtMBIgABgEkAAy0LAwIBIgABgEsABC0LBAMcCgMFBhwKBQQAHAoEAwYBIgABgEMABS0LBQQBIgABgEwABi0LBgUcCgUHBhwKBwYAHAoGBQYBIgABgE0ABy0LBwYcCgYIBhwKCAcAHAoHBgYnAgcEBgAqAQcJLQsJCBwKCAkGHAoJBwAcCgcIBicCBwQHACoBBwotCwoJHAoJCgYcCgoHABwKBwkGJwIHBAgAKgEHCy0LCwocCgoLBhwKCwcAHAoHCgYnAgcECQAqAQcMLQsMCxwKCwwGHAoMBwAcCgcLBicCBwQKACoBBw0tCw0MHAoMDQUcCg0HABwKBwwFASIAAYBOAA0tCw0HHAoHDQIcCg0BABwKAQcCLQoHDS0KCQctCgsJLQoNCy0KAgEtCgMCLQoEAy0KBQQtCgYFLQoIBi0KCggtCgwKJioBAAEFVUVPBQl2Kjo8BAIBJioBAAEFJcfuEmsjjcA8BAIBJiUAABLTLQgBAwAAAQIBLgyARgADLQgBBAAAAQIBLgyARgAEJwIFBBAnAgYCCC4IgEUAAiMAABmJDCoCBQckAgAHAAAaCiMAABmbLQoFAiMAABmkDSIAAoBQAAUkAgAFAAAZwiMAABm5LQsDAS0LBAImLQsEBRgqBQYHACIBAggAKggCCS0LCQUcCgUIBgAqBwgFDioHBQkkAgAJAAAZ9SUAABMgLQ4FBAEiAAKASQAFLQoFAiMAABmkLQsDBxgqBwYIACIBAgkAKgkCCi0LCgccCgcJBgAqCAkHDioIBwokAgAKAAAaPSUAABMgLQ4HAwEiAAKASQAHLQoHAiMAABmJJQAAEtMtCAEEAAABAgEuDIBKAAQnAgYEAicCBwEBLQgBBScCCAQhAAgBCAEnAwUEAQAiBQIIJwIJBCBDA6oAAgAGAAkABwAIJwIKBCAuAgAIgAMuAgAKgAQlAAAdoCcCAgQhLgiASQADIwAAGsAMKgMCBiQCAAYAABrXIwAAGtItCwQBJi0LBAYEKgYGBwMogFAAAwAGDyIAA4BQAAgkAgAIAAAa/SUAAB4gDSIABoBQAAgkAgAIAAAbEiUAAB18ACIFAgkAKgkGCi0LCggcCggGAAQqBwEIBCoGCAkDKIBKAAYACAQqCAcGACoJBgctDgcEASIAA4BJAAYtCgYDIwAAGsAlAAAS0y0LBAULIgAFgEQABiQCAAYAABt4JwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAAHjItAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLgyASAAEASIABoBJAAItCwIBJi4BgAOABgsAgAYAAoAHJACABwAAG+UjAAAb8C4AgAOABSMAABxXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAHEMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAHBIoAYAFBAABAwCABgACgAYjAAAcVyYlAAAS0y0LBAYLIgAGgEQAByQCAAcAABx6JwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAHQ0jAAAcky0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACiQCAAoAABy4JQAAHXwuAgAHgAMoAIAEBAAEJQAAG8ouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaASQAFDioGBQckAgAHAAAc+CUAABMgLQ4KAS0OCAItDgUDLQ4JBCMAAB17JwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAHjItAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAABvKLgiABQAJASIACYBJAAotDgUKLQ4JAS0OBwIuDIBJAAMtDggEIwAAHXsmKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAHh8DAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAdvCYqAQABBSiGkrBH3P1DPAQCASYlAAAS0y4IgEUABSMAAB5CDSIABYBDAAYkAgAGAAAerSMAAB5XLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAewyMAAB8vLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAbyi4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAB8vASIABYBJAAYtCgYFIwAAHkI=",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+x9B5xUxdL9StxdYBcWzAlz1tsT75hzzkqUNJEgIGBOmBWzoiAqSs45iIKAOeeMoJhQMWHO6d/1nH30Dr0S5tT9V7+P+/3qo6flNedUVVfXuffu7AYl/1w3blhSss1G/4w30FY3/2cdbS0L5qr/NMf1LX+v3DLX2DJXYZlraplrbpnTsEsOLJjbRNulBXObWua2sqy3tWWupWVuG8vctpZ/YzvL3PaWuR0sczta/o1dLHx3s/xvd9dWWjC3h2VuT8vcXpY5zzKnLHMhy1zYMhexzEUtczHLXNwy51vmEpa5vS1z+1jm9rXM7WeZ298yd4Bl7kDL3EGWuYMtc4dY5g61zB1mmTvcMneEZe5Iy9xRlrmjLXPHWOaOtcwdZ5k73jJ3gmXuRMvcSZa5ky1zp1jmTrXMtbLMtbbMtbHMtbXMtbPMtbfMnWaZ62CZ62iZ62SZ62yZ62KZS1rmUpa5tGUuY5nLWuZylrmulrlulrnulrkelrnTLXM9LXO9LHO9LXNnWOb6WOb6Wub6WebOtMydZZk72zJ3jmXuXMvceZa58y1zF1jmLrTMXWSZu9gy198yd4ll7lLL3GWWucstc1dY5q60zF1lmbvaMneNZW6AZe5ay9x1lrnrLXM3WOZutMzdZJm72TJ3i2XuVsvcQMvcbZa52y1zgyxzgy1zd1jmhljm7rTM3WWZu9syN9Qyd49l7l7L3DDL3HDL3AjL3EjL3CjL3GjL3BjL3FjL3DjL3HjL3ATL3ETL3CTL3GTL3BTL3FTL3DTL3HTL3AzL3EzL3CzL3GzL3H2WuTmWufstcw9Y5uZa5uZZ5h60zM23zC2wzC20zD1kmXvYMveIZe5Ry9xjlrnHLXNPWOaetMw9ZZl72jL3jGXuWcvcc5a55y1zL1jmXrTMvWSZe9ky94pl7lXL3GuWudctc29Y5t60zL1lmVtkmXvbMrfYMrfEMveOZe5dy9xSy9x7+Tnz2iD/54H5P8NeLBLJxkNZFVZJL5RI+VEvEk3FfOWrqB/NhPxwOOtH/HgilYh7CRUJZ1UumgjnvH+ux+uuXMsr6gqlOXE+sc44U6nCGcJWpa2egZX88Fd+vFPJyvHOxviJ/N+p/t89qT8/pe1pbc/UXTlffdUt8IFX3KV2Aa71ZF1cbJ6F5ZDncfpvV+BaTwH995wj/tsNuNbTQP89D/SfrTY8a9SG54zx88b4mYLa8IL+/KK2l7S9HEBt2B241gvA2LziSG7vAVzrRaD/XnXEf3sC13oJ6L/XmGvDK0YNeNUYv2aMXy6oDa/rz29oe1PbWwHUhr2Aa70OjM0iR3LbA671BtB/bzviPwVc602g/xYz14ZFRg142xgvNsZvFdSGJfrzO9re1bY0gNoQAq61BBib9xzJ7TBwrXeA/nvfEf9FgGu9C/TfB8y14T2jBrxvjD8wxksLasOH+vNH2pZp+ziA2hAFrvUhMDafOJLbMeBaHwH996kj/osD11oG9N9y5trwiVEDPjXGy43xxwW14TP9+XNtX2j7MoDa4APX+gwYm68cye0EcK3Pgf5b4Yj/9gau9QXQf18z14avjBqwwhh/bYy/LKgN3+jP32r7Ttv3AdSGfYBrfQOMzQ+O5Pa+wLW+BfrvR0f8tx9wre+A/vuJuTb8YNSAH43xT8b4+4La8LP+/Iu2X7X9FkBt2B+41s/A2PzuSG4fAFzrF6D//nDEfwcC1/oV6L8/mWvD70YN+MMY/2mMfyuoDX/pz3/X/Wdig3r8teEg4Fp/AWNTp54buX0wcK2/gf6r64j/DgGuVVIP57969XhrA+V3dQ2oa4zrGeMN6tWsDfX1oIG2htpKA6gNhwLXqg+MTZkjuX0YcK0GQP+VO+K/w4FrNQT6rxFzbSgzakC5MW5kjEsLakNjPWiirUJbZQC14QjgWo2BsWnqSG4fCVyrCdB/zRzx31HAtSqA/qtirg1NjRrQzBhXGePKgtrQXA9aaNtQ20YB1IajgWs1B8ZmY0dy+xjgWi2A/tvEEf8dC1xrQ6D/NmWuDRsbNWATY7ypMd6ooDZspgeba9tC25YB1IbjgGttBozNVo7k9vHAtTYH+m9rR/x3AnCtLYD+a8lcG7YyasDWxrilMd6yoDZsowfbattO2/YB1IYTgWttA4zNDo7k9knAtbYF+m9HR/x3MnCt7YD+24m5Nuxg1IAdjfFOxnj7gtqwsx7som1XbbsFUBtOAa61MzA2uzuS26cC19oF6L89HPFfK+BauwL9tydzbdjdqAF7GOM9jfFuBbVhLz3wtCltoQBqQ2vgWnsBYxN2JLfbANfygP6LOOK/tsC1FNB/UebaEDZqQMQYR41xqKA2xPQgrs3XlgigNrQDrhUDxmZvR3K7PXCtONB/+zjiv9OAa/lA/+3LXBv2NmrAPsZ4X2OcKKgN++nB/toOIGwB1IYOwLX2A8bmIEdyuyNwrf2B/jvYEf91Aq51ANB/hzDXhoOMGnCwMT7EGB9YUBsO1YPDtB2u7YgAakNn4FqHAmNzpCO53QW41mFA/x3liP+SwLUOB/rvaObacKRRA44yxkcb4yMKasMxenCstuO0HR9AbUgB1zoGGJsTHMntNHCtY4H+O9ER/2WAax0H9N9JzLXhBKMGnGiMTzLGxxfUhpP14BRtp2prFUBtyALXOhkYm9aO5HYOuNYpQP+1ccR/XYFrnQr0X1vm2tDaqAFtjHFbY9yqoDa004P22k7T1iGA2tANuFY7YGw6OpLb3YFrtQf6r5Mj/usBXOs0oP86M9eGjkYN6GSMOxvjDgW1oYseJLWltKUDqA2nA9fqAoxNxpHc7glcKwn0X9YR//UCrpUC+i/HXBsyRg3IGuOcMU4X1IauetBNW3dtPQKoDb2Ba3UFxuZ0R3L7DOBa3YD+6+mI//oA1+oO9F8v5tpwulEDehrjXsa4R0Ft6K0HZ2jro61vALWhL3Ct3sDY9HMkt/sB1zoD6L8zHfHfmcC1+gD9dxZzbehn1IAzjfFZxrhvQW04Ww/O0XautvMCqA1nAdc6Gxib8x3J7bOBa50D9N8FjvjvHOBa5wL9dyFzbTjfqAEXGOMLjfF5BbXhIj24WFt/bZcEUBvOBa51ETA2lzqS2+cB17oY6L/LHPHf+cC1+gP9dzlzbbjUqAGXGePLjfElBbXhCj24UttV2q4OoDZcAFzrCmBsrnEkty8ErnUl0H8DHPHfRcC1rgL671rm2nCNUQMGGONrjfHVBbXhOj24XtsN2m4MoDZcDFzrOmBsbnIkt/sD17oe6L+bHfHfJcC1bgD67xbm2nCTUQNuNsa3GOMbC2rDrXowUNtt2m4PoDZcClzrVmBsBjmS25cB1xoI9N9gR/x3OXCt24D+u4O5NgwyasBgY3yHMb69oDYM0YM7td2l7e4AasMVwLWGAGMz1JHcvhK41p1A/93jiP+uAq51F9B/9zLXhqFGDbjHGN9rjO8uqA3D9GC4thHaRgZQG64GrjUMGJtRjuT2NcC1hgP9N9oR/w0ArjUC6L8xzLVhlFEDRhvjMcZ4ZEFtGKsH47SN1zYhgNpwLXCtscDYTHQkt68DrjUO6L9JjvjveuBa44H+m8xcGyYaNWCSMZ5sjCcU1IYpejBV2zRt0wOoDTcA15oCjM0MR3L7RuBaU4H+m+mI/24CrjUN6L9ZzLVhhlEDZhrjWcZ4ekFtmK0H92mbo+3+AGrDzcC1ZgNj84AjuX0LcK37gP6b64j/bgWuNQfov3nMteEBowbMNcbzjPH9BbXhQT2Yr22BtoUB1IaBwLUeBMbmIUdy+zbgWvOB/nvYEf/dDlxrAdB/jzDXhoeMGvCwMX7EGC8sqA2P6sFj2h7X9kQAtWEQcK1HgbF50pHcHgxc6zGg/55yxH93ANd6HOi/p5lrw5NGDXjKGD9tjJ8oqA3P6MGz2p7T9nwAtWEIcK1ngLF5wZHcvhO41rNA/73oiP/uAq71HNB/LzHXhheMGvCiMX7JGD9fUBte1oNXtL2q7bUAasPdwLVeBsbmdUdyeyhwrVeA/nvDEf/dA1zrVaD/3mSuDa8bNeANY/ymMX6toDa8pQeLtL2tbXEAteFe4FpvAWOzxJHcHgZcaxHQf+844r/hwLXeBvrvXebasMSoAe8Y43eN8eKC2rBUD97T9r62DwKoDSOAay0FxuZDR3J7JHCt94D++8gR/40CrvU+0H/LmGvDh0YN+MgYLzPGHxTUho/14BNtn2pbHkBtGA1c62NgbD5zJLfHANf6BOi/zx3x31jgWp8C/fcFc234zKgBnxvjL4zx8oLa8KUefKVthbavA6gN44BrfQmMzTeO5PZ44FpfAf33rSP+mwBcawXQf98x14ZvjBrwrTH+zhh/XVAbvteDH7T9qO2nAGrDROBa3wNj87MjuT0JuNYPQP/94oj/JgPX+hHov1+Za8PPRg34xRj/aox/KqgNv+nB79r+0PZnALVhCnCt34Cx+cuR3J4KXOt3oP/+dsR/04Br/QH0X0l93trwl1ED/jbG9O9Wj/8sqA0b6P9WR1tdbfXq89eG6cC1NqiPi039+m7k9gzgWnWA/mvgiP9mAteqC/RfQ+baUN+oAQ2McUNjXK9+zdpQqj+XaSvX1iiA2jALuFYpMDaNHcnt2cC1yoD+a+KI/+4DrlUO9F8Fc21obNSAJsa4whg3KqgNlfpzU23NtFUFUBvmANeqBMamuSO5fT9wraZA/7VwxH8PANdqBvTfhsy1oblRA1oY4w2NcVVBbdhIf95Y2ybaNg2gNswFrrURMDabOZLb84BrbQz03+aO+O9B4FqbAP23BXNt2MyoAZsb4y2M8aYFtWFL/XkrbVtraxlAbZgPXGtLYGy2cSS3FwDX2grov20d8d9C4FpbA/23HXNt2MaoAdsa4+2MccuC2rC9/ryDth217RRAbXgIuNb2wNjs7EhuPwxcaweg/3ZxxH+PANfaEei/XZlrw85GDdjFGO9qjHcqqA276c+7a9tD254B1IZHgWvtBozNXo7k9mPAtXYH+s9zxH+PA9faA+g/xVwb9jJqgGeMlTHes6A2hPTnsLaItmgAteEJ4FohYGxijuT2k8C1wkD/xR3x31PAtSJA//nMtSFm1IC4MfaNcbSgNiT057217aNt3wBqw9PAtRLA2OznSG4/A1xrb6D/9nfEf88C19oH6L8DmGvDfkYN2N8YH2CM9y2oDQfqzwdpO1jbIQHUhueAax0IjM2hjuT288C1DgL67zBH/PcCcK2Dgf47nLk2HGrUgMOM8eHG+JCC2nCE/nyktqO0HR1AbXgRuNYRwNgc40huvwRc60ig/451xH8vA9c6Cui/45hrwzFGDTjWGB9njI8uqA3H688naDtR20kB1IZXgGsdD4zNyY7k9qvAtU4A+u8UR/z3GnCtE4H+O5W5Npxs1IBTjPGpxvikgtrQSn9ura2NtrYB1IbXgWu1AsamnSO5/QZwrdZA/7V3xH9vAtdqA/Tfacy1oZ1RA9ob49OMcduC2tBBf+6orZO2zgHUhreAa3UAxqaLI7m9CLhWR6D/ko74723gWp2A/ksx14YuRg1IGuOUMe5cUBvS+nNGW1ZbLoDasBi4VhoYm66O5PYS4FoZoP+6OeK/d4BrZYH+685cG7oaNaCbMe5ujHMFtaGH/ny6tp7aegVQG94FrtUDGJvejuT2UuBapwP9d4Yj/nsPuFZPoP/6MNeG3kYNOMMY9zHGvQpqQ1/9uZ+2M7WdFUBteB+4Vl9gbM5mjs3ZRgz6GeMzjfFZBbE5R38+V9t52s63xKYOODY7luD8eQHOn2qDfB7Sn7RuS2Y/XADMqwuZ/HBh3g/1CnxgXhuA/bJBCU/9L4HiVOH/LkjOabaGzik20LutOQHl8TlntWubvrio/j9/Xlw/75Dq7KKJywoA1AE77GLgLuu/Frsst5rL9EN/ix/qMibOatZKr2YtdVF9nvh4RSad6T/0xruIqStF47wEhjOU4sR5KQBnOhMLe5FE3NYJXWJ0PJca491LjN+iVrdmJ3SZ/nuXa7tC25UBdKl7ANe6DLgnr3JEge0JXOtyoP+udsR/ewHXugLov2uYVdJVRj242hhfY4yvLFBJA/Tna7Vdp+36AGqDB1xrADA2NziS2wq41rVA/93oiP9CwLWuA/rvJubacINRA240xjcZ4+sLasPN+vMt2m7VNjCA2hAGrnUzMDa3OZLbEeBatwD9d7sj/osC17oV6L9BzLXhNqMG3G6MBxnjgQW1YbD+fIe2IdruDKA2xIBrDQbG5i5HcjsOXOsOoP/udsR/PnCtIUD/DWWuDXcZNeBuYzzUGN9ZUBvu0Z/v1TZM2/AAakMCuNY9wNiMcCS39waudS/QfyMd8d8+wLWGAf03irk2jDBqwEhjPMoYDy+oDaP15zHaxmobF0Bt2Be41mhgbMY7ktv7AdcaA/TfBEf8tz9wrbFA/01krg3jjRowwRhPNMbjCmrDJP15srYp2qYGUBsOAK41CRibaY7k9oHAtSYD/TfdEf8dBFxrCtB/M5hrwzSjBkw3xjOM8dSC2jBTf56lbba2+wKoDQcD15oJjM0cR3L7EOBas4D+u98R/x0KXGs20H8PMNeGOUYNuN8YP2CM7yuoDXP153naHtQ2P4DacBhwrbnA2CxwJLcPB641D+i/hY747wjgWg8C/fcQc21YYNSAhcb4IWM8v6A2PKw/P6LtUW2PBVAbjgSu9TAwNo87kttHAdd6BOi/Jxzx39HAtR4F+u9J5trwuFEDnjDGTxrjxwpqw1P689PantH2bAC14RjgWk8BY/OcI7l9LHCtp4H+e94R/x0HXOsZoP9eYK4Nzxk14Hlj/IIxfragNryoP7+k7WVtrwRQG44HrvUiMDavOpLbJwDXegnov9cc8d+JwLVeBvrvdeba8KpRA14zxq8b41cKasMb+vOb2t7StiiA2nAScK03gLF525HcPhm41ptA/y12xH+nANd6C+i/Jcy14W2jBiw2xkuM8aKC2vCO/vyutqXa3gugNpwKXOsdYGzedyS3WwHXehfovw8c8V9r4FpLgf77kLk2vG/UgA+M8YfG+L2C2vCR/rxM28faPgmgNrQBrvURMDafOpLbbYFrLQP6b7kj/msHXOtjoP8+Y64Nnxo1YLkx/swYf1JQGz7Xn7/Q9qW2rwKoDe2Ba30OjM0KR3L7NOBaXwD997Uj/usAXOtLoP++Ya4NK4wa8LUx/sYYf1VQG77Vn7/T9r22HwKoDR2Ba30LjM2PjuR2J+Ba3wH995Mj/usMXOt7oP9+Zq4NPxo14Cdj/LMx/qGgNvyiP/+q7TdtvwdQG7oA1/oFGJs/HMntJHCtX4H++9MR/6WAa/0G9N9fzLXhD6MG/GmM/zLGvxfUhr/155IG+r9pq9OAvzakgWv9DYxN3QZu5HYGuFZJA5z/6jnivyxwrQ2A/qvfgLc2UH5X14B6xri+Ma7ToGZtaKA/N9RWqq0sgNqQA67VABibckdyuytwrYZA/zVyxH/dgGuVAv3XmLk2lBs1oJExbmyMywpqQxP9uUJbpbamAdSG7sC1mgBj08yR3O4BXKsC6L8qR/x3OnCtSqD/mjPXhmZGDagyxs2NcdOC2tBCf95Q20baNg6gNvQErtUCGJtNHMntXsC1NgT6b1NH/NcbuNZGQP9txlwbNjFqwKbGeDNjvHFBbdhcf95C25batgqgNpwBXGtzYGy2diS3+wDX2gLov5aO+K8vcK0tgf7bhrk2bG3UgJbGeBtjvFVBbdhWf95O2/badgigNvQDrrUtMDY7OpLbZwLX2g7ov50c8d9ZwLW2B/pvZ+basKNRA3Yyxjsb4x0KasMu+vOu2nbTtnsAteFs4Fq7AGOzhyO5fQ5wrV2B/tvTEf+dC1xrN6D/9mKuDXsYNWBPY7yXMd69oDZ4+rPSFtIWDqA2nAdcywPGJuJIbp8PXEsB/Rd1xH8XANcKAf0XY64NEaMGRI1xzBiHC2pDXH/2tSW07R1AbbgQuFYcGJt9HMnti4Br+UD/7euI/y4GrpUA+m8/5tqwj1ED9jXG+xnjvQtqw/768wGES9tBAdSG/sC19gfG5mBHcvsS4FoHAP13iCP+uxS41oFA/x3KXBsONmrAIcb4UGN8UEFtOEx/PlzbEdqODKA2XAZc6zBgbI5yJLcvB651ONB/RzvivyuAax0B9N8xzLXhKKMGHG2MjzHGRxbUhmP15+O0Ha/thABqw5XAtY4FxuZER3L7KuBaxwH9d5Ij/rsauNbxQP+dzFwbTjRqwEnG+GRjfEJBbThFfz5VWyttrQOoDdcA1zoFGJs2juT2AOBapwL919YR/10LXKsV0H/tmGtDG6MGtDXG7Yxx64La0F5/Pk1bB20dA6gN1wHXag+MTSdHcvt64FqnAf3X2RH/3QBcqwPQf12Ya0MnowZ0NsZdjHHHgtqQ1J9T2tLaMgHUhhuBayWBsck6kts3AddKAf2Xc8R/NwPXSgP915W5NmSNGpAzxl2NcaagNnTTn7tr66Ht9ABqwy3AtboBY9PTkdy+FbhWd6D/ejniv4HAtXoA/debuTb0NGpAL2Pc2xifXlAbztCf+2jrq61fALXhNuBaZwBjc6YjuX07cK0+QP+d5Yj/BgHX6gv039nMteFMowacZYzPNsb9CmrDOfrzudrO03Z+ALVhMHCtc4CxucCR3L4DuNa5QP9d6Ij/hgDXOg/ov4uYa8MFRg240BhfZIzPL6gNF+vP/bVdou3SAGrDncC1LgbG5jJHcvsu4Fr9gf673BH/3Q1c6xKg/65grg2XGTXgcmN8hTG+tKA2XKk/X6Xtam3XBFAbhgLXuhIYmwGO5PY9wLWuAvrvWkf8dy9wrauB/ruOuTYMMGrAtcb4OmN8TUFtuF5/vkHbjdpuCqA2DAOudT0wNjc7ktvDgWvdAPTfLY74bwRwrRuB/ruVuTbcbNSAW4zxrcb4poLaMFB/vk3b7doGBVAbRgLXGgiMzWBHcnsUcK3bgP67wxH/jQaudTvQf0OYa8NgowbcYYyHGONBBbXhTv35Lm13axsaQG0YA1zrTmBs7nEkt8cC17oL6L97HfHfOOBadwP9N4y5Ntxj1IB7jfEwYzy0oDYM159HaBupbVQAtWE8cK3hwNiMdiS3JwDXGgH03xhH/DcRuNZIoP/GMteG0UYNGGOMxxrjUQW1YZz+PF7bBG0TA6gNk4BrjQPGZpIjuT0ZuNZ4oP8mO+K/KcC1JgD9N4W5NkwyasBkYzzFGE8sqA1T9edp2qZrmxFAbZiKXAsYm5mO5PY05FpA/81yxH/TkWsB/TebuTbMNGrALGM82xjPKKgN9+nPc7Tdr+2BAGrDDOBa9wFjM9eR3J4JXGsO0H/zHPHfLOBa9wP99yBzbZhr1IB5xvhBY/xAQW2Yrz8v0LZQ20MB1IbZwLXmA2PzsCO5fR9wrQVA/z3iiP/mANdaCPTfo8y14WGjBjxijB81xg8V1IbH9OfHtT2h7ckAasP9wLUeA8bmKUdy+wHgWo8D/fe0I/6bC1zrCaD/nmGuDU8ZNeBpY/yMMX6yoDY8qz8/p+15bS8EUBvmAdd6FhibFx3J7QeBaz0H9N9LjvhvPnCt54H+e5m5Nrxo1ICXjPHLxviFgtrwiv78qrbXtL0eQG1YAFzrFWBs3nAktxcC13oV6L83HfHfQ8C1XgP67y3m2vCGUQPeNMZvGePXC2rDIv35bW2LtS0JoDY8DFxrETA27ziS248A13ob6L93HfHfo8C1FgP9t5S5Nrxj1IB3jfFSY7ykoDa8pz+/r+0DbR8GUBseA671HjA2HzmS248D13of6L9ljvjvCeBaHwD99zFzbfjIqAHLjPHHxvjDgtrwif78qbbl2j4LoDY8CVzrE2BsPnckt58CrvUp0H9fOOK/p4FrLQf670vm2vC5UQO+MMZfGuPPCmrDV/rzCm1fa/smgNrwDHCtr4Cx+daR3H4WuNYKoP++c8R/zwHX+hrov++Za8O3Rg34zhh/b4y/KagNP+jPP2r7SdvPAdSG54Fr/QCMzS+O5PYLwLV+BPrvV0f89yJwrZ+A/vuNuTb8YtSAX43xb8b454La8Lv+/Ie2P2k+gNrwEnCt34Gx+duR3H4ZuNYfQP+VNHTDf68A1/oT6L8NGvLWhr+NGkCxqh5vYIz/KqgNdfR/q6utnrb6Dflrw6vAteo0xMWmgSO5/RpwrbpA/zV0xH+vA9eqB/RfKXNtaGDUgIbGuNQY129YszaU6c/l2hppaxxAbXgDuFYZMDZNHMntN4FrlQP9V+GI/94CrtUI6L9K5trQxKgBFca40hg3LqgNTfXnZtqqtDUPoDYsAq7VFBibFo7k9tvAtZoB/behI/5bDFyrCui/jZhrQwujBmxojDcyxs0LasPG+vMm2jbVtlkAtWEJcK2NgbHZ3JHcfge41iZA/23hiP/eBa61KdB/WzLXhs2NGrCFMd7SGG9WUBu20p+31tZS2zYB1IalwLW2AsZmW0dy+z3gWlsD/bedI/7bCbhWS6D/tmeuDdsaNWA7Y7y9Md6moDbsoD/vqG0nbTsHUBt2Bq61AzA2uziS27sA19oR6L9dHfHfrsC1dgL6bzfm2rCLUQN2Nca7GeOdC2rD7vrzHtr21LZXALVhN+BauwNj4zHHxjNisIcx3tMY71UQG6U/h7SFtUXysamX/7t1S2q/DoTwSCX/8z0gTP9GOhMLe5FEvMTwEQ67zo0SfK1CY9zDAYx7OoBxLwcweg5gVA5gDDmAMewAxogDGKMOYIw5gDHuAEbfAYwJBzDu7QDGfRzAuK8DGPdzAOP+DmA8wAGMBzqA8SAHMB7sAMZDHMB4qAMYD3MA4+EOYDzCAYxHOoDxKAcwHu0AxmMcwHisAxiPcwDj8Q5gPMEBjCc6gPEkBzCe7ADGUxzAeKoDGFs5gLG1AxjbOICxrQMY2zmAsb0DGE9zAGMHBzB2dABjJwcwdnYAYxcHMCYdwJhyAGPaAYwZBzBmHcCYcwBjVwcwdnMAY3cHMPZwAOPpDmDs6QDGXg5g7O0AxjMcwNjHAYx9HcDYzwGMZzqA8SwHMJ7tAMZzHMB4rgMYz3MA4/kOYLzAAYwXOoDxIgcwXuwAxv4OYLzEAYyXOoDxMgcwXu4AxiscwHilAxivcgDj1Q5gvMYBjAMcwHitAxivcwDj9Q5gvMEBjDc6gPEmBzDe7ADGWxzAeKsDGAc6gPE2BzDe7gDGQQ5gHOwAxjscwDjEAYx3OoDxLgcw3u0AxqEOYLzHAYz3OoBxmAMYhzuAcYQDGEc6gHGUAxhHO4BxjAMYxzqAcZwDGMc7gHGCAxgnOoBxkgMYJzuAcYoDGKc6gHGaAxinO4BxhgMYZzqAcZYDGGc7gPE+BzDOcQDj/Q5gfMABjHMdwDjPAYwPOoBxvgMYFziAcaEDGB9yAOPDDmB8xAGMjzqA8TEHMD7uAMYnHMD4pAMYn3IA49MOYHzGAYzPOoDxOQcwPu8AxhccwPiiAxhfcgDjyw5gfMUBjK86gPE1BzC+7gDGNxzA+KYDGN9yAOMiBzC+7QDGxQ5gXOIAxnccwPiuAxiXOoDxPQcw7uQAxp0dwLiLAxh3dQDjbgwYOXAqpt+Z/d+rDhjwhfVXrlXsL1WO4sgrCkzdfIBo3ZYl//wy5Dolq/7Sao5AblDyfzvh4F+CU98NnHVLmDdwIeBiN10MuOk4ccYDStRicfrrjjNUOEHYCn8zfMz4DfDUZVWP48a8X/Cb4RP6897a9tG2r/Gb4asM/v/mE6+4SyWAsTPx7teQEfB/FwcmRwlj4u2Pc3LMlnj7GwmWaLhmiXcAYdJ2kLaDjcSrWxJM4h3gWjtltkDFJsQhTO3UIfl26t8CVyz2Q9cde6RwYnVVlK7q8fvG+NCCZD5Mfz5c2xHajmy4ahtZF5wLwKqpDgPm1VHgal4Ym6OM2BxujI8wxkcWxOZo/fkYbcdqO84oNGT1S1a9JJ9wFrjQfVyH2RfAtdjuB7xfUhJIN+kVd6mjHZFnh7h20B4CLIjHMx20xxv3LZqXrDxgOAPpRiEL8a2tVkoM+rNlfnyC9suJ2k7SdrK2U7Sdqq2Vttba2mhrq62dtvbaTtPWQVtHbZ20ddbWRVtSW0pbWltGW1ZbTltXbd20ddfWQ9vp2npq66Wtd8M8mOrEIDClBXMnWuZOssydbJk7xTJ3qmWulWWutWWujWWurWWunWWuvWXuNMtcB8tcR8tcJ8tcZ8tcF8tc0jKXssylLXMZy1zWMpezzHW1zHWzzHW3zPWwzJ1umetpmetlmeudnzOvbfJ/Hpj/0yvuqlF0ii3GJwDWyubo8tSJoLWI40mQtf7x18nFrxXK+0udUuxakf/6Xp1a3FqeEUfVqpi1QjVyQrVe97W8gvxSbdZxrVhulVxVbddtLd+S96rduqzlW/eQar/2a8Vr2Y/qtLVdK17r3lYd1m6t0L/UCdVxbdaK/2vNUZ3WfK30auqX6ryma8VXWwtVlzVby1uDuqqSa7KWt0Y1WqVWv1Z0Deu9Sq9urcganx0q869rRXJrcQ6p7L+tFV+rM03lal/LX8vzUXWtZa1Ebq3PWtXNvpa3Due26m5by1unHkD1WHUttY79hDq9cK3MOvcmqmfNtcJF9Dmql7FWKFdUz6R6A0VfkM+VesN6vYwy8Z7RkBEwLV54N6NY8GfgAqj6AJtxLh8SRtQjh2of9gFvgmYlq95q5d4EXlFXhvWuiumLvvkN1q/wzkbffGDNuX4WBYp+1oKrJJ7qC9xA/cDBRScfbZq+wM1YzbuvoydSL1geJTIm3jMbMgI+E34iJTJnAk+ks4SfSOTDs+AnUiJzlqMnUi8Y7kTaApflRDo7v8HOKTyRzracSOcEcCL1Ap5IZwM30DlMwUUVoGqcSM7nAotZSQn+tOyTL0Doh6RIKXAesJjZfOgVdymK8XkMncx5jnYyPWH1JxU28Z7fkBHw+fBOJhU+H7j5LxDeyZAPL4B3MqnwBcybH1FAzxNeQC8E+7D6Qh+8yBy/CLj3guyAe8Jwp0IWuCwd8MX5wty/sAO+2NIB9w+gA8adQJ66GJiU/ZmCi96ISM6XMHfAXnGXouJ4EUP3dqnwrpXicqkDvLly/FJgjl8mPMdra1IQzQ9qrcvBB3ZQaud02Fnj50y8VzRkBHwFXO34uSuAAbxSuNohH14JVzt+7krhaocK3eUNZRfjq8DFuPpCc0bm+NWOqp3TYbj9rAUui9q5Jl+YBxSqnWssamdAAGoHdwJ56hpgUg5gCi56IyI5Xyu8E6TieDVD13+dcLVDcbnOAd5cOX4dMMevF57jtTUpXnGXQjYpNzj6bKcH7KwJ1fg+jhsbMgK+Ea52Qt6NwE1wk3C1Qz68Ca52Qt5NwtUOFbobGsouxjc7onaQOX6Lo2qnBwy3ylngsqidW/OFeWCh2rnVonYGBqB2cCeQp24FJuVApuCiNyKS823CO0EqjrcwdP23C1c7FJfbHeDNleO3A3N8kPAcr61J8Yq7FLJJGeyo2ukOO2syNdTOHQ0ZAd8BVzsZ7w7gJhgiXO2QD4fA1U7GGyJc7VChG9xQdjG+0xG1g8zxuxxVO91huNOBqZ2784V5aKHauduidoYGoHZwJ5Cn7gYm5VCm4KI3IpLzPcI7QSqOdzF0/fcKVzsUl3sd4M2V4/cCc3yY8ByvrUnxirsUskkZ7qja6QY7a2I1vhNjRENGwCPgaiemRgA3wUjhaod8OBKudmI1eHtFXjbeiEI3vKHsYjzKEbWDzPHRjqqdbjDcscC+S2VMvjCPLVQ7YyxqZ2wAagd3AnlqDDApxzIFF70RkZzHCe8EqTiOZuj6xwtXOxSX8Q7w5srx8cAcnyA8x2trUrziLoVsUiY6qna64p7t+CbeSQ0ZAU/CP9vxJwE3wWThaod8OBn/bMefLFztUKGb2FB2MZ7iiNpB5vhUR9VOVxjuTNwCl0XtTMsX5umFameaRe1MD0Dt4E4gT00DJuV0puCiNyKS8wzhnSAVx6kMXf9M4WqH4jLTAd5cOT4TmOOzhOd4bU2KV9ylkE3KbEfVTg521kQSJt77GjICvg+udiKJ+4CbYI5wtUM+nANXO5HEHOFqhwrd7Iayi/H9jqgdZI4/4KjaycFwR3wLXBa1MzdfmOcVqp25FrUzLwC1gzuBPDUXmJTzmIKL3ohIzg8K7wSpOD7A0PXPF652KC7zHeDNlePzgTm+QHiO19akeMVdCtmkLHRU7WRhZ02qxptsDzVkBPwQXO2k1EPATfCwcLVDPnwYrnZSNXh7RV423ohCt7Ch7GL8iCNqB5njjzqqdrIw3KnA3mR7LF+YHy9UO49Z1M7jAagd3AnkqceASfk4U3DRGxHJ+QnhnSAVx0cZuv4nhasdisuTDvDmyvEngTn+lPAcr61J8Yq7FLJJedpRtZPBqZ20ifeZhoyAn8GrnfQzwE3wrHC1Qz58Fq920s8KVztU6J5uKLsYP+eI2kHm+POOqp0MriFOWeCyqJ0X8oX5xUK184JF7bwYgNrBnUCeegGYlC8yBRe9EZGcXxLeCVJxfJ6h639ZuNqhuLzsAG+uHH8ZmOOvCM/x2poUr7hLIZuUVx1VO2ncm2wpE+9rDRkBv4Z/ky31GnATvC5c7ZAPX8e/yZZ6XbjaoUL3akPZxfgNR9QOMsffdFTtpHEvOyUtcFnUzlv5wryoUO28ZVE7iwJQO7gTyFNvAZNyEVNw0RsRyflt4Z0gFcc3Gbr+xcLVDsVlsQO8uXJ8MTDHlwjP8dqaFK+4SyGblHccVTsp2Fnj1/gG6ncbMgJ+F652fO9d4CZYKlztkA+XwtWO7y0Vrnao0L3TUHYxfs8RtYPM8fcdVTspGO54YN9A/UG+MH9YqHY+sKidDwNQO7gTyFMfAJPyQ6bgojcikvNHwjtBKo7vM3T9y4SrHYrLMgd4c+X4MmCOfyw8x2trUrziLoVsUj5xVO0kmdTOpw0ZAX/KoHY+BW6C5cLVDvlwOYPaWS5c7VCh+6Sh7GL8mSNqB5njnzuqdpIOqp0v8oX5y0K184VF7XwZgNrBnUCe+gKYlF86onaQnL8S3glScfycoetfIVztUFxWOMCbK8dXAHP8a+E5XluT4hV3KWST8o2jaqcL7KxJ1vhOtm8bMgL+Fq52kolvgZvgO+Fqh3z4HVztJBPfCVc7VOi+aSi7GH/viNpB5vgPjqqdLjDcycC+k+3HfGH+qVDt/GhROz8FoHZwJ5CnfgQm5U9MwUVvRCTnn4V3glQcf2Do+n8RrnYoLr84wJsrx38B5vivwnO8tibFK+5SyCblN0fVTmec2omYeH9vyAj4d7zaifwO3AR/CFc75MM/8Gon8odwtUOF7reGsovxn46oHWSO/+Wo2umMa4jDFrgsaufv6sJcWlJT2fxtUTv0l7jVDu4E8tTfyMJbyhNc9EZEct6gFFt80BuOiuNfDF1/nVLeg8sr7lIUF8IonTdXjps4i12rrvAcr61J8Yq7FLJJqQfMmyDVTifYWZOp8WynfikjYFocq3YyifrATdAAuDm5fNigFK12MokGzIcGotDVK5VdjBuCi3H1heaMzPFSIOcg1U4nmNrJBPZspyxfmMsL1U5Z6apqpzwAtdMJqHbKgElZXsoTXPRGRHJuJLwTpOJYytD1NxaudigujR3gzZXjjYE53kR4jtfWpHjFXQrZpFQ4qnY6ws6adNbEW1nKCLgSrnbS2UrgJmgqXO2QD5vC1U4621S42qFCV1Equxg3c0TtIHO8ylG10xGmdtIZC1wWtdM8X5hbFKqd5ha10yIAtdMRqHaaA5OyRSlPcNEbEcl5Q+GdIBXHKoaufyPhaofispEDvLlyfCNgjm8sPMdra1K84i6FbFI2cVTtdICdNarGs51NSxkBbwpXOyqxKXATbCZc7ZAPN4OrHZXYTLjaoUK3SansYry5I2oHmeNbOKp2OsDUjgrs2c6W+cK8VaHa2dKidrYKQO10AKqdLYFJuVUpT3DRGxHJeWvhnSAVxy0Yuv6WwtUOxaWlA7y5crwlMMe3EZ7jtTUpXnGXQjYp2zqqdk6DnTWpGmpnu1JGwNvB1U4qsR1wE2wvXO2QD7eHq51UYnvhaocK3balsovxDo6oHWSO7+io2jkNpnZSgamdnfKFeedCtbOTRe3sHIDaOQ2odnYCJuXOpTzBRW9EJOddhHeCVBx3ZOj6dxWudiguuzrAmyvHdwXm+G7Cc7y2JsUr7lLIJmV3R9VOe9w3UPsm3j1KGQHvAVc7vr8HcBPsKVztkA/3hKsd399TuNqhQrd7qexivJcjageZ456jaqc9TO34cQtcFrWj8oU5VKh2lEXthAJQO+2BakcBkzJUyhNc9EZEcg4L7wSpOHoMXX9EuNqhuEQc4M2V4xFgjkeF53htTYpX3KWQTUrMUbXTDnbWRGqonXgpI+A4XO3oeeAm8IWrHfKhD1c7Ed8Xrnao0MVKZRfjhCNqB5njezuqdtrB1E4kMLWzT74w71uodvaxqJ19A1A77YBqZx9gUu5byhNc9EZEct5PeCdIxXFvhq5/f+Fqh+KyvwO8uXJ8f2COHyA8x2trUrziLoVsUg50VO20hZ01CWXiPaiUEfBBcLWTUAcBN8HBwtUO+fBguNpJ1ODtFXnZeEMKXansYnyII2oHmeOHOqp22sLUTsKzwGVRO4flC/PhhWrnMIvaOTwAtdMWqHYOAybl4aU8wUVvRCTnI4R3glQcD2Xo+o8UrnYoLkc6wJsrx48E5vhRwnO8tibFK+5SyCblaEfVThvYWRP3TLzHlDICPgauduLeMcBNcKxwtUM+PBauduLescLVDhW6o0tlF+PjHFE7yBw/3lG10wamdmI5C1wWtXNCvjCfWKh2TrConRMDUDttgGrnBGBSnljKE1z0RkRyPkl4J0jF8XiGrv9k4WqH4nKyA7y5cvxkYI6fIjzHa2tSvOIuhWxSTnVU7bTGfUtBjW+gblXKCLgVXO2ksq2Am6C1cLVDPmwNVzupbGvhaocK3amlsotxG0fUDjLH2zqqdlrjvqUgsG+gbpcvzO0L1U47i9ppH4DaaQ1UO+2ASdm+lCe46I2I5Hya8E6QimNbhq6/g3C1Q3Hp4ABvrhzvAMzxjsJzvLYmxSvuUsgmpZOjaqcV7KwJ1Xi207mUEXBnuNoJeZ2Bm6CLcLVDPuwCVzshr4twtUOFrlOp7GKcdETtIHM85ajaaYX7BurAnu2k84U5U6h20ha1kwlA7bQCqp00MCkzpTzBRW9EJOes8E6QimOKoevPCVc7FJecA7y5cjwHzPGuwnO8tibFK+5SyCalm6Nq51TcWZM28XYvZQTcHa52vHR34CboIVztkA97wNWOl+4hXO1QoetWKrsYn+6I2kHmeE9H1c6pMLXjpSxwWdROr3xh7l2odnpZ1E7vANQO8ARSvYBJ2buUJ7jojYjkfIbwTpCKY0+Grr+PcLVDcenjAG+uHO8DzPG+wnO8tibFK+5SyCaln6Nq5xTYWROr8SbbmaWMgM+Eq51Y9kzgJjhLuNohH54FVzux7FnC1Q4Vun6lsovx2Y6oHWSOn+Oo2jkF93M7gb3Jdm6+MJ9XqHbOtaid8wJQO6cA1c65wKQ8r5QnuOiNiOR8vvBOkIrjOQxd/wXC1Q7F5QIHeHPl+AXAHL9QeI7X1qR4xV0K2aRc5KjaORl21qga38l2cSkj4Ivhakepi4GboL9wtUM+7A9XO6oGb6/Iy8YbUeguKpVdjC9xRO0gc/xSR9XOybg32QL7TrbL8oX58kK1c5lF7VwegNo5Gah2LgMm5eWlPMFFb0Qk5yuEd4JUHC9l6PqvFK52KC5XOsCbK8evBOb4VcJzvLYmxSvuUsgm5WpH1c5JuJcxavzczjWljICvKcWvO0C4QiHeA4zOA7Qui6qggnJ1qeyid60jqgKZl9cxF3pETK5jyPEgC+qJTAX1+lJGwNczFNQbhBdU4n1DQAXVK+5StDFuKOXZcCjeQW6yExrifGDivbGUEfCNDCfijcCKfpPwDUs+vIlhE9wk/B4tbdKbGOTPtcB43yz8dgHlzs1Mxb76Qu/tm4HxuUW4xK9NMXjFXQqpGG4VnuMU41sZGjlkHlKT0Lxk5S1z80LjBq7F9yzCC7E+59jA8G3L/Higjudt2m7XNkjbYG13aBui7U5td2m7W9tQbfdou1fbMG3DtY3QNlLbKG2jtY3RNlbbOG3jtU3QNlHbJG2TtU3RNlXbNG3Ttc0ofMYyMP88xZy7zTJ3u2VukGVusGXuDsvcEMvcnZa5uyxzd1vmhlrm7rHM3WuZG2aZG26ZG2GZG2mZG2WZG22ZG2OZG2uZG2eZG2+Zm2CZm2iZm2SZm2yZm2KZm2qZm2aZm26Zm1G66rO7bfJ/Hpj/0yvuqlF0ii2WAwGFt/o54G2gtYjj7ZC1/vHXoOLXCuX9pQYXu1bkv75XdxS3lmfEUQ0pZq1QjZxQd677Wl5Bfqm71nGtWG6VXFV3r9taviXv1dB1Wcu37iF1z9qvFa9lP6p713ateK17Ww1bu7VC/1In1PC1WSv+rzVHjVjztdKrqV9q5JquFV9tLVSj1mwtbw3qqhq9Jmt5a1Sj1ZjVrxVdw3qvxq5urcganx1q3L+uFcmtxTmkxv/bWvG1OtPUhNrX8tfyfFQTa1krkVvrs1ZNsq/lrcO5rSbb1vLWqQdQU1ZdS61jP6GmFq6VWefeRE2ruVa4iD5HTTfWCuWK6pnUjFI372jPgPV6mRpvHc8sZQRMi6PuelWDn4kLoJoFcCrnHW3yIWHEvnWcqcHbK/IK8u1R3ObNBPb26Oz8BruvUG3OLl317dH7SvnfHsVVEk/NBm6g+8DBRScfbZrZwM1YzXu2oyfSdFgeJTIm3jmljIDnwE+kRGYO8ES6X/iJRD68H34iJTL3O3oiTYfhTqQtcFlOpAfyG2xu4Yn0gOVEmhvAiTQdeCI9ANxAc5mCi34QjOQ8D1jMSkrwp+WsfAFCPwhGSoEHgcXM5kOvuEtRjB9k6GQedLSTmQarP6mwiXd+KSPg+fBOJhWeD9z8C4R3MuTDBfBOJhVewLz5EQX0QeEFdCHYh9UX+uBF5vhDwL0XZAc8DYY7FbLAZemAH84X5kcKO+CHLR3wIwF0wLgTyFMPA5PyEabgojcikvOjzB2wV9ylqDg+xNC9PSa8a6W4POYAb64cfwyY448Lz/HamhRE84Na6wnwgR2U2pkKO2v8nIn3yVJGwE/C1Y6fexIYwKeEqx3y4VNwtePnnhKudqjQPVEquxg/DS7G1ReaMzLHn3FU7UyF4fazFrgsaufZfGF+rlDtPGtRO88FoHZwJ5CnngUm5XNMwUVvRCTn54V3glQcn2Ho+l8QrnYoLi84wJsrx18A5viLwnO8tibFK+5SyCblJUef7UyBnTU1f+/4y6WMgF+Gq52Q9zJwE7wiXO2QD1+Bq52Q94pwtUOF7qVS2cX4VUfUDjLHX3NU7UyB4Q7u946/ni/MbxSqndctaueNANQO7gTy1OvApHyDKbjojYjk/KbwTpCK42sMXf9bwtUOxeUtB3hz5fhbwBxfJDzHa2tSvOIuhWxS3nZU7UyGnTWZGmpncSkj4MVwtZPxFgM3wRLhaod8uASudjLeEuFqhwrd26Wyi/E7jqgdZI6/66jamQzDnQ5M7SzNF+b3CtXOUovaeS8AtYM7gTy1FJiU7zEFF70RkZzfF94JUnF8l6Hr/0C42qG4fOAAb64c/wCY4x8Kz/HamhSvuEshm5SPHFU7k2BnTazGd2IsK2UEvAyudmJqGXATfCxc7ZAPP4arnVgN3l6Rl403otB9VCq7GH/iiNpB5vinjqqdSTDcscC+S2V5vjB/Vqh2llvUzmcBqB3cCeSp5cCk/IwpuOiNiOT8ufBOkIrjpwxd/xfC1Q7F5QsHeHPl+BfAHP9SeI7X1qR4xV0K2aR85ajamYh7tuObeFeUMgJegX+2468AboKvhasd8uHX+Gc7/tfC1Q4Vuq9KZRfjbxxRO8gc/9ZRtTMRhjsTt8BlUTvf5Qvz94Vq5zuL2vk+ALWDO4E89R0wKb9nCi56IyI5/yC8E6Ti+C1D1/+jcLVDcfnRAd5cOf4jMMd/Ep7jtTUpXnGXQjYpPzuqdibAzppIwsT7Sykj4F/gaieS+AW4CX4VrnbIh7/C1U4k8atwtUOF7udS2cX4N0fUDjLHf3dU7UyA4Y74FrgsauePfGH+s1Dt/GFRO38GoHZwJ5Cn/gAm5Z9MwUVvRCTnv4R3glQcf2fo+v8WrnYoLn87wJsrx/9GNlRlsnO8tibFK+5SyCZlA5wPA1U742FnTarGm2x1yhgB0+JYtZNSdYCboG6ZbLVDPiSM4G+grsHbK/Ky8UYUug3KZBfjeuBi/N8NCeaMzPH6QM5Bqp3xsGYhFdibbA3yhblhWUlNZdOgbFW1Q3+JW+2MB6qdBsCkbFjGE1z0RkRyLhXeCVJxrF+GPxjKmA8ur7hLUVzKHODNleNlwBwvF57jtTUpXnGXQjYpjRxVO+Nwaidt4m1cxgi4MV7tpBsDN0ET4WqHfNgEr3bSTYSrHSp0jcpkF+MKR9QOMscrHVU743BqJ2WBy6J2muYLc7NCtdPUonaaBaB2xgHVTlNgUjYr4wkueiMiOVcJ7wSpOFYydP3NhasdiktzB3hz5XhzYI63EJ7jtTUpXnGXQjYpGzqqdsbi3mRLmXg3KmMEvBFc7URSGwE3wcbC1Q75cGO42omkNhaudqjQbVgmuxhv4ojaQeb4po6qnbG4l52SFrgsamezfGHevFDtbGZRO5sHoHbGAtXOZsCk3LyMJ7jojYjkvIXwTpCK46YMXf+WwtUOxWVLB3hz5fiWwBzfSniO19akeMVdCtmkbO2o2hkDO2v8Gt9A3bKMEXBLuNrxvZbATbCNcLVDPtwGrnZ8bxvhaocK3dZlsovxto6oHWSOb+eo2hkDUzvxwL6Bevt8Yd6hUO1sb1E7OwSgdsYA1c72wKTcoYwnuOiNiOS8o/BOkIrjdgxd/07C1Q7FZScHeHPl+E7AHN9ZeI7X1qR4xV0K2aTs4qjaGc2kdnYtYwS8K4Pa2RW4CXYTrnbIh7sxqJ3dhKsdKnS7lMkuxrs7onaQOb6Ho2pntINqZ898Yd6rUO3saVE7ewWgdkYD1c6ewKTcyxG1g+TsCe8EqTjuwdD1K+Fqh+KiHODNleMKmOMh4TleW5PiFXcpZJMSdlTtjIKdNcka38kWKWMEHIGrnWQiAtwEUeFqh3wYhaudZCIqXO1QoQuXyS7GMUfUDjLH446qnVEwtZMM7DvZ/HxhThSqHd+idhIBqJ1RQLXjA5MyUcYTXPRGRHLeW3gnSMUxztD17yNc7VBc9nGAN1eO7wPM8X2F53htTYpX3KWQTcp+jqqdkTi1EzHx7l/GCHh/vNqJ7A/cBAcIVzvkwwPwaidygHC1Q4VuvzLZxfhAR9QOMscPclTtjMSpnbAFLovaOThfmA8pVDsHW9TOIQGonZFAtXMwMCkPKeMJLnojIjkfKrwTpOJ4EEPXf5hwtUNxOcwB3lw5fhgwxw8XnuO1NSlecZdCNilHOKp2RuB+u2iNZztHljECPhKudjKJI4Gb4Cjhaod8eBRc7WQSRwlXO1TojiiTXYyPdkTtIHP8GEfVzgjcL6AM7NnOsfnCfFyh2jnWonaOC0DtjACqnWOBSXlcGU9w0RsRyfl44Z0gFcdjGLr+E4SrHYrLCQ7w5srxE4A5fqLwHK+tSfGKuxSySTnJUbUzHHbWpLMm3pPLGAGfDFc76ezJwE1winC1Qz48Ba520tlThKsdKnQnlckuxqc6onaQOd7KUbUzHKZ20hkLXBa10zpfmNsUqp3WFrXTJgC1MxyodloDk7JNGU9w0RsRybmt8E6QimMrhq6/nXC1Q3Fp5wBvrhxvB8zx9sJzvLYmxSvuUsgm5TRH1c4w2Fmjajzb6VDGCLgDXO2oRAfgJugoXO2QDzvC1Y5KdBSudqjQnVYmuxh3ckTtIHO8s6NqZxhM7ajAnu10yRfmZKHa6WJRO8kA1M4woNrpAkzKZBlPcNEbEck5JbwTpOLYmaHrTwtXOxSXtAO8uXI8DczxjPAcr61J8Yq7FLJJyTqqdu7F/XbRGmonV8YIOAdXO6lEDrgJugpXO+TDrnC1k0p0Fa52qNBly2QX426OqB1kjnd3VO3ci/vtooGpnR75wnx6odrpYVE7pwegdu4Fqp0ewKQ8vYwnuOiNiOTcU3gnSMWxO0PX30u42qG49HKAN1eO9wLmeG/hOV5bk+IVdylkk3KGo2rnHtw3UPsm3j5ljID7wNWO7/cBboK+wtUO+bAvXO34fl/haocK3RllsotxP0fUDjLHz3RU7dwDUzt+3AKXRe2clS/MZxeqnbMsaufsANTOPUC1cxYwKc8u4wkueiMiOZ8jvBOk4ngmQ9d/rnC1Q3E51wHeXDl+LjDHzxOe47U1KV5xl0I2Kec7qnaGws6aSA21c0EZI+AL4Gon4l8A3AQXClc75MML4Won4l8oXO1QoTu/THYxvsgRtYPM8YsdVTtDYWonEpja6Z8vzJcUqp3+FrVzSQBqZyhQ7fQHJuUlZTzBRW9EJOdLhXeCVBwvZuj6LxOudigulznAmyvHLwPm+OXCc7y2JsUr7lLIJuUKR9XO3bCzJqFMvFeWMQK+Eq52EupK4Ca4SrjaIR9eBVc7iRq8vSIvG29EobuiTHYxvtoRtYPM8WscVTt3w9ROwrPAZVE7A/KF+dpCtTPAonauDUDt3A1UOwOASXltGU9w0RsRyfk64Z0gFcdrGLr+64WrHYrL9Q7w5srx64E5foPwHK+tSfGKuxSySbnRUbVzF+ysiXsm3pvKGAHfBFc7ce8m4Ca4WbjaIR/eDFc7ce9m4WqHCt2NZbKL8S2OqB1kjt/qqNq5C6Z2YjkLXBa1MzBfmG8rVDsDLWrntgDUzl1AtTMQmJS3lfEEF70RkZxvF94JUnG8laHrHyRc7VBcBjnAmyvHBwFzfLDwHK+tSfGKuxSySbnDUbVzJ+5bCmp8A/WQMkbAQ+BqJ5UdAtwEdwpXO+TDO+FqJ5W9U7jaoUJ3R5nsYnyXI2oHmeN3O6p27sR9S0Fg30A9NF+Y7ylUO0MtaueeANTOnUC1MxSYlPeU8QQXvRGRnO8V3glScbyboesfJlztUFyGOcCbK8eHAXN8uPAcr61J8Yq7FLJJGeGo2hkCO2tCNZ7tjCxjBDwSrnZC3kjgJhglXO2QD0fB1U7IGyVc7VChG1EmuxiPdkTtIHN8jKNqZwjuG6gDe7YzNl+YxxWqnbEWtTMuALUzBKh2xgKTclwZT3DRGxHJebzwTpCK4xiGrn+CcLVDcZngAG+uHJ8AzPGJwnO8tibFK+5SyCZlkqNq5w7cWZM28U4uYwQ8Ga52vPRk4CaYIlztkA+nwNWOl54iXO1QoZtUJrsYT3VE7SBzfJqjaucOmNrxUha4LGpner4wzyhUO9MtamdGAGoHeAKp6cCknFHGE1z0RkRynim8E6TiOI2h658lXO1QXGY5wJsrx2cBc3y28ByvrUnxirsUskm5z1G1Mxh21sRqvMk2p4wR8By42oll5wA3wf3C1Q758H642oll7xeudqjQ3Vcmuxg/4IjaQeb4XEfVzmDcz+0E9ibbvHxhfrBQ7cyzqJ0HA1A7g4FqZx4wKR8s4wkueiMiOc8X3glScZzL0PUvEK52KC4LHODNleMLgDm+UHiO19akeMVdCtmkPOSo2hkEO2tUje9ke7iMEfDDcLWj1MPATfCIcLVDPnwErnZUDd5ekZeNN6LQPVQmuxg/6ojaQeb4Y46qnUG4N9kC+062x/OF+YlCtfO4Re08EYDaGQRUO48Dk/KJMp7gojcikvOTwjtBKo6PMXT9TwlXOxSXpxzgzZXjTwFz/GnhOV5bk+IVdylkk/KMo2rndtzLGDV+bufZMkbAz5bh131OuEIh3s+VrXQwaF0WVUEF5Zky2UXveUdUBTIvX2Au9IiYvMCQ40EW1NuYCuqLZYyAX2QoqC8JL6jE+6WACqpX3KVoY7xUxrPhULyD3GQDS3E+MPG+XMYI+GWGE/FlYEV/RfiGJR++wrAJXhF+j5Y26SsM8ud5YLxfFX67gHLnVaZiX32h9/arwPi8Jlzi16YYvOIuhVQMrwvPcYrx6wyNHDIPqUloXrLylrl5oXG/X8Kzz0ugOEOszzk2MHzbMj9+Q8fzTW1vaVuk7W1ti7Ut0faOtne1LdX2nrb3tX2g7UNtH2lbpu1jbZ9o+1Tbcm2faftc2xfavtT2lbYV2r7W9o22b7V9p+17bT8UPmN5I/88xZx70zL3lmVukWXubcvcYsvcEsvcO5a5dy1zSy1z71nm3rfMfWCZ+9Ay95Flbpll7mPL3CeWuU8tc8stc59Z5j63zH1hmfvSMveVZW6FZe5ry9w3lrlvLXPfWea+t8z9ULbqs7tt8n8emP/TK+6qUXSKLZZvAApv9XPAN0FrEce3IGv9469Fxa8VyvtLvV3sWpH/+l4tLm4tz4ijWlLMWqEaOaHeWfe1vIL8Uu+u41qx3Cq5qpau21q+Je/Ve+uylm/dQ+r9tV8rXst+VB+s7VrxWve2+nDt1gr9S51QH63NWvF/rTlq2ZqvlV5N/VIfr+la8dXWQvXJmq3lrUFdVZ+uyVreGtVotXz1a0XXsN6rz1a3VmSNzw71+b+uFcmtxTmkvvi3teJrdaapL2tfy1/L81F9Vctaidxan7VqhX0tbx3ObfW1bS1vnXoA9c2qa6l17CfUt4VrZda5N1Hf1VwrXESfo7431grliuqZ1A+O3tH+AdbrZWq8dfxjGSPgH8vQbx1n1I+4AKqfAE7lvKNNPvwJeEe72oc/gTdBUG+P4jZvJrC3R3/Ob7BfCu9s/Fy26tujv5Txvz2KqySe+hm4gX4BBxedfLRpfgZuxmrePzt6In0Py6NExsT7axkj4F/hJ1Ii8yvwRPpN+IlEPvwNfiIlMr85eiJ9D8OdSFvgspxIv+c32B+FJ9LvlhPpjwBOpO+BJ9LvwA30B1Nw0Q+CkZz/BBazkhL8aflTvgChHwQjpcBfwGJm86FX3KUoxn8xdDJ/OdrJfAerP6mwiffvMkbAf8M7mVT4b+TmL5fdyZAPCSO2k0mFTd5ekZeNN6KA/iW8gG4A9mH1hT54kTleB8c50J/o/Q5WM1IhC1yWDrhu+T9/1isvqdnt1i1ftQOmv8TdAX8H7IDrApOyXjlPcNEbEcm5PnAjlpTgNxwVxzrl+IOhAfPB5RV3KYpLAwd4c+V4A2CONxSe47U1KYjmB7VWKfjADkrtfAs7a/ycibesnBEwLY5VO36uDBjAcuFqh3xYDlc7fq5cuNqhQldaLrsYNwIX4+oLzRmZ440dVTvfwtSOn7XAZVE7TfKFuaJQ7TSxqJ2KANTOt0C10wSYlBXlPMFFb0Qk50rhnSAVx8YMXX9T4WqH4tLUAd5cOd4UmOPNhOd4bU2KV9ylkE1KFTBvglQ738DOmpq/d7x5OSPg5nC1E/KaAzdBC+Fqh3zYAq52Ql4L4WqHCl1VuexivKEjageZ4xs5qna+gamd4H7v+Mb5wrxJodrZ2KJ2NglA7XwDVDsbA5Nyk3Ke4KI3IpLzpsI7QSqOGzF0/ZsJVzsUl80c4M2V45sBc3xz4TleW5PiFXcpZJOyhaNq52vcT4nVUDtbljMC3hKudjLelsBNsJVwtUM+3AqudjLeVsLVDhW6LcplF+OtHVE7yBxv6aja+RqmdtKBqZ1t8oV520K1s41F7WwbgNr5Gqh2tgEm5bblPMFFb0Qk5+2Ed4JUHFsydP3bC1c7FJftHeDNlePbA3N8B+E5XluT4hV3KWSTsqOjamcF7KyJ1fhOjJ3KGQHvBFc7MbUTcBPsLFztkA93hqudWA3eXpGXjTei0O1YLrsY7+KI2kHm+K6Oqp0VMLUTC+y7VHbLF+bdC9XObha1s3sAamcFUO3sBkzK3ct5goveiEjOewjvBKk47srQ9e8pXO1QXPZ0gDdXju8JzPG9hOd4bU2KV9ylkE2K56ja+Qr3bMc38apyRsAK/2zHV8BNEBKudsiHIfyzHT8kXO1QofPKZRfjsCNqB5njEUfVzle4LxeMW+CyqJ1ovjDHCtVO1KJ2YgGona+AaicKTMpYOU9w0RsRyTkuvBOk4hhh6Pp94WqH4uI7wJsrx31gjieE53htTYpX3KWQTcrejqqdL2FnTSRh4t2nnBHwPnC1E0nsA9wE+wpXO+TDfeFqJ5LYV7jaoUK3d7nsYryfI2oHmeP7O6p2voSpnYhvgcuidg7IF+YDC9XOARa1c2AAaudLoNo5AJiUB5bzBBe9EZGcDxLeCVJx3J+h6z9YuNqhuBzsAG+uHD8YmOOHCM/x2poUr7hLIZuUQx1VO1/gvoG6xptsh5UzAj4MrnZS6jDgJjhcuNohHx4OVzupGry9Ii8bb0ShO7RcdjE+whG1g8zxIx1VO1/gvoE6sDfZjsoX5qML1c5RFrVzdABq5wug2jkKmJRHl/MEF70RkZyPEd4JUnE8kqHrP1a42qG4HOsAb64cPxaY48cJz/HamhSvuEshm5TjHVU7n+PUTtrEe0I5I+AT8GonfQJwE5woXO2QD0/Eq530icLVDhW648tlF+OTHFE7yBw/2VG18zlO7aQscFnUzin5wnxqodo5xaJ2Tg1A7XwOVDunAJPy1HKe4KI3IpJzK+GdIBXHkxm6/tbC1Q7FpbUDvLlyvDUwx9sIz/HamhSvuEshm5S2jqqdz3BvsqVMvO3KGQG3w7/JlmoH3ATthasd8mF7/JtsqfbC1Q4VurblsovxaY6oHWSOd3BU7XyGe5MtaYHLonY65gtzp0K109GidjoFoHY+A6qdjsCk7FTOE1z0RkRy7iy8E6Ti2IGh6+8iXO1QXLo4wJsrx7sAczwpPMdra1K84i6FbFJSjqqd5bjfLlrjG6jT5YyA03C143tp4CbICFc75MMMXO34Xka42qFClyqXXYyzjqgdZI7nHFU7y2FqJx7YN1B3zRfmboVqp6tF7XQLQO0sB6qdrsCk7FbOE1z0RkRy7i68E6TimGPo+nsIVzsUlx4O8ObK8R7AHD9deI7X1qR4xV0K2aT0dFTtfMqkdnqVMwLuxaB2egE3QW/haod82JtB7fQWrnao0PUsl12Mz3BE7SBzvI+jaudTB9VO33xh7leodvpa1E6/ANTOp0C10xeYlP0cUTtIzmcK7wSpOPZh6PrPEq52KC5nOcCbK8fPAub42cJzvLYmxSvuUsgm5RxH1c4nsLMmWeM72c4tZwR8LlztJBPnAjfBecLVDvnwPLjaSSbOE652qNCdUy67GJ/viNpB5vgFjqqdT2BqJxnYd7JdmC/MFxWqnQstaueiANTOJ0C1cyEwKS8q5wkueiMiOV8svBOk4ngBQ9ffX7jaobj0d4A3V473B+b4JcJzvLYmxSvuUsgm5VJH1c7HOLUTMfFeVs4I+DK82olcBtwElwtXO+TDy/FqJ3K5cLVDhe7SctnF+ApH1A4yx690VO18jFM7YQtcFrVzVb4wX12odq6yqJ2rA1A7HwPVzlXApLy6nCe46I2I5HyN8E6QiuOVDF3/AOFqh+IywAHeXDk+AJjj1wrP8dqaFK+4SyGblOscVTvLcL9dtMaznevLGQFfD1c7mcT1wE1wg3C1Qz68Aa52MokbhKsdKnTXlcsuxjc6onaQOX6To2pnGe63iwb2bOfmfGG+pVDt3GxRO7cEoHaWAdXOzcCkvKWcJ7jojYjkfKvwTpCK400MXf9A4WqH4jLQAd5cOT4QmOO3Cc/x2poUr7hLIZuU2x1VOx/Bzpp01sQ7qJwR8CC42klnBwE3wWDhaod8OBiudtLZwcLVDhW628tlF+M7HFE7yBwf4qja+QimdtIZC1wWtXNnvjDfVah27rSonbsCUDsfAdXOncCkvKucJ7jojYjkfLfwTpCK4xCGrn+ocLVDcRnqAG+uHB8KzPF7hOd4bU2KV9ylkE3KvY6qnQ9hZ42q8WxnWDkj4GFwtaMSw4CbYLhwtUM+HA5XOyoxXLjaoUJ3b7nsYjzCEbWDzPGRjqqdD2FqRwX2bGdUvjCPLlQ7oyxqZ3QAaudDoNoZBUzK0eU8wUVvRCTnMcI7QSqOIxm6/rHC1Q7FZawDvLlyfCwwx8cJz/HamhSvuEshm5TxjqqdD3C/XbSG2plQzgh4AlztpBITgJtgonC1Qz6cCFc7qcRE4WqHCt34ctnFeJIjageZ45MdVTsf4H67aGBqZ0q+ME8tVDtTLGpnagBq5wOg2pkCTMqp5TzBRW9EJOdpwjtBKo6TGbr+6cLVDsVlugO8uXJ8OjDHZwjP8dqaFK+4SyGblJmOqp33cd9A7Zt4Z5UzAp4FVzu+Pwu4CWYLVzvkw9lwteP7s4WrHSp0M8tlF+P7HFE7yByf46jaeR+mdvy4BS6L2rk/X5gfKFQ791vUzgMBqJ33gWrnfmBSPlDOE1z0RkRyniu8E6TiOIeh658nXO1QXOY5wJsrx+cBc/xB4TleW5PiFXcpZJMy31G18x7srInUUDsLyhkBL4CrnYi/ALgJFgpXO+TDhXC1E/EXClc7VOjml8suxg85onaQOf6wo2rnPZjaiQSmdh7JF+ZHC9XOIxa182gAauc9oNp5BJiUj5bzBBe9EZGcHxPeCVJxfJih639cuNqhuDzuAG+uHH8cmONPCM/x2poUr7hLIZuUJx1VO0thZ01CmXifKmcE/BRc7STUU8BN8LRwtUM+fBqudhI1eHtFXjbeiEL3ZLnsYvyMI2oHmePPOqp2lsLUTsKzwGVRO8/lC/PzhWrnOYvaeT4AtbMUqHaeAybl8+U8wUVvRCTnF4R3glQcn2Xo+l8UrnYoLi86wJsrx18E5vhLwnO8tibFK+5SyCblZUfVzruwsybumXhfKWcE/Apc7cS9V4Cb4FXhaod8+Cpc7cS9V4WrHSp0L5fLLsavOaJ2kDn+uqNq512Y2onlLHBZ1M4b+cL8ZqHaecOidt4MQO28C1Q7bwCT8s1ynuCiNyKS81vCO0Eqjq8zdP2LhKsdissiB3hz5fgiYI6/LTzHa2tSvOIuhWxSFjuqdt7BfUtBjW+gXlLOCHgJXO2kskuAm+Ad4WqHfPgOXO2ksu8IVztU6BaXyy7G7zqidpA5vtRRtfMO7lsKAvsG6vfyhfn9QrXznkXtvB+A2nkHqHbeAybl++U8wUVvRCTnD4R3glQclzJ0/R8KVzsUlw8d4M2V4x8Cc/wj4TleW5PiFXcpZJOyzFG1swR21oRqPNv5uJwR8MdwtRPyPgZugk+Eqx3y4SdwtRPyPhGudqjQLSuXXYw/LXdD7SBzfDmQc5BqZwnuG6gDe7bzWfk/f35eXlJT2dB/KFQ79Je41c4SoNr5DJiUn5fzBBe9EZGcvwAXH/SGo+K4vBx/MHxZzntwecVdiuLypQO8uXL8S2COfyU8x2trUrziLoVsUlYA8yZItbMYd9akTbxflzMC/rocrXa89NfATfANMLG4fPhNOVrteOlvmA8NRKFbUS67GH/riNpB5vh3jqqdxTC146UscFnUzvf5wvxDodr53qJ2fghA7QBPIPU9MCl/KOcJLnojIjn/KLwTpOL4HUPX/5NwtUNx+ckB3lw5/hMwx38WnuO1NSlecZdCNim/OKp23oadNbEab7L9Ws4I+Fe42ollfwVugt+Eqx3y4W9wtRPL/iZc7VCh+6VcdjH+3RG1g8zxPxxVO2/jfm4nsDfZ/swX5r8K1c6fFrXzVwBq522g2vkTmJR/lfMEF70RkZz/Ft4JUnH8g6HrL2kkW+1QXAijdN5cOW7iLHatDRrJzvHamhSvuEshm5Q6wLwJUu0sgp01qsZ3stVtxAiYFseqHaXqAjdBPeDm5PJhvUZotaNq8PaKvGy8EYWuTiPZxbg+uBhXX2jOyBxvgNx7JcGpnUW4N9kC+062hvnCXNqopKayadhoVbVDf4lb7SwCqp2GwKQsbcQTXPRGRHIuE94JUnFswND1lwtXOxSXcgd4c+V4OTDHGwnP8dqaFK+4SyGblMaOqp23cC9j1Pi5nSaNGAE3aYRft0K4QiHeFY1WOhi0LouqoILSuJHsolfpiKpA5mVT5kKPiElThhwPsqC+yVRQmzViBNyMoaBWCS+oxLsqoILqFXcp2hhVjXg2HIp3kJvsjTKcD0y8zRsxAm7OcCI2B1b0FsI3LPmwBcMmaCH8Hi1t0hYM8qcSGO8Nhd8uoNzZkKnYV1/ovb0hMD4bCZf4tSkGr7hLIRXDxsJznGK8MUMjh8xDahLql6y8zMN3E9qf9BcalATTRWwCDGgdA+em+UKzWeEDBfoPlxbMbZafMy/0A4VNgBHcdM3XSq9mLbUZuP1sWGJ/ylWylv5cHe4SxqTcFOgTcxNtXpiMmzdadZcVJh4yWVaDVa2OzObAJN6iESwZPNOnW6zBZi4W+2ZAPyB9uuVa+HR1/5bp0y2Nollq+NP0qVfcpf769/VC6ZwKR7PxqBdLRqKZWDiUCcW9TCSaUxpwKBHRrsmlI37GD4VzoXgo/RcW339yrLqwVR8kf5WsPEBovJX+c2ttLRv9c4oGpcW3NuKu/HAoFA9TfvgZT0Uy+ggIhTKpiJf2kulQNhFRiVwkFAmnM+mUzqWkynm5ZDqR8/9Zy8S7TSNGwNtYes1iwW8D7LG3Fa7FyYfbWnrNYn24LbgjKC0J5r2XrZkeG5dg/VujI9jObADQNy2AgVTmaWCCXkvM6TVJvu3WQYSuzunbATfz9uD2sNqv2xudy9rmgm7dVFp5OS8R8pJePB2LpxKZUMpP5sK5aDgTXle/ri7ZkX7dgcmvOwQg79YiJ1bbZe8A9OmOwm+srmteruZSyLzcCexDdNNT7UNkzuyEbyxq1GCvyOt/5VYD+iypvnb+t8bCK+5SOzEV6p3XvbFYo0N7J4YnV8+1+P96R3q1hwlx3pmB9/Ng3tVXvbXj761N8S6W8y7AhhqYNwoZC3M/7lJEQ7omzR7HfnxBSF6ujgcyL3c1b/9kwuFIJpFKq2golkx5fiac9HKReFjrgkw4nsmE/VgsGQ5nYn7OT+jzWysE34vG4wkvFgonQsBcUi8w5eWu+bwM8kEV8u6C2bTslr/FtrsrBzYXvt0YisEeTI3KHv9SGL3irv/4YncGX+zJ5Is9GQ8J8sUeDL54iblpK/ahLPHek4H3yy1k14Gt800B+m4AMN4K6cP/FRWLrrPV114uqti9/kXFrmaZNVJzezEUhlf+D6o5r5HMAvMKU9fsWW6DS1Y1ylQ14bDeG5m4ymVy4Wg8EUqpWDgWy0Vy8ZgfyeSikWQmnlWRZDiUyMa9nPKz2Xg0nI7HcolMOpYzi3axCokrPspQNbUdCpJvP3Li5DpgQi4eMCHmAybEcMC8ynTA1AfjRBawMHAt5O1C5GH1KlMxDK/BYVWsTyPA+Ji3uiQdVlzxifwP3YKL5m/BxajuoUHX9oAb+XJPsWsBH8yy/GRKtQ/Rr/Fy+bDYteLC40EbJs7QJPhMDZPPeLs2xuSLBJMvEoy3a8kPPoMv3hB+u5Z4Jxh4v+nA7do4w+1aYLzVm+tv1xZeCl1nq6+9OdV0nKkg7s2opgnz3gyF4S1HbtfGgU3RPo1kFpi3mBTWPgHcrkXGZ1/g7do3gQqYKz77WuKztgfh6t6YRcZnP6b6uR/AD6t7sxjph/2Z/LA/c2O9H8M5ssiBxnp/Bt5vM52fhTcoin1jHnkjABhr9fb6prrwUvsxNdUHuNhUH8DcVB/AUBQW/x9sqg8UWmAWMzVtBzrWVB8EbKrfBjbVXPE56P/DOxDIuyGcOLkOmINdPGAOZj5gDmY4YJY48g4EsoAdAlwLedcGeVgtYSqGhwTwDsShwB8derOFzMOKKz6HMj5WLKll3WLjfZjwnwSiNQ5jqL2HA+rQP7/PJ8fCm/AdzsD7COHxJs5HMPA+UjhvwnckA++jhPMmfEcx8D5aOG/CdzQD72OE8yZ8xzDwPlY4b8J3LAPv44TzJnzHMfA+3oFz7HgG3icI5034TmDgfaID8T6RgfdJwnkTvpMYeJ8snDfhO5mB9ynCeRO+Uxh4n+rA/j6VgXcr4bwJXysG3q2F8yZ8rRl4txHOm/C1YeDdVjhvwteWgXc7B+paOwbe7YXzJnztGXifJpw34TuNgXcH4bwJXwcG3h0d2N8dGXh3Es6b8HVi4N3ZgXh3ZuDdRThvwteFgXfSgXgnGXinhPMmfCkG3mnhvAlfmoF3Rjhvwpdh4J11YH9nGXjnhPMmfDkG3l0diHdXBt7dhPMmfN0YeHd3IN7dGXj3EM6b8PVg4H26cN6E73QG3j2F8yZ8PRl493Jgf/di4N1bOG/C15uB9xnCeRO+Mxh493Egz/sw8O4rnDfh68vAu58D8e7HwPtM4bwJ35kMvM9yIN5nMfA+Wzhvwnc2A+9zhPMmfOcw8D5XOG/Cdy4D7/OE8yZ85zHwPl84b8J3PgPvCxyo5xcw8L5QOG/CdyED74uE8yZ8FzHwvlg4b8J3MQPv/g7s7/4MvC8RzpvwXcLA+1IH4n0pA+/LhPMmfJcx8L5cOG/CdzkD7yuE8yZ8VzDwvlI4b8J3JQPvqxyoa1cx8L5aOG/CdzUD72sciPc1DLwHCOdN+AYw8L5WOG/Cdy0D7+scyPPrGHhfL5w34buegfcNwnkTvhsYeN8onDfhu5GB903CeRO+mxh43yycN+G7mYH3LcJ5E75bGHjfKpw34buVgfdA4bwJ30AG3rc50LfcxsD7duG8Cd/tDLwHCedN+AYx8B7sQJ4PZuB9h3DehO8OBt5DhPMmfEMYeN8pnDfhu5OB910O7O+7GHjfLZw34bubgfdQB+I9lIH3PcJ5E757GHjfK5w34buXgfcwB/J8GAPv4cJ5E77hDLxHOBDvEQy8RwrnTfhGMvAe5UC8RzHwHi2cN+EbzcB7jHDehG8MA++xwnkTvrEMvMcJ5034xjHwHi+cN+Ebz8B7ggP1fAID74nCeRO+iQy8JwnnTfgmMfCe7ECeT2bgPUU4b8I3hYH3VOG8Cd9UBt7ThPMmfNMYeE8XzpvwTWfgPUM4b8I3g4H3TOG8Cd9MBt6zHDjHZjHwni2cN+GbzcD7PuG8Cd99DLznCOdN+OYw8L5fOG/Cdz8D7wccqGsPMPCeK5w34ZvLwHuecN6Ebx4D7wcdyPMHGXjPF86b8M1n4L3AgXgvYOC9UDhvwreQgfdDwnkTvocYeD/sQJ4/zMD7EeG8Cd8jDLwfdSDejzLwfkw4b8L3GAPvx4XzJnyPM/B+woE8f4KB95PCeRO+Jxl4P+VAvJ9i4P20cN6E72kG3s8I5034nmHg/awDef4sA+/nhPMmfM8x8H5eOG/C9zwD7xeE8yZ8LzDwflE4b8L3IgPvl4TzJnwvMfB+WThvwvcyA+9XhPMmfK8w8H7VgfP7VQberwnnTfheY+D9ugPxfp2B9xvCeRO+Nxh4vymcN+F7k4H3W8J5E763GHgvEs6b8C1i4P22cN6E720G3ouF8yZ8ixl4LxHOm/AtYeD9jgPn9zsMvN8VzpvwvcvAe6lw3oRvKQPv9xzI8/cYeL8vnDfhe5+B9wfCeRO+Dxh4f+hAnn/IwPsj4bwJ30cMvJc5EO9lDLw/Fs6b8H3MwPsT4bwJ3ycMvD8VzpvwfcrAe7lw3oRvOQPvz4TzJnyfMfD+3IF6/jkD7y+E8yZ8XzDw/lI4b8L3JQPvrxzI868YeK8QzpvwrWDg/bUD8f6agfc3wnkTvm8YeH/rQLy/ZeD9nXDehO87Bt7fC+dN+L5n4P2DA3n+AwPvH4XzJnw/MvD+SThvwvcTA++fhfMmfD8z8P7Fgf39CwPvX4XzJny/MvD+TThvwvcbA+/fHcjz3xl4/yGcN+H7g4H3n8J5E74/GXj/JZw34fuLgfffwnkTvr8ZeJc0ls2b8JGheW8gnDfh24CBdx3hvOkcq8PAu65w3oSvLgPveg7Eux4D7/rCeRO++gy8GwjnTfgaMPBuKJw34WvIwLvUgf1dysC7TDhvwlfGwLvcgXiXM/BuJJw34WvEwLuxA/FuzMC7iXDehK8JA+8KB+JdwcC7UjhvwlfJwLupA/FuysC7mXDehK8ZA+8q4bwJXxUD7+YO5HlzBt4thPMmfC0YeG8onDfh25CB90bCeRO+jRh4byycN+HbmIH3JsJ5E75NGHhv6kA935SB92bCeRO+zRh4by6cN+HbnIH3FsJ5E74tGHhv6cD+3pKB91bCeRO+rRh4by2cN+HbmoF3S+G8CV9LBt7bCOdN+LZh4L2tcN6Eb1sG3ts5UM+3Y+C9vXDehG97Bt47OBDvHRh47yicN+HbkYH3Tg7EeycG3jsL5034dmbgvYsD8d6FgfeuwnkTvl0ZeO8mnDfh242B9+7CeRO+3Rl47+HA/t6DgfeewnkTvj0ZeO/lQLz3YuDtCedN+DwG3ko4b8KnGHiHHMjzEAPvsHDehC/MwDviQLwjDLyjwnkTvigD75gD8Y4x8I4L50344gy8feG8CZ/PwDshnDfhSzDw3tuB/b03A+99hPMmfPsw8N5XOG/Cty8D7/0cyPP9GHjvL5w34dufgfcBDsT7AAbeBwrn/R98DLwPciDeBzHwPlg4b8J3MAPvQ4TzJnyHMPA+VDhvwncoA+/DhPMmfIcx8D5cel3T+A5n4H2EA/X8CAbeRwrnTfiOZOB9lHDehO8oBt5HC+dN+I5m4H2MA/v7GAbexwrnTfiOZeB9nHDehO84Bt7HC+dN+I5n4H2CcN6E7wQG3ic6UNdOZOB9knDehO8kBt4nC+dN+E5m4H2KA3l+CgPvU4XzJnynMvBuJZw34WvFwLu1cN6ErzUD7zbCeRO+Ngy82wrnTfjaMvBu50A9b8fAu71w3oSvPQPv0xyI92kMvDsI5034OjDw7uhAvDsy8O4knDfh68TAu7MD8e7MwLuLcN6ErwsD76QD8U4y8E4J5034Ugy808J5E740A++McN6EL8PAOyucN+HLMvDOCedN+HIMvLs6UM+7MvDuJpw34evGwLu7A/HuzsC7h3DehK8HA+/THYj36Qy8ewrnTfh6MvDu5UC8ezHw7i2cN+HrzcD7DAfifQYD7z7CeRO+Pgy8+wrnTfj6MvDu50Ce92PgfaZw3oTvTAbeZwnnTfjOYuB9tgN5fjYD73OE8yZ85zDwPteBeJ/LwPs84bwJ33kMvM8Xzpvwnc/A+wLhvAnfBQy8L3Rgf1/IwPsi4bwJ30UMvC8WzpvwXczAu79w3oSvPwPvSxzY35cw8L5UOG/CdykD78sciPdlDLwvF86b8F3OwPsKB+J9BQPvK4XzJnxXMvC+yoF4X8XA+2rhvAnf1Qy8r3Eg3tcw8B4gnDfhG8DA+1oH4n0tA+/rhPMmfNcx8L5eOG/Cdz0D7xuE8yZ8NzDwvlE4b8J3IwPvm4TzJnw3MfC+WThvwnczA+9bhPMmfLcw8L5VOG/CdysD74HCeRO+gQy8bxPOm/DdxsD7duG8Cd/tDLwHCedN+AYx8B4snDfhG8zA+w7hvAnfHQy8hwjnTfiGMPC+UzhvwncnA++7hPMmfHcx8L5bOG/CdzcD76HCeRO+oQy87xHOm/Ddw8D7XuG8Cd+9DLyHCedN+IYx8B4unDfhG87Ae4Rw3oRvBAPvkcJ5E76RDLxHCedN+EYx8B7dGLdWPb1GlcHdvND+GA2Ml4l3TGNGwGMa49cdCwwgF++xjVc6GLQu20NJjoex48DFpfqqU8g/FvIjET8UTiXjIZWMpOKxXCKTTuZCfiqUSXpZ34tl4qFk2E/6EZVKJ30vlUmGovFMMpKNqRAyl8Yba+l/Me0lcl4y6ifjWb2Ql/X0IOVnc7FQMpWOeKGMUiob0f8vlM1EEqlMTKVi+l+PppT+39liHUqlE7F4XP8v05lUJKKiiVAyk1JxReQjOT8eTqlUWEMNx6O5UDYX8RLaGZpmTrsgnMpel8/LVXwYSSSzetlUOBbOpjTYXCgaSyb0/yody4ZjkRT5NxoO5WKRsPZbyAtHkrl0JOp7iZCfjkSuA/pwgvBDifBNYNgvE4XzJnwTGXhPEs6b8E1i4D1ZOG/CN5mB9xThvAnfFAbeU4XzJnxTGXhPE86b8E1j4D1dOG/CN52B9wzhvAnfDAbeM4XzJnwzGXjPEs6b8M1i4D1bOG/CN5uB933CeRO++xh4zxHOm/DNYeB9v3DehO9+Bt4PCOdN+B5g4D1XOG/CN5eB9zzhvAnfPAbeDwrnTfgeZOA9XzhvwjefgfcC4bwJ3wIG3guF8yZ8Cxl4PyScN+F7iIH3w8J5E76HGXg/Ipw34XuEgfejjj7UfZTpoe5jjRkBP8bwUPdx4Q91iffjjVc6GLQuC1Z6+DqeYZM9EdBD3WIfdCJz6cnGuAeltlirXC6di2fi2Vw4FErH46l4OB2NptJp/cA6lVJ6KuMntAP0rBfX/0ooHvPDfjid9lIqlsn954Hp45aHusqLxaOxRDKn/wHtk5CnVDiby2n+er1MJBnzoqloKBULZ2J+TtNSae2BTDQeykWyiZAKTQD68CnhhxLhe4phvzwtnDfhe5qB9zPCeRO+Zxh4PyucN+F7loH3c8J5E77nGHg/L5w34XuegfcLwnkTvhcYeL8onDfhe5GB90vCeRO+lxh4vyycN+F7mYH3K8J5E75XGHi/Kpw34XuVgfdrwnkTvtcYeL8unDfhe52B9xvCeRO+Nxh4vymcN+F7k4H3W8J5E763GHgvEs6b8C1i4P22cN6E720G3ouF8yZ8ixl4LxHOm/AtYeD9jnDehO8dBt7vCudN+N5l4L1UOG/Ct5SB93uOPtx8j+nh5vuNGQG/z/Bw8wPhDzeJ9weNVzoYtC4LVnoI+STDJvswoIebxT7wQ+bSR41xDwytsY7mvFwuFU9m09loNpxUsVQ0EopGkn4sG0n5fjLjZcL6b2RTuVAiGwpF40r/Q9FoOO7H0+ms/1Q+L1d5QJyMhyPZVCocioUjKptLqkTKC8dUJqHCXjoTiadCsVQ84vv6wWwmFMtm03oyp5/Z+nHtEZV8CujDZcIPJcK3jGG/fCycN+H7mIH3J8J5E75PGHh/Kpw34fuUgfdy4bwJ33IG3p8J5034PmPg/blw3oTvcwbeXwjnTfi+YOD9pXDehO9LBt5fCedN+L5i4L1COG/Ct4KB99fCeRO+rxl4fyOcN+H7hoH3t8J5E75vGXh/J5w34fuOgff3wnkTvu8ZeP8gnDfh+4GB94/CeRO+Hxl4/yScN+H7iYH3z8J5E76fGXj/Ipw34fuFgfevwnkTvl8ZeP8mnDfh+42B9++OPuT7nekh3x+NGQH/wfCQ70/hD/mI95+NVzoYtC4LVnoY9xHDJvsroId8xT74QubS341xD85ssdZPKiPJUDIV1X81kovGw/q5ptL/hJfTjzMJTDgTzSQTXiQVjkUSuVQonkp74ZRH/14ulYwvy+flKj5MJ3LJVDruR6KZqKdpRkPZUNILx1VaO0TlVCSa9TIpP5T1NZ1ETKVD0ZzKhvUj0xQ5aBlyPzaRvV8IHxl6v2wgnDfh24CBdx3hvAlfHQbedYXzJnx1GXjXE86b8NVj4F1fOG/CV5+BdwPhvAlfAwbeDYXzJnwNGXiXCudN+EoZeJcJ5034yhh4lwvnTfjKGXg3Es6b8DVi4N1YOG/C15iBdxPhvAlfEwbeFcJ5E74KBt6VwnkTvkoG3k2F8yZ8TRl4NxPOm/A1Y+BdJZw34ati4N1cOG/C15yBdwvhvAlfCwbeGwrnTfg2ZOC9URM3H3ZtBIyXiXfjJoyAN26CX3cTYAC5eG/SZKWDQeuyYKWHUn8zPOzaFFxcqq/CBzXFPgBC5tJmTXAPkGyxDmWj4ajn5fxYPJ3RT8ki9NAsFommo9FMKh4KZ5R+thby/Ggsk8rE48rPJiIpz9eOiefC+glfST4vV3nYFVJeLhsLR5OpSDoeyeincKl0Lu6l0iH99DCciMZ8T6P2QqFMJpFQOf04MROJerFkSs9HE5kSoA83F34oEb7NGQ6lLYTzJnxbMPDeUjhvwrclA++thPMmfFsx8N5aOG/CtzUD75bCeRO+lgy8txHOm/Btw8B7W+G8Cd+2DLy3E86b8G3HwHt74bwJ3/YMvHcQzpvw7cDAe0fhvAnfjgy8dxLOm/DtxMB7Z+G8Cd/ODLx3Ec6b8O3CwHtX4bwJ364MvHcTzpvw7cbAe3fhvAnf7gy89xDOm/DtwcB7T+G8Cd+eDLz3Es6b8O3FwNtz9KGPx/TQRzVhBKwYHvqEhD/0Id6hJisdDFqXBSs9nNmMYZOFg3roU+SDEGQuRZoAH6RYYq1BpFQulA7lwn5ao8omk7l4LJfLRZNeJhaJh9MqkU5EwvqhUtKPZKIJ/Q+reDgTyWRjqZQf2Tyfl4U+VMlMIpSLxPTifiaR1I5Meums5p3Ken5IRbNplVQ5Tzs6kc2mUvpRWSyTyUZjyZBKaD9mNwf6MCr8UCJ8UYb9EhPOm/DFGHjHhfMmfHEG3r5w3oTPZ+CdEM6b8CUYeO8tnDfh25uB9z7CeRO+fRh47yucN+Hbl4H3fsJ5E779GHjvL5w34dufgfcBwnkTvgMYeB8onPd/8DHwPkg4b8J3EAPvg4XzJnwHM/A+RDhvwncIA+9DhfMmfIcy8D5MOG/CdxgD78OF8yZ8hzPwPkI4b8J3BAPvI4XzJnxHMvA+ytGHH0cxPfw4ugkj4KMZHn4cI/zhB/E+pslKB4PWZcFKDykiDJvs2IAefhT7QACZS8c1wT1QsMVaheKxdCQXCoe9aDrsaZ6hbNhLxnOprB9NZbx0LpzNhjJeMhfNqbAGoFQinvEyubBGkszkovm8XMWHmWzGT/heMhtKZTIqGQmFNEJPL5rwc2k/HfVzUS8aj6eT0WQ0nQ2nQmk/7vvRXDrjpaKhcBTow+OFH0qE73iG/XKCcN6E7wQG3icK5034TmTgfZJw3oTvJAbeJwvnTfhOZuB9inDehO8UBt6nCudN+E5l4N1KOG/C14qBd2vhvAlfawbebYTzJnxtGHi3Fc6b8LVl4N1OOG/C146Bd3vhvAlfewbepwnnTfhOY+DdQThvwteBgXdH4bwJX0cG3p2E8yZ8nRh4dxbOm/B1ZuDdRThvwteFgXfS0YcASaaHAKkmjIBTDA8B0sIfAhDvdJOVDgaty4KVbtYfx7DJMkE9BCjyxjgyl7JNcDfWrbFORvVzg4zKxEOhdC4dS9Bvt0nm0nF68BGNJuIpDVH/K4lMOh1O5fTfTej/mE0m0mm9eDJ1fD4vC30YiqlQNJNUXtLLZrxYOBSPen4ylfRiGaWdGU6mYyqmpzOpbCYcSeSiYc0mk0xEw+Fw3I/Gjwf6MCf8UCJ8OYb90lU4b8LXlYF3N+G8CV83Bt7dhfMmfN0ZePcQzpvw9WDgfbpw3oTvdAbePYXzJnw9GXj3Es6b8PVi4N1bOG/C15uB9xnCeRO+Mxh49xHOm/D1YeDdVzhvwteXgXc/4bwJXz8G3mcK5034zmTgfZZw3oTvLAbeZwvnTfjOZuB9jnDehO8cBt7nCudN+M5l4H2eozfDz2O6GX5+E0bA5zPcDL9A+M1w4n1Bk5UOBq3LgpVuWmcZNtmFAd0ML/YGMTKXLmqCu8FsjXXWC8fikay+eR7NRDPxWCydSYX03f9kTj8GiMRz8axKeF4sF4uFQoloLBtPRxJpFfGzaS8RjkRz+bxc5WZ4KOZp2hE/Eknpm/OhqPJDiXA0nIj52UhCRfVzhlDUjyg/HI1H4mF9815ltGdzMRXOxdKpTA7ow4uFH0qE72KG/dJfOG/C15+B9yXCeRO+Sxh4XyqcN+G7lIH3ZcJ5E77LGHhfLpw34bucgfcVwnkTvisYeF8pnDfhu5KB91XCeRO+qxh4Xy2cN+G7moH3NcJ5E75rGHgPEM6b8A1g4H2tcN6E71oG3tcJ5034rmPgfb1w3oTvegbeNwjnTfhuYOB9o3DehO9GBt43OXpT+Camm8I3N2EEfDPDTeFbhN8UJt63NFnpYNC6LFjp5u1FDJvs1qBuChd5oxSZSwOb4G602mKtYn4sodLhZCwZieqFoulINp1NJdOpdDyX9HKxUDoczUUSMf0fEvpes74HngpHsxpGOBTOhUIX5/Oy0IcqkclokLlw0s9EYmkVTXsqHsulUtFUIpqNZNLRuOf7uZyGFsmoVMaPpGOpXDIaz6QzaR2Ai4E+vE34oUT4bmPYL7cL5034bmfgPUg4b8I3iIH3YOG8Cd9gBt53COdN+O5g4D1EOG/CN4SB953CeRO+Oxl43yWcN+G7i4H33cJ5E767GXgPFc6b8A1l4H2PcN6E7x4G3vcK50347mXgPUw4b8I3jIH3cOG8Cd9wBt4jhPMmfCMYeI8UzpvwjWTgPcrRm6OjmG6Ojm7CCHg0w83RMcJvjhLvMY7cHKWbmAMZNtnYgG6OFnvDEJlL45rgbjjaYq30QiHPj4cTUf0XQzH9v8yl/GwukYyH9M3fpKbk5VKJXCiseeT8sErrv6oph1TcS8ZV5rZ8Xq7iw1TOD2W00+KZeCThaY9pbOm0vpHsZWNK32SOqlA2ndS3lqPRkPKyoXgsq/3hp7N+Lupno7cBfThe+KFE+MYz7JcJwnkTvgkMvCcK5034JjLwniScN+GbxMB7snDehG8yA+8pwnkTvikMvKcK5034pjLwniacN+GbxsB7unDehG86A+8ZwnkTvhkMvGcK5034ZjLwniWcN+GbxcB7tnDehG82A+/7hPMmfPcx8J4jnDfhm8PA+35HbxLez3ST8IEmjIAfYLhJOFf4TULiPdeRm4R0M28cwyabF9RNwiJvnCFz6cEmuBtvtliHcvFoQq/ox5O5VCgbiYZTUT+W8/W90Fw8Fc0qFUv5fkgv6kdyIRWOh+K5WCKnVFT/zXQkNT6fl3VWyaFsNhVKp6IJX2UzkWgskkimsqlM1vNVJq1vZMbSfsxTmWwkHIln45mMioX8VDKUSSbTkXAqPh7ow/nCDyXCN59hvywQzpvwLWDgvVA4b8K3kIH3Q8J5E76HGHg/LJw34XuYgfcjwnkTvkcYeD8qnDfhe5SB92PCeRO+xxh4Py6cN+F7nIH3E8J5E74nGHg/KZw34XuSgfdTwnkTvqcYeD8tnDfhe5qB9zPCeRO+Zxh4P+vozbJnmW6WPdeEEfBzDDfLnhd+s4x4P+/IzTK6qfUgwyZ7IaCbZcXeQELm0os1OBd3A8oa63DET/pe2I9nc+lwwk/FMvSOYFrFE9FQ2s+EYl4ilVWpsJ8MZ/QNxEQymUmkE7GkyiRU2IvPz+flKj7MqFQyFtNUIhpbQnkqrv8vl4wlsulQKuN5oVBS/18mor2W9LxEkn5O289lItlQLJvOpeYDffiS8EOJ8L3EsF9eFs6b8L3MwPsV4bwJ3ysMvF8VzpvwvcrA+zXhvAnfawy8XxfOm/C9zsD7DeG8Cd8bDLzfFM6b8L3JwPst4bwJ31sMvBcJ5034FjHwfls4b8L3NgPvxcJ5E77FDLyXCOdN+JYw8H7H0ZtG7zDdNHq3CSPgdxluGi0VftOIeC915KYR3dx5kWGTvRfQTaNib6Qgc+n9JrgbMdZYh9KZnB9SKhyNp1JJP5HwVC6cy8bDyYi+ZRaJa5LJRCzu6TtV6SgNw/FcOKP8rB9OqHjmpXxernrTKBGLxqIqnckkshFfqVwkG1Up38tk0knt3VREo8tmVTwS8pLJbCyp72x5Kh2KqXg6lvWjLwF9+IHwQ4nwfcCwXz4UzpvwfcjA+yPhvAnfRwy8lwnnTfiWMfD+WDhvwvcxA+9PhPMmfJ8w8P5UOG/C9ykD7+XCeRO+5Qy8PxPOm/B9xsD7c+G8Cd/nDLy/EM6b8H3BwPtL4bwJ35cMvL9y9ObJV0w3T1Y0YQS8guHmydfCb54Q768duXlCNzneZ9hk3wR186TIGwrIXPq2Ce6GhC3WoVwukgyHEiE/Hc+pdDzlh0PRZDbr+elsTmVVNKriuUgsmk3pPzSFXCKc0XdmYtFIhH4lbuiDfF6u4kMvlkumIppvLKGhhOiXAWeTaT/up0KxWDyVCatULpwN+dmwvt0Tj0WSSfrLmUQqldH/rcYNj2J9+J3wQ4nwfcewX74Xzpvwfc/A+wfhvAnfDwy8fxTOm/D9yMD7J+G8Cd9PDLx/Fs6b8P3MwPsX4bwJ3y8MvH8Vzpvw/crA+zfhvAnfbwy8fxfOm/D9zsD7D+G8Cd8fDLz/dPQmwp9MNxH+asII+C+Gmwh/C7+JQLz/duQmAon9bxk2WUlFMDcRihXWyFzaoAInzG2xDsXDobifSXthfbshp5KpWDwUj0ZCfiQU08zDKRUJxbO+8pKpaCaS8UPxRNL3QiqbS2VCqbT/XT4vV7mJkAjTryiMZbKhXEZ5OQ01k/Hi4Zz2VMJLJuKxnIol0voPL6zxJVQ6Eo9H45pTJJSJhJPfAX1Yp0L2fiF8ZOj9Ulc4b8JXl4F3PeG8CV89Bt71hfMmfPUZeDcQzpvwNWDg3VA4b8LXkIF3qXDehK+UgXeZcN6Er4yBd7lw3oSvnIF3I+G8CV8jBt6NK9wU042B8TLxNqlgBNykAr9uBTCAXLwrKlY6GLQuC1YSvRswbLLKoMR0kQITmUtNK3AC1RbrkJbjys9mI/FYOpHKZb0I/XaqTDaTjqRyyWwqlotrSlqJR0OReC4di4cz8UQ6kYwnYtGMCv1HqBLfVd9qiCfDUT+SSKQ14VAqFdEzuUw8GQ1Ho5m4SvlpFUqreDySiOS8dDLjecmon9McEslQNhuqA/RhM+GHEuFrxrBfqoTzJnxVDLybC+dN+Joz8G4hnDfha8HAe0PhvAnfhgy8NxLOm/BtxMB7Y+G8Cd/GDLw3Ec6b8G3CwHtT4bwJ36YMvDdzVFRuxiQqN69gBLw5g6jcQrioJN5bOCIqSfw1ZdhkWwYlKosUWshc2qoCJ9RssQ4lNPxISsWVSuTS9EtNEspP+Pp/m0tkY/FENqtZZf14xsvGEn42FlZZP5pLhcLhjEpq9dosn5eriMqY1r0JDcZT8WQk5GVTqWwqrTF7fjyusuEwfXNlIu0l/Yx+mJxMKZVLJKJZpf9ONppQoWZAH24t/FAifFsz7JeWwnkTvpYMvLcRzpvwbcPAe1vhvAnftgy8txPOm/Btx8B7e+G8Cd/2DLx3EM6b8O3AwHtH4bwJ344MvHdyVFztxCSudq5gBLwzg7jaRbi4It67OCKuSARtxbDJdg1KXBUpOJC5tFsFTrDYYh1SkVhMRcPZZCQZ99KZlJ/wlNaJyXA2FlXZeMTzwqmsF4tnIhqbSqWSSf0UMBdK+rls0g9Hts7n5SriKqe0GtUPMWOafC6aymlHhtJeNpNJpPRq0awf9kLJiMql474GG/UT4WQ8l1QRTS4aT2e3Bvpwd+GHEuHbnWG/7CGcN+Hbg4H3nsJ5E749GXjvJZw34duLgbcnnDfh8xh4K+G8CZ9i4B0SzpvwhRh4hx0VGWEmkRGpYAQcYRAZUeEig3hHHREZJAZ2Y9hksaBERpGNNzKX4hW4xt0W65CfCvsJpcIplVHpUCQdTydD0VgqG4ropz/JdDqm2UVzERWK+fFszIunItkEPTlKRZP0K+p3z+flKiIjnvLS0ZgWXSriRzz9RMmPhbxIMpELx3I5DVfFE5FQNKJhe7lQ2EtrsDGVUHH9z8aT8djuQB/6wg8lwucz7JeEcN6EL8HAe2/hvAnf3gy89xHOm/Dtw8B7X+G8Cd++DLz3E86b8O3HwHt/R5vt/Zma7QMqGAEfwNBsHyi82f5PoBxptqkpjjNssoOCaraLbECRuXRwBa6BtcVaJeIZ5cWjYa0gEjH9wdeLRVQikQj5ukvPeMmYnwhlw+lQOh6K6CcJsUw4qZ9mhKOxUDae+0+jeKCl2VZaEIQzuUySvkkjkVCZXDSd1Y8j9LOPhOboqUw6FY3GIqlYjhycSOjHI1oUpFPJREa7RvlAHx4i/FAifIcw7JdDhfMmfIcy8D5MOG/CdxgD78OF8yZ8hzPwPkI4b8J3BAPvIx1tOo9kajqPqmAEfBRD03m08KaTeB/tSNNJzeHBDJvsmICazmIbMWQuHVuBa+RssVbpSDqsW2rdviYSXlTfPfbCsWTEC8f1dDKWzCo/ozKhSDSU0QtndJsdSeeSfjaTjXu5TNo/JJ+Xq/gwov/FSCQTTXm+l0snqXfPpOKxSCKl8Wt8sWQsnQpFQrFsOBRJZTOpRET3zVHdbua8UDh5CNCHxwk/lAjfcQz75XjhvAnf8Qy8TxDOm/CdwMD7ROG8Cd+JDLxPcrT5Oomp+Tq5ghHwyQzN1ynCmy/ifYojzRc1SccybLJTg2q+imxIkLnUqgLX0NhiHYolciqVTOt7iTF9OzEeUhk/FE0mwvQucFTf+UyrlAqH0rlYSN/NjNN9Rn2LMeKlIpFkNhMOHZfPy1UeryfSUf0/i2n+qUQ4Q69F+yHPy0TiaS8VSiYSae1E+iU+YT+b1XdWw9lsJqL/J+FUKqpCmRoNU7E+bC38UCJ8rRn2SxvhvAlfGwbebYXzJnxtGXi3c7QJacfUhLSvYATcnqEJOU14E0K8T3OkCaFmoRXDJusQ1GPHIg9mZC51rMAd7NZY67tImp+XTsaiWU+3LSn978fiXjatuy59s8vPpqPZdCweC8WS8UhO3/lKp7OptP4f5DTiXLx1Pi9X8aHy/JB+Wqt0W5TKRbIqHctqN+lbVZlM1PPTiUQsk9P/ln4mms2lEn5Kqajmp9sn7bCYl2oN9GEn4YcS4evEsF86C+dN+Doz8O7i6GHchekwTlYwAk4yHMYp4Ycx8U45chjTodmRYZOlAzqMiz2gkLmUqcAdcNZYR8NeRv+7yo/rWwcerRxJxv1YNplRsUQololmaDmNNhmKxfxYMheNRPyIfhoVCSWVH+qUz8tVDuNUOBzPaIi6c4nkQqFsWhPMhnIJvUJWP92KhmKheDgWy/kq7iU93cv4+q5GJKn7nEw069c4QIv1YVb4oUT4sgz7JefooZRjOpS6VjAC7spwKHUTfigR726OHEp0eGQYNln3oA6lIgs1Mpd6VOAK/ZrEOhVORzLxRCaikgkVj/rpVCSRDkdVPK2PtUgyGtInb06FwjHPz6UT+jDO52Wd1cTai/ipWFZpYhk/orQL0tlkKJKL5TIacSqbDoVVyIvE9apx/UwgHMsCfXi6o8X5dKbi3LOCEXBPhuLcS3hxJt69HCnOVER7MBTn3kEV54JrbQsWMpfOqMAVPFusETE5gyHWfcxnp344pE8d+nt+xlORTDrkh0KZVMTTt1PToWwiohK5SCgSTmfSKb1mUuW8XDKdyPn/rBVkQe3DVFD7VjAC7stQUPsJL6jEux9DQaVkKy1ZWVRsV/W/VWxic/ilekOj/WIm85lGvsErRz/cDlSErW4eYzVoCnCDkprVxJUgmEl5Vn79s4kXRxDOZKgqZzLf/EHxXl1LsZZXDd7FYjxH+A00SsxzGFqKc8FHc3VhoHUvza+L9sXZTL44j8kX5zH6gqvVPF94TaH4n8vA+90W/195p1eDTxHv8xh4L20hu/4R7/MZzhBgvBXSh9RQNSxZs455dWutLqfMNdFxQ58v1dcF/9Yte8Vd6hymg8AEvZaY1er+HcJ8AUNheB9cGKqvemsZs7Vp4IrlfGGFzAKDjIWZlxcaDcq6xmd1PkfG5yLzPlg4rPdGJq5ymVw4Gk+EUipGz2IiuXjMj2T0I6JkJp5VkWQ4lKAfZ6BfFBWPhulX+SYy6VjOLNoqEw5HMolUWulHOsmU52fCSS8XiYdDXjKjHwFlwn4slgyHMzE/5yf0XYlkLux70Xg84cVC4USIKz4XWeKztgfh6m6bIONzMVP9vBjgh9XdXkL6oT+TH/r/i6BANNYXM5wjHzjQWPdn4P0h0/lZtwBnsbdNgT2PAsZafbi+qS681MVMTfUlLjbVlzA31ZcwFIWP/g821ZcKLTAfMTVtlzrWVF8GbKo/BDbVXPG5LB+ffzsUJN8N4cTJdcBc7uIBcznzAXM5wwGzjOmAqQ/GiSxgVwDXQt61QR5Wy5iK4RVrcFgV69MrK3CHQo27NoIOK674XFnEI8TVKb/qx/N11y7e6dWsuzYvO612LeSj/qsqcL4zY3RVETFanXpfxxhlFP1YgPJyXkInsBdPx+KpRCaU8nXa5qLhTHhtXkhb3VrIGF1dgfOdGaOrLXWu7lrGanVw1iK/VtsfXA306TXCX3FZ1xxfm3ffil0LmeMDgIKY1ii8E17sHcHqeCDzb0AFHGeNc6bYtc7ErfU/c7fxqgpsT1N9XcspBgeAQVcfINf+ixhENCYDGMTgp/9/3+1Z7SFHnK9l4L3ckbusA4BF9jrgoQLMG7WcSRhdx/go9Gqm/fiZkLxcHQ9kXl4PFP/AXFKfMeXl9cbd5cIfjCipJV+94i6FfGfXbFpuyP9QxI2uHNhc+G5gKAY3MTUqNxVxN8JbA1/cyOCLm5l8cTPjIUG+uInBF18If1+GeN/MwPtL4S+in1+LivWKuxQw3urL9e/MFF4KXWerr1tcVLG3MD7SJMy3MBSGr/4PqrlbK2QWmK+YuuZbA3hnBhmfgcB3Zr4EPobkis/A/w/vzFxVwbPvXTlgbnPxgLmN+YC5jeGAWeHIOzPIAnY7cC3k7ULkYbWCqRjeHsA7M4OA8fmshczDiis+g4zDKqhvOjof+CzSxDu4ghHwYIaHsoOBnesdwE3A5cM7LAdSsT68w4FboncwvLCBPOCQuTME/MJG9VUH7L/zgZzvZM5BRK7YctAr7kI2xtD6dRc4HujbmJR7QIyK9tydDM3+3WDhQ99uV52D1Vj/yo/p3/oL6+f//Jt1jH9v00Yr/73N8uOh+t+9R9u91c1DAT4QFnUv0JfUrDU3fMmJeyjTnYUSKM4Q39pq5Z0G+rNlfjxM+2W4thHaRmobpW20tjHaxmobp228tgnaJmqbpG2ytinapmqbpm26thnaZmqbpW22tvu0zdF2v7YHtM3VNk/bg9rma1ugbWFFHkx1F09gSgvmhlvmRljmRlrmRlnmRlvmxljmxlrmxlnmxlvmJljmJlrmJlnmJlvmpljmplrmplnmplvmZljmZlrmZlnmZlvm7rPMzbHM3W+Ze8AyN9cyN88y96Blbr5lboFlbmF+zry2yf95YP5Pr7irRtEp9hAbBlgrm6PLU8NBaxHHEZC1/vHXyOLXClU/XxxV7FqRlc8qRxe3lmc+9xxTzFqhms9Qx677Wl7h89hx67iWvkm0yrPd8eu2lm97TjxhXdby7c+cJ679WvHanl9PWtu14rU/C5+8dmuF/u25+pS1WSv+78/op675Wqt9h2Tamq4VX20tVNPXbC1vDeqqmrEma3lrVKPVzNWvFV3Deq9mrW6tyBqfHWr2v65Fv3Nrzde679/Wiq/Vmabm1L6Wv5bno7q/lrUSubU+a9UD9rW8dTi31VzbWt469QBq3qprqXXsJ9SDhWtl1rk3UfNrrhUuos9RC4y1Qrmieia1ECj6qG+8oWSlcFqYFzHz86JmXl7kPJAXPXPyImh2XhTNzIuk6XnRNDUvoibnRdXEvMganxddY/MibHRelI3MizTq3agXpCvIpx0LYf1npsbTjocqGAHT4qg7rtXgH8IllXoYKBC4fEgYUXfkqn34MHBj0iZoVhLM+ym4gpJhvdNj+uKR/AZ7tPBuyyP5wJpzj1pUMfp2O66SeOoR4AZ6FBxcdPLRpnkEuBmreT8C3oxBnUgLYHmUyJh4H6tgBPwY/ERKZB4DnkiPCz+RyIePw0+kROZxR0+kBTDcibQFLsuJ9ER+gz1ZeCI9YTmRngzgRFoAPJGeAG6gJ5mCi34JAcn5KWAxKynBn5YP5wsQ+mE6Ugo8DSxmNh96xV2KYvw0QyfztKOdzHxY/UmFTbzPVDACfgbeyaTCzwA3/7PCOxny4bPwTiYVfpZ58yMK6NPCC+hzYB9WX+iDF5njzwP3XpAd8HwY7lTIApelA34hX5hfLOyAX7B0wC8G0AHjTiBPvQBMyheZgoveiEjOLzF3wF5xl6Li+DxD9/ay8K6V4vKyA7y5cvxlYI6/IjzHa2tSEM0Paq1XwQd2UGrnQdhZ4+dMvK9VMAJ+Da52/NxrwAC+LlztkA9fh6sdP/e6cLVDhe7VCtnF+A1wMa6+0JyROf6mo2rnQRhuP2uBy6J23soX5kWFaucti9pZFIDawZ1AnnoLmJSLmIKL3ohIzm8L7wSpOL7J0PUvFq52KC6LHeDNleOLgTm+RHiO19akeMVdCtmkvOPos515sLMmVOOrgt6tYAT8LlzthLx3gZtgqXC1Qz5cClc7IW+pcLVDhe6dCtnF+D1H1A4yx993VO3Mg+FWOQtcFrXzQb4wf1iodj6wqJ0PA1A7uBPIUx8Ak/JDpuCiNyKS80fCO0Eqju8zdP3LhKsdissyB3hz5fgyYI5/LDzHa2tSvOIuhWxSPnFU7cyFnTWZGmrn0wpGwJ/C1U7G+xS4CZYLVzvkw+VwtZPxlgtXO1ToPqmQXYw/c0TtIHP8c0fVzlwY7nRgaueLfGH+slDtfGFRO18GoHZwJ5CnvgAm5ZdMwUVvRCTnr4R3glQcP2fo+lcIVzsUlxUO8ObK8RXAHP9aeI7X1qR4xV0K2aR846jaeQB21sRqfCfGtxWMgL+Fq52Y+ha4Cb4TrnbIh9/B1U6sBm+vyMvGG1HovqmQXYy/d0TtIHP8B0fVzgMw3LHAvkvlx3xh/qlQ7fxoUTs/BaB2cCeQp34EJuVPTMFFb0Qk55+Fd4JUHH9g6Pp/Ea52KC6/OMCbK8d/Aeb4r8JzvLYmxSvuUsgm5TdH1c79uGc7von39wpGwL/jn+34vwM3wR/C1Q758A/8sx3/D+FqhwrdbxWyi/GfjqgdZI7/5ajauR+GOxO3wGVRO39XF+bKkprK5m+L2qG/xK12cCeQp/5GFt5KnuCiNyKS8waV2OKD3nBUHP9i6PrrVPIeXF5xl6K4EEbpvLly3MRZ7Fp1hed4bU2KV9ylkE1KPWDeBKl25sDOmkjCxFu/khEwLY5VO5FEfeAmaADcnFw+bFCJVjuRRAPmQwNR6OpVyi7GDcHFuPpCc0bmeCmQc5BqZw5M7UR8C1wWtVOWL8zlhWqnrHJVtVMegNqZA1Q7ZcCkLK/kCS56IyI5NxLeCVJxLGXo+hsLVzsUl8YO8ObK8cbAHG8iPMdra1K84i6FbFIqHFU798HOmlSNN9kqKxkBV8LVTkpVAjdBU+Fqh3zYFK52UjV4e0VeNt6IQldRKbsYN3NE7SBzvMpRtXMfTO2kAnuTrXm+MLcoVDvNLWqnRQBq5z6g2mkOTMoWlTzBRW9EJOcNhXeCVByrGLr+jYSrHYrLRg7w5srxjYA5vrHwHK+tSfGKuxSySdnEUbUzG6d20ibeTSsZAW+KVzvpTYGbYDPhaod8uBle7aQ3E652qNBtUim7GG/uiNpB5vgWjqqd2Ti1k7LAZVE7W+YL81aFamdLi9rZKgC1MxuodrYEJuVWlTzBRW9EJOethXeCVBy3YOj6WwpXOxSXlg7w5srxlsAc30Z4jtfWpHjFXQrZpGzrqNqZhXuTLWXi3a6SEfB2+DfZUtsBN8H2wtUO+XB7/Jtsqe2Fqx0qdNtWyi7GOziidpA5vqOjamcW7k22pAUui9rZKV+Ydy5UOztZ1M7OAaidWUC1sxMwKXeu5AkueiMiOe8ivBOk4rgjQ9e/q3C1Q3HZ1QHeXDm+KzDHdxOe47U1KV5xl0I2Kbs7qnZmws4av8Y3UO9RyQh4D7ja8b09gJtgT+Fqh3y4J1zt+N6ewtUOFbrdK2UX470cUTvIHPccVTszYWonHtg3UKt8YQ4Vqh1lUTuhANTOTKDaUcCkDFXyBBe9EZGcw8I7QSqOHkPXHxGudiguEQd4c+V4BJjjUeE5XluT4hV3KWSTEnNU7cxgUjvxSkbAcQa1EwduAl+42iEf+gxqxxeudqjQxSplF+OEI2oHmeN7O6p2ZjiodvbJF+Z9C9XOPha1s28AamcGUO3sA0zKfR1RO0jO+wnvBKk47s3Q9e8vXO1QXPZ3gDdXju8PzPEDhOd4bU2KV9ylkE3KgY6qnemwsyZZ4zvZDqpkBHwQXO0kEwcBN8HBwtUO+fBguNpJJg4Wrnb+U+gqZRfjQxxRO8gcP9RRtTMdpnaSgX0n22H5wnx4odo5zKJ2Dg9A7UwHqp3DgEl5eCVPcNEbEcn5COGdIBXHQxm6/iOFqx2Ky5EO8ObK8SOBOX6U8ByvrUnxirsUskk52lG1Mw2ndiIm3mMqGQEfg1c7kWOAm+BY4WqHfHgsXu1EjhWudqjQHV0puxgf54jaQeb48Y6qnWk4tRO2wGVROyfkC/OJhWrnBIvaOTEAtTMNqHZOACbliZU8wUVvRCTnk4R3glQcj2fo+k8WrnYoLic7wJsrx08G5vgpwnO8tibFK+5SyCblVEfVzlTcbxet8WynVSUj4FZwtZNJtAJugtbC1Q75sDVc7WQSrYWrHSp0p1bKLsZtHFE7yBxv66jamYr77aKBPdtply/M7QvVTjuL2mkfgNqZClQ77YBJ2b6SJ7jojYjkfJrwTpCKY1uGrr+DcLVDcengAG+uHO8AzPGOwnO8tibFK+5SyCalk6NqZwrsrElnTbydKxkBd4arnXS2M3ATdBGudsiHXeBqJ53tIlztUKHrVCm7GCcdUTvIHE85qnamwNROOmOBy6J20vnCnClUO2mL2skEoHamANVOGpiUmUqe4KI3IpJzVngnSMUxxdD154SrHYpLzgHeXDmeA+Z4V+E5XluT4hV3KWST0s1RtTMZdtaoGs92ulcyAu4OVzsq0R24CXoIVzvkwx5wtaMSPYSrHSp03SplF+PTHVE7yBzv6ajamQxTOyqwZzu98oW5d6Ha6WVRO70DUDuTgWqnFzApe1fyBBe9EZGczxDeCVJx7MnQ9fcRrnYoLn0c4M2V432AOd5XeI7X1qR4xV0K2aT0c1TtTML9dtEaaufMSkbAZ8LVTipxJnATnCVc7ZAPz4KrnVTiLOFqhwpdv0rZxfhsR9QOMsfPcVTtTML9dtHA1M65+cJ8XqHaOdeids4LQO1MAqqdc4FJeV4lT3DRGxHJ+XzhnSAVx3MYuv4LhKsdissFDvDmyvELgDl+ofAcr61J8Yq7FLJJuchRtTMR9w3Uvon34kpGwBfD1Y7vXwzcBP2Fqx3yYX+42vH9/sLVDhW6iyplF+NLHFE7yBy/1FG1MxGmdvy4BS6L2rksX5gvL1Q7l1nUzuUBqJ2JQLVzGTApL6/kCS56IyI5XyG8E6TieClD13+lcLVDcbnSAd5cOX4lMMevEp7jtTUpXnGXQjYpVzuqdibAzppIDbVzTSUj4GvgaifiXwPcBAOEqx3y4QC42on4A4SrHSp0V1fKLsbXOqJ2kDl+naNqZwJM7UQCUzvX5wvzDYVq53qL2rkhALUzAah2rgcm5Q2VPMFFb0Qk5xuFd4JUHK9j6PpvEq52KC43OcCbK8dvAub4zcJzvLYmxSvuUsgm5RZH1c542FmTUCbeWysZAd8KVzsJdStwEwwUrnbIhwPhaidRg7dX5GXjjSh0t1TKLsa3OaJ2kDl+u6NqZzxM7SQ8C1wWtTMoX5gHF6qdQRa1MzgAtTMeqHYGAZNycCVPcNEbEcn5DuGdIBXH2xm6/iHC1Q7FZYgDvLlyfAgwx+8UnuO1NSlecZdCNil3Oap2xsHOmrhn4r27khHw3XC1E/fuBm6CocLVDvlwKFztxL2hwtUOFbq7KmUX43scUTvIHL/XUbUzDqZ2YjkLXBa1MyxfmIcXqp1hFrUzPAC1Mw6odoYBk3J4JU9w0RsRyXmE8E6QiuO9DF3/SOFqh+Iy0gHeXDk+Epjjo4TneG1NilfcpZBNymhH1c5Y3LcU1PgG6jGVjIDHwNVOKjsGuAnGClc75MOxcLWTyo4Vrnao0I2ulF2MxzmidpA5Pt5RtTMW9y0FgX0D9YR8YZ5YqHYmWNTOxADUzlig2pkATMqJlTzBRW9EJOdJwjtBKo7jGbr+ycLVDsVlsgO8uXJ8MjDHpwjP8dqaFK+4SyGblKmOqp0xsLMmVOPZzrRKRsDT4Gon5E0DboLpwtUO+XA6XO2EvOnC1Q4VuqmVsovxDEfUDjLHZzqqdsbgvoE6sGc7s/KFeXah2pllUTuzA1A7Y4BqZxYwKWdX8gQXvRGRnO8T3glScZzJ0PXPEa52KC5zHODNleNzgDl+v/Acr61J8Yq7FLJJecBRtTMad9akTbxzKxkBz4WrHS89F7gJ5glXO+TDeXC146XnCVc7VOgeqJRdjB90RO0gc3y+o2pnNEzteCkLXBa1syBfmBcWqp0FFrWzMAC1AzyB1AJgUi6s5AkueiMiOT8kvBOk4jifoet/WLjaobg87ABvrhx/GJjjjwjP8dqaFK+4SyGblEcdVTujYGdNrMabbI9VMgJ+DK52YtnHgJvgceFqh3z4OFztxLKPC1c7VOgerZRdjJ9wRO0gc/xJR9XOKNzP7QT2JttT+cL8dKHaecqidp4OQO2MAqqdp4BJ+XQlT3DRGxHJ+RnhnSAVxycZuv5nhasdisuzDvDmyvFngTn+nPAcr61J8Yq7FLJJed5RtTMSdtaoGt/J9kIlI+AX4GpHqReAm+BF4WqHfPgiXO2oGry9Ii8bb0She75SdjF+yRG1g8zxlx1VOyNxb7IF9p1sr+QL86uFaucVi9p5NQC1MxKodl4BJuWrlTzBRW9EJOfXhHeCVBxfZuj6XxeudigurzvAmyvHXwfm+BvCc7y2JsUr7lLIJuVNR9XOCNzLGDV+buetSkbAb1Xi110kXKEQ70WVKx0MWpdFVVBBebNSdtF72xFVgczLxcyFHhGTxQw5HmRBHc5UUJdUMgJewlBQ3xFeUIn3OwEVVK+4S9HGeKeSZ8OheAe5yYZV4Hxg4n23khHwuwwn4rvAir5U+IYlHy5l2ARLhd+jpU26lEH+vA2M93vCbxdQ7rzHVOyrL/Tefg8Yn/eFS/zaFINX3KWQiuED4TlOMf6AoZFD5mGQTcI9RpOg/HAoFA8TJj/jqUgmHfJDoUwq4qW9ZDqUTURUIhcJRcLpTDql8SdVzssl04mc/89aJt4PKxkBf2jZBMWC/xC4+T8S3iSQDz+ybIJiffgRuFOmZ0h1SoLdBF6RlwUuyr81uvBlRvzg3RQwkMp8MGiCXkvM6TVJvmXrcDquzunLgJv5Y+AGMf1K6166jrmgH/SqtPJyXiLkJb14OhZPJTKhlJ/MhXPRcCa8rn5dXbIj/foJk18/MfxafaEfZK9FTqjV/PcafijWp58KV3zrmperuRQyL5eDfYhueqp9iMyZ5fjGokYN9oq8qLFoWGJvLErWMpdW448azzzQTQv6LKm+Pvu3xsIr7lLLmQr1Z+veWKzRob2c4ZZa3Q3/v0rl1R4mxPkzBt71wLyrr3prx99bm+JdLOfPgQ01MG8UMhbmfvy8iIZ0TZo9jv1YX0hero4HMi+/MNZSmXA4kkmk0ioaiiVTnp8JJ71cJB7WuiATjmcyYT8WS4bDmZif8xP6/NYKwfei8XjCi4XCiRAwl1R9prz8Ip+XFJMGJcHfYvOKvMym5cv8LbavXDmwufB9yVAMVjA1Kiv+pTB6xV3/8cVXDL74mskXXzMeEuSLFQy+aMjctK3uLtjqFAfx/pqBd+mGsusAFdnlDHcDgPFWSB/+r6jYFUwq9hsXVew3/6JiV7PMGqm5bxgKQ9n/QTX3baXMAlPG1DV/a7kNLlnVfGeqmnBY741MXOUyuXA0ngilVCwci+UiuXjMj2Ry0UgyE8+qSDIcSmTjXk752Ww8Gk7HY7lEJh3LmUW7WIXEFZ/vDFVT26Eg+fYjJ06uA+Z7Fw+Y75kPmO8ZDphypgOmPhgnsoD9AFwLebsQeViVMxXDH9bgsCrWpz8C42Pe6pJ0WHHF58f/oVtwP+Vvwf1MdQ8NurYH3MiXe4pdC/hgluWV2Wof1nXEh8Wu9YvweNCG+YWhSfiVqWH6lfF27c9MvviNyRe/Md6uJT/8yuCLJsJv1xLv3xh4Vzhwu/YXhtu1wHirivW3awsvha6z1dfvnGr6F6aC+DujmibMvzMUhkpHbtf+AmyK/qiUWWAqmRTWHwHcrkXG50/g7doKoALmis+flvis7UG4ujdmkfH5i6l+/gXww+reLEb64W8mP/zN3Fj/xXCONHWgsf6bgXczpvOz8AZFsW/MI28EAGOtmq1vqgsv9RdTU13S1MGm2gTN0VSb61evW2xRqPo/2FRv0FRmgaliatqI76UlNS/JTXWdprimuhmwqeaKT52mwb8DgbwbwomT64Cp6+IBU5f5gKnLcMA0d+QdCGQBq9dU5GMA6GHVnKkY1mvK/w5E/aa4Q6FiQ5mHFVd86jflU/wL849W0N9TsBD2hfu+QtaJBrBG1K8RI1q3+gtobihZ9QL59b/1GH1+xhvKx9iwKRgjx+2zBgwH+obCn88SbwoOuog0AB7qpUAFiowHc8FQXJvRhYJRiiwYrlb2mAOBKmuKx2gFWvTr5TigIVcTqrypfIyNXEmoxjigYVcTqrEDCdXElYSqwAGNuJpQFQ4kVKUrCdUUBzTqakI1dSChmq1vdj21vwPNbpUrO785Dmjc1YRq7sDOb+FKQm2IA+q7mlAbOpBQG7mSUBvjgCZcTaiNHUioTVxJqE1xQJOuJtSmDiTUZq4k1OY4oClXE2pzBxJqC1cSaksc0LSrCbWlAwm1lSsJtTUOaMbVhNragYRq6UpCbYMDmnU1obZxIKG2dSWhtsMBzbmaUNs5kFDbu5JQO8CAKs/VhNrBgYTa0ZWE2gmXUMrVhNrJgYTa2ZWE2gWXUM6+Z7SLAwm1qysJtRsuoZx9z2g3BxJqd1cSag9cQjn7ntEeDiTUnq4k1F64hHL2PaO9HEgoz5WEUriEirmaUMqBhAq5klBhXEI5+z5U2IGEiriSUFFcQjn7PlTUgYSKuZJQcVxCOfs+VNyBhPJdSagELqGcfR8q4UBC7e1KQu2DSyhn34fax4GE2teVhNoPl1DOvg+1nwMJtb8rCXUALqGcfR/qAAcS6kBXEuogXEI5+z7UQQ4k1MGuJNQhuIRy9n2oQxxIqEORGOkL+cpKVn7HEoHdJj+uAwZO3+eE+AK31X0vllfcpRoAHczhwwVgH5Yx+LBMuA/ng33YiMGHjYT78EGwD5sw+LCJcB/OA/uwksGHlcJ9OBfsw2YMPmwm3IcPgH1YxeDDKuE+vB/swxYMPmwh3IdzwD7ciMGHGwn34X1gH27C4MNNhPtwNtiHmzH4cDPhPpwF9uEWDD7cQrgPZ4J9uBWDD7cS7sMZYB+2ZPBhS+E+nA724bYMPtxWuA+ngX24PYMPtxfuw6lgH+7I4MMdhftwCtiHOzP4cGfhPpwM9uGuDD7cVbgPJ4F9uDuDD3cX7sOJYB/uyeDDPYX7cALYhx6DDz3hPhwP9mGIwYch4T4cB/ZhhMGHEeE+HAv2YYzBhzHhPhwD9qHP4ENfuA9Hg324N4MP9xbuw1FgH+7L4MN9hftwJNiH+zP4cH/hPhwB9uGBDD48ULgPh4N9eDCDDw8W7sNhYB8e2lT4y4kFF2bdcKzEcmHWDim+tVfmFMWsaX58mB4cru0IbUdqO0rb0dqO0XastuO0Ha/tBG0najtJ28naTtF2an6RVk3zi1b/1llatGXB3OGWuSMsc0da5o6yzB1tmTvGMnesZa5Vfq6kBP/LQRfkf3MxZD218jchV6+HemGzHpK3Qv4G45ovfxbLt3VTHMcNmX6TdmsjH6sv6AGgavqhWJ+2acrjhzaGH9AH4HyGfUQv2KLrB/ClXdUGGPO2TDFvG0DutwX6oR2TH9ox5v6DDLnfhCH3gS9bq3bAmLdninl77tzXfjhMqB9ojXpgrnPBvdc80L7J5uj6R4RVNsXuw2bofah5A1/YV82AfE9j2oenBXAGnQb0QwcmP3RgPIMeYDiDqhjOIOAPCagOwJh3ZIp5xwByvyPQD52Y/NCJMffvZ8j9Fgy5D/zhDtUJGPPOTDHvHED/dbhQP9Aa6P7rPnD/NYeh/9oI3H9twtB/AX9AqMYPyhTLtwvTPuwSwBnUBeiHJJMfkoxn0GyGM2gzhjMI+ENJKgmMeYop5qkAcj8F9EOayQ9pxtyfxZD7WzDkPvCHyVQaGPMMU8wzAfRfRwj1A62B7r9mgPuvmQz911bg/qslQ/8F/IHEGj+YVyzfLNM+zAZwBmWBfsgx+SHHeAZNZziDtmU4g4A/BKlywJh3ZYp51wByvyvQD92Y/NCNMfenMeT+9gy5D/zhVdUNGPPuTDHvHkD/daRQP9Aa6P5rCrj/msrQf+0I7r92Zui/gD8AXeMHgYvl24NpH/YI4AzqAfTD6Ux+OJ3xDJrMcAbtynAGAX/oWp0OjHlPppj3DCD3ewL90IvJD70Yc38SQ+7vzpD7wB+WV72AMe/NFPPeAfRfRwn1A62B7r8mgPuviQz9157g/stj6L+AX7hQ44sHiuV7BtM+PCOAM+gMoB/6MPmhD+MZNJ7hDAoxnEHAL3lQfYAx78sU874B5H5foB/6MfmhH2Puj2PI/QhD7gO/nEP1A8b8TKaYnxlA/3W0UD/QGuj+awy4/xrL0H/FwP2Xz9B/Ab/gpcYXnRTL9yymfXhWAGfQWUA/nM3kh7MZz6DRDGfQ3gxnEPBLZdTZwJifwxTzcwLI/XOAfjiXyQ/nMub+KIbc35ch94FfBqTOBcb8PKaYnxdA/3WMUD/QGuj+awS4/xrJ0H/tD+6/DmTov4BfKFXji5WK5Xs+0z48P4Az6HygHy5g8sMFjGfQcIYz6GCGMwj4JVbqAmDML2SK+YUB5P6FQD9cxOSHixhzfxhD7h/KkPvALx9TFwFjfjFTzC8OoP86VqgfTM4bgDkfB+CcSv6zFifO4x3x5wmO4DzREZwnOYLzZEdwnuIIzlOBOEm7lpfU/MXfTUtqXmj8hzH4GY3xcAcwHuEAxiMdwHiUAxiPdgDjMQ5gPJapxiMwhmM+y7pceNev+7+1Lm7tUIhxbVVdE8xepb8eXKLtUm2Xabtc2xXartR2lbartV2jbYC2a7Vdp+16bTdou7FpSc0vlu7fdNUvm77EMnepZe4yy9zllrkrLHNXWuausszdYJm7MT9HDV2zkpU3AMwLXUyvbio+GRX9P9MXN+Uz5ubCoNN/KOx80XemrgbcUaCnMLTWTcA7Mjc7onxcwXmNIzgHOILzWkdwXucIzusdwYmol6nEf7rqGndgC++OF1s/gXc0VH+m2KA5A++QqEsc4Qy846IudYQz8A6OuswRzsA7QupyRzgD7zCpKxzhDLxjpa50hDPwDpi6KiDO3rpdqnpwA1Ar3cL0FN9cF+yH6kvdCIz9LSAtm8vmEibnDcD5PhDA2XZnFo3zNgDOWNJLZGOxOCfO2wE4U6lYPJn1o5w4ByHino5lc+F4iBPnYADOZDSSy0XDSU6cdwBwRpWXjYbiOU6cQwA4EykvGvP9NCfOOwE4Vc4PZxLJFCfOuxBxT2W9dEYlCFvzklV/u6T5WyXN3yZp/hZJ87dHmr810vxtkeZviRxojOMN131s3my/0RjfZoxvN8aDjPFgY3yHMR5ijO80xnflx3frP4dqu0fbvdqGaRuubYS2kU3/uclPfqxbsuqFvgdzt/yb/HRF2NZW//Rp1b6t/mmPUdovo7WN0Ta28GEC/cfSgrnRlrkxlrmx+Tnzqo91Vo2gFlsgRqEawZynRgMfkIyBrPWPv8YCN0GQm3fo+s1r3bzjtF/Ga5ugbWLh5h1n2ZTjLXMTLHMTA9i8Q4Gbdxxw844Hbt4JwM070dHNe8/6zWvdvJO0XyZrm6JtauHmnWTZlJMtc1Msc1MD2Lz3ADfvJODmnQzcvFOAm3eqo5v33vWb17p5p2m/TNc2Q9vMws07zbIpp1vmZljmZgawee8Fbt5pwM07Hbh5ZwA370xHN++w9ZvXunlnab/M1naftjmFm3eWZVPOtszdZ5mbE8DmHQbcvLOAm3c2cPPeB9y8cxzdvMPXb17r5r1f++UBbXO1zSvcvPdbNuUDlrm5lrl5AWze4cDNez9w8z4A3LxzgZt3nqObd8T6zWvdvA9qv8zXtkDbwsLN+6BlU863zC2wzC0MYPOOAG7eB4Gbdz5w8y4Abt6Fjm7ekes3r3XzPqT98rC2R7Q9Wrh5H7Jsyoctc49Y5h4NYPOOBG7eh4Cb92Hg5n0EuHkfBW6C6mS6tAScqPoqXb/e+vXWr7d+vfXrrV9v/Xrr11u/nuT1VHXv37vhSh3Qyxj3NManG+Mexri7Me5mjLsa45wxzhrjjDFOG+OUMU4a4y7GuLMx7mSMOxrjDsb4NGPc3hi3M8ZtjXEbY9zaGLcyxqca41OM8cnG+CRjfKIxPsEYzyhdOZ5ujKcZ46nGeIoxnmyMJxnjicZ4gjEeb4zHGeOxxniMMR5tjEcZ45HGeIQxHm6Mhxnje43xPcZ4qDG+2xjfZYzvNMZDjPEdxniwMR5kjG83xrcZ44HG+IeylePvjfF3xvhbY/yNMf7aGK8wxl8Z4y+N8RfG+HNj/JkxXm6MPzXGnxjjj43xMmP8kTH+0Bh/YIzfN8bvGeOlxvhdY/yOMV5ijBcb47eN8SJj/JYxftMYv2GM5xj3IcxHeeajPvNR4DxjbD49MJ8umE8fFhpj84aleUPTvOH5qDE275GY91DMeyxjjbH5+q35eq75+u5EY2y+8We+EWi+MTjVGJsvGZkvIZkvKc00xuZ7DeZ7D9XvRdxS8s/1mP78uLYntD2p7SltT2t7Rtuz2p7T9ry2F7S9qO0lbS9re0Xbq9pe0/a6tje0vantLW2LtL2tbbG2Jdre0fautqXa3tP2vrYPtH2o7SNty7R9rO0TbZ9qW67tM22fa/tC25favtK2QtvX2r7R9q2277R9r+0HbT9q+0nbz9p+0fartt+0/a7tD21/avtL299006yZ9oW2Otrqaqunrb62BtoaaivVVqatXFsjbY21NdFWoa1SW1NtzbRVaWuurYW2DbVtpG1jbZto21TbZto217aFti21baVta20ttW2jbVtt22nbXtsO2nbUtpO2nbXtom1Xbbtp213bHtr21LaXNk+b0hbSFtYW0RbVFtMW1+ZrS2jbW9s+2vbVtp+2/bUdoO1AbQdpO1jbIdoO1XaYtsO1HaHtSG1HaTta2zHajtV2nLbjtZ2g7URtJ2k7uVmwPz8wtMKFm8IhvrULbgq3zI9P0XE4VVsrba21tdHWVls7be21naatg7aO2jpp66yti7aktpS2tLaMtqy2nLau2rpp666th7bTtfXU1ktbb21naOujra+2fs3yYKpvJBOY0oK5Uy1zrSxzrS1zbSxzbS1z7Sxz7S1zp1nmOljmOlrmOlnmOlvmuljmkpa5lGUubZnLWOaylrmcZa6rZa6bZa67Za6HZe50y1xPy1wvy1xvy9wZlrk+lrm+lrl++Tnz2ib/54H5P73irhpFp9iHFrQ3il2r+qHFqaC1iGMryFr/+Kt18WuF8v5SbYpdK/Jf36u2xa3lGXFU7YpZK1QjJ1T7dV/LK8gvddo6rhXLrZKrqsO6reVb8l51XJe1fOseUp3Wfq14LftRdV7bteK17m3VZe3WCv1LnVDJtVkr/q81R6XWfK30auqXSq/pWvHV1kKVWbO1vDWoqyq7Jmt5a1SjVW71a0XXsN6rrqtbK7LGZ4fq9q9rRXJrcQ6p7v+2VnytzjTVo/a1/LU8H9XptayVyK31Wat62tfy1uHcVr1sa3nr1AOo3quupdaxn1BnFK6VWefeRPWpuVa4iD5H9TXWCuWK6plUv2Y40Ud9450lK4VTv7yI6ZMXNb3zIqdnXvT0yIugbnlRlMuLpExeNKXyIqpLXlR1yousDnnR1T4vwtrmRVnrvEij3o16QbpIQFeVrBTL5oUW0P1g/WdGmXjPbMYImBavU7BuseDPxCWVOgvg1GqBwOVDwrgB2IdnATdmkF81jSsoGdY7PaYvzs5vsHMK77acnQ+sOXeORRWjv34aV0k8dTZwA50DDi46+WjTnA3cjP/9BeTgzRjUidQXlkeJjIn33GaMgM+Fn0iJzLnAE+k84ScS+fA8+ImUyJzn6InUF4Y7kbbAZTmRzs9vsAsKT6TzLSfSBQGcSH2BJ9L5wA10AVNwUQXov79KGsj5QmAxKynBn5Zn5QtQHXAOIqXARcBiZvOhV9ylKMYXMXQyFznayfSB1Z9U2MR7cTNGwBfDO5lU+GLg5u8vvJMhH/aHdzKpcH/mzY8ooBcJL6CXgH1YfaEPXmSOXwrce0F2wH1guFN8vy+uoAO+LF+YLy/sgC+zdMCXB9AB404gT10GTMrLmYKL3ohIzlcwd8BecZei4ngpQ/d2pfCuleJypQO8uXL8SmCOXyU8x2trUhDND2qtq8EHdlBq5wzYWePnTLzXNGMEfA1c7fi5a4ABHCBc7ZAPB8DVjp8bIFztUKG7upnsYnwtuBhXX2jOyBy/zlG1cwYMt5+1wGVRO9fnC/MNhWrneovauSEAtYM7gTx1PTApb2AKLnojIjnfKLwTpOJ4HUPXf5NwtUNxuckB3lw5fhMwx28WnuO1NSlecZdCNim3OPpspzfsrAl5Jt5bmzECvhWudkLercBNMFC42iEfDoSrnZA3ULjaoUJ3SzPZxfg2R9QOMsdvd1Tt9IbhVjkLXBa1MyhfmAcXqp1BFrUzOAC1gzuBPDUImJSDmYKL3ohIzncI7wSpON7O0PUPEa52KC5DHODNleNDgDl+p/Acr61J8Yq7FLJJuctRtdMLdtZkaqidu5sxAr4brnYy3t3ATTBUuNohHw6Fq52MN1S42qFCd1cz2cX4HkfUDjLH73VU7fSC4U4HpnaG5Qvz8EK1M8yidoYHoHZwJ5CnhgGTcjhTcNEbEcl5hPBOkIrjvQxd/0jhaofiMtIB3lw5PhKY46OE53htTYpX3KWQTcpoR9VOT9hZE6vxnRhjmjECHgNXOzE1BrgJxgpXO+TDsXC1E6vB2yvysvFGFLrRzWQX43GOqB1kjo93VO30hOGOBfZdKhPyhXliodqZYFE7EwNQO7gTyFMTgEk5kSm46I2I5DxJeCdIxXE8Q9c/WbjaobhMdoA3V45PBub4FOE5XluT4hV3KWSTMtVRtXM67tmOb+Kd1owR8DT8sx1/GnATTBeudsiH0/HPdvzpwtUOFbqpzWQX4xmOqB1kjs90VO2cDsOdiVvgsqidWfnCPLtQ7cyyqJ3ZAagd3AnkqVnApJzNFFz0RkRyvk94J0jFcSZD1z9HuNqhuMxxgDdXjs8B5vj9wnO8tibFK+5SyCblAUfVTg/YWRNJmHjnNmMEPBeudiKJucBNME+42iEfzoOrnUhinnC1Q4XugWayi/GDjqgdZI7Pd1Tt9IDhjvgWuCxqZ0G+MC8sVDsLLGpnYQBqB3cCeWoBMCkXMgUXvRGRnB8S3glScZzP0PU/LFztUFwedoA3V44/DMzxR4TneG1NilfcpZBNyqOOqp3usLMmVeNNtseaMQJ+DK52Uuox4CZ4XLjaIR8+Dlc7qRq8vSIvG29EoXu0mexi/IQjageZ4086qna6w3CnAnuT7al8YX66UO08ZVE7TwegdnAnkKeeAibl00zBRW9EJOdnhHeCVByfZOj6nxWudiguzzrAmyvHnwXm+HPCc7y2JsUr7lLIJuV5R9VON5zaSZt4X2jGCPgFvNpJvwDcBC8KVzvkwxfxaif9onC1Q4Xu+Wayi/FLjqgdZI6/7Kja6YZriFMWuCxq55V8YX61UO28YlE7rwagdnAnkKdeASblq0zBRW9EJOfXhHeCVBxfZuj6XxeudigurzvAmyvHXwfm+BvCc7y2JsUr7lLIJuVNR9VOV9ybbCkT71vNGAG/hX+TLfUWcBMsEq52yIeL8G+ypRYJVztU6N5sJrsYv+2I2kHm+GJH1U5X3MtOSQtcFrWzJF+Y3ylUO0ssauedANQO7gTy1BJgUr7DFFz0RkRyfld4J0jFcTFD179UuNqhuCx1gDdXji8F5vh7wnO8tibFK+5SyCblfUfVTg521vg1voH6g2aMgD+Aqx3f+wC4CT4UrnbIhx/C1Y7vfShc7VChe7+Z7GL8kSNqB5njyxxVOzkY7nhg30D9cb4wf1Kodj62qJ1PAlA7uBPIUx8Dk/ITpuCiNyKS86fCO0EqjssYuv7lwtUOxWW5A7y5cnw5MMc/E57jtTUpXnGXQjYpnzuqdrJMaueLZoyAv2BQO18AN8GXwtUO+fBLBrXzpXC1Q4Xu82ayi/FXjqgdZI6vcFTtZB1UO1/nC/M3hWrna4va+SYAtYM7gTz1NTApv3FE7SA5fyu8E6TiuIKh6/9OuNqhuHznAG+uHP8OmOPfC8/x2poUr7hLIZuUHxxVOxnYWZOs8Z1sPzZjBPwjXO0kEz8CN8FPwtUO+fAnuNpJJn4Srnao0P3QTHYx/tkRtYPM8V8cVTsZGO5kYN/J9mu+MP9WqHZ+taid3wJQO7gTyFO/ApPyN6bgojcikvPvwjtBKo6/MHT9fwhXOxSXPxzgzZXjfwBz/E/hOV5bk+IVdylkk/KXo2onjVM7ERPv380YAf+NVzuRv5GboEq22iEfEkaw2omYvL0iLxtvRKH7q5nsYrxBFbYYV19ozsgcrwPkHKTaSeMa4rAFLovaqVv1z5/1qk+YamVTt2pVtUN/iVvt4E4gT9UFJmW9Kp7gojciknN9cPFBbzgqjnWq8AdDA+aDyyvuUhSXBg7w5srxBsAcbyg8x2trUrziLoVsUkqBeROk2knBzppMjWc7ZVWMgGlxrNrJJMqAm6BcuNohH5bD1U4mUS5c7VChK62SXYwbOaJ2kDne2FG1k4KpnUxgz3aa5AtzRaHaaWJROxUBqJ0UUO00ASZlRRVPcNEbEcm5UngnSMWxMUPX31S42qG4NHWAN1eONwXmeDPhOV5bk+IVdylkk1LlqNpJws6adNbE27yKEXBzuNpJZ5sDN0EL4WqHfNgCrnbS2RbC1Q4Vuqoq2cV4Q0fUDjLHN3JU7SRhaiedscBlUTsb5wvzJoVqZ2OL2tkkALWTBKqdjYFJuUkVT3DRGxHJeVPhnSAVx40Yuv7NhKsdistmDvDmyvHNgDm+ufAcr61J8Yq7FLJJ2cJRtdMFdtaoGs92tqxiBLwlXO2oxJbATbCVcLVDPtwKrnZUYivhaocK3RZVsovx1o6oHWSOt3RU7XSBqR0V2LOdbfKFedtCtbONRe1sG4Da6QJUO9sAk3LbKp7gojcikvN2wjtBKo4tGbr+7YWrHYrL9g7w5srx7YE5voPwHK+tSfGKuxSySdnRUbXTGXbWpGqonZ2qGAHvBFc7qcROwE2ws3C1Qz7cGa52UomdhasdKnQ7Vskuxrs4onaQOb6ro2qnM0ztpAJTO7vlC/PuhWpnN4va2T0AtdMZqHZ2Aybl7lU8wUVvRCTnPYR3glQcd2Xo+vcUrnYoLns6wJsrx/cE5vhewnO8tibFK+5SyCbFc1TtdIKdNb5v4lVVjIAVXO34vgJugpBwtUM+DMHVju+HhKsdKnRelexiHHZE7SBzPOKo2ukEUzt+3AKXRe1E84U5Vqh2oha1EwtA7XQCqp0oMCljVTzBRW9EJOe48E6QimOEoev3hasdiovvAG+uHPeBOZ4QnuO1NSlecZdCNil7O6p2OsLOmkgNtbNPFSPgfeBqJ+LvA9wE+wpXO+TDfeFqJ+LvK1ztUKHbu0p2Md7PEbWDzPH9HVU7HWFqJxKY2jkgX5gPLFQ7B1jUzoEBqJ2OQLVzADApD6ziCS56IyI5HyS8E6TiuD9D13+wcLVDcTnYAd5cOX4wMMcPEZ7jtTUpXnGXQjYphzqqdjrAzpqEMvEeVsUI+DC42kmow4Cb4HDhaod8eDhc7SRq8PaKvGy8EYXu0CrZxfgIR9QOMsePdFTtdICpnYRngcuido7KF+ajC9XOURa1c3QAaqcDUO0cBUzKo6t4goveiEjOxwjvBKk4HsnQ9R8rXO1QXI51gDdXjh8LzPHjhOd4bU2KV9ylkE3K8Y6qndNgZ03cM/GeUMUI+AS42ol7JwA3wYnC1Q758ES42ol7JwpXO1Tojq+SXYxPckTtIHP8ZEfVzmkwtRPLWeCyqJ1T8oX51EK1c4pF7ZwagNo5Dah2TgEm5alVPMFFb0Qk51bCO0EqjiczdP2thasdiktrB3hz5XhrYI63EZ7jtTUpXnGXQjYpbR1VO+1x31JQ4xuo21UxAm4HVzupbDvgJmgvXO2QD9vD1U4q21642qFC17ZKdjE+zRG1g8zxDo6qnfa4bykI7BuoO+YLc6dCtdPRonY6BaB22gPVTkdgUnaq4gkueiMiOXcW3glScezA0PV3Ea52KC5dHODNleNdgDmeFJ7jtTUpXnGXQjYpKUfVTjvYWROq8WwnXcUIOA1XOyEvDdwEGeFqh3yYgaudkJcRrnao0KWqZBfjrCNqB5njOUfVTjvcN1AH9myna74wdytUO10taqdbAGqnHVDtdAUmZbcqnuCiNyKSc3fhnSAVxxxD199DuNqhuPRwgDdXjvcA5vjpwnO8tibFK+5SyCalp6Nqpy3urEmbeHtVMQLuBVc7XroXcBP0Fq52yIe94WrHS/cWrnao0PWskl2Mz3BE7SBzvI+jaqctTO14KQtcFrXTN1+Y+xWqnb4WtdMvALUDPIFUX2BS9qviCS56IyI5nym8E6Ti2Ieh6z9LuNqhuJzlAG+uHD8LmONnC8/x2poUr7hLIZuUcxxVO21gZ02sxpts51YxAj4XrnZi2XOBm+A84WqHfHgeXO3EsucJVztU6M6pkl2Mz3dE7SBz/AJH1U4b3M/tBPYm24X5wnxRodq50KJ2LgpA7bQBqp0LgUl5URVPcNEbEcn5YuGdIBXHCxi6/v7C1Q7Fpb8DvLlyvD8wxy8RnuO1NSlecZdCNimXOqp2WsPOGlXjO9kuq2IEfBlc7Sh1GXATXC5c7ZAPL4erHVWDt1fkZeONKHSXVskuxlc4onaQOX6lo2qnNe5NtsC+k+2qfGG+ulDtXGVRO1cHoHZaA9XOVcCkvLqKJ7jojYjkfI3wTpCK45UMXf8A4WqH4jLAAd5cOT4AmOPXCs/x2poUr7hLIZuU6xxVO61wL2PU+Lmd66sYAV9fhV/3BuEKhXjfULXSwaB1WVQFFZTrqmQXvRsdURXIvLyJudAjYnITQ44HWVBPZSqoN1cxAr6ZoaDeIrygEu9bAiqoXnGXoo1xSxXPhkPxDnKTndIM5wMT761VjIBvZTgRbwVW9IHCNyz5cCDDJhgo/B4tbdKBDPLnRmC8bxN+u4By5zamYl99off2bcD43C5c4temGLziLoVUDIOE5zjFeBBDI3cb87lQ7Jq/VJaU9Gu26m344m6d+4rWRfmwH7BhGQzLQ98zH20Mzj/aoD14Z8mqF8gX/62Z6DyNN5SP8Q707WWOzTSYQ2lsKLt4Em8KDvpZ3mBg8RwCPMSR8WAuGIprM7pQMIYgC4arlT3mQKDuXB8oT5U3lY/xrvWB8lRjBwJ19/pAearCgUANXR8oTzV1IFD3rA+Up/Z3oJm4d32gPNXcgR01bH2gPLWhA4Eavj5QntrYgUCNWB8oT23qQKBGrg+UpzZ3IFCj1gfKU1s6EKjR6wPlqa0dCNSY9YHy1DYOBGrs+kB5ajsHAjVufaA8tYMDgRq/PlCe2smBQE1YHyhP7eJAoCauD5SndnMgUJPWB8pTezgQqMnrA+WpvRwI1JT1gfKUciBQU9cHylNhBwI1bX2gPBV1IFDT1wfKU3EHAjVjfaA8lXAgUDPXB8pT+zgQqFnrA+Wp/RwI1Oz1gfLUAQ4E6r71gfLUQQ4Eas76QHnqEAcCdT8yUPTNGGUlK3+2jMBukx/XAQOv/mHY6vW4fh7QK+5Sg4EO5vBhX7AP72Tw4Z3CfdgH7MO7GHx4l3AfngH24d0MPrxbuA97g304lMGHQ4X7sBfYh/cw+PAe4T7sCfbhvQw+vFe4D08H+3AYgw+HCfdhD7APhzP4cLhwH3YH+3AEgw9HCPdhN7APRzL4cKRwH3YF+3AUgw9HCfdhDuzD0Qw+HC3ch1mwD8cw+HCMcB9mwD4cy+DDscJ9mAb7cByDD8cJ92EK7MPxDD4cL9yHSbAPJzD4cIJwH3YB+3Aigw8nCvdhZ7APJzH4cJJwH3YC+3Aygw8nC/dhR7APpzD4cIpwH3YA+3Aqgw+nCvfhaWAfTmPw4TThPmwP9uF0Bh9OF+7DdmAfzmDw4QzhPmwL9uFMBh/OFO7DNmAfzmLw4SzhPmwN9uFsBh/OFu7DVmAf3sfgw/uE+/BUsA/nMPhwjnAfngL24f1Vwl9OLLgw64ZjJZYLs3ZI8a29MqcoZk3z4we0v+dqm6ftQW3ztS3QtlDbQ9oe1vaItke1PabtcW1PaHtS21NV/6zxdFV+0erftkGLtiyYm2uZm2eZe9AyN98yt8Ayt9Ay95Bl7un8XEkJ/pciFL5g6RVzqZW/AaZ6PdQLm/WQvBXyN7fUfPmzWL7PVOE4In+xhJmPzxj5WH1BDwBV0w/F+vTZKh4/PGv4geMA5HhpF10/gC/tqmeBMX+OKebPBZD7zwH98DyTH55nzn2Ol63RuQ982Vo9D4z5C0wxf4E797UfHhDqB1qjHphr4cvcXjFXvvdCvGD/z2/d+wff0CrsPrwHvQ81b+AL+zVeXC+W74tM+/DFAM6gF4F+eInJDy8xn0EcPySAPoOAPySgXgLG/GWmmL8cQO6/DPTDK0x+eIU59zl+uAOd+8Af7lCvAGP+KlPMXw2g/5or1A+0Bkf/1R3cf/UA91/Dwf3XCIb+C/gDQjV+UKZYvq8x7cPXAjiDXgP64XUmP7zOfAZx/FAS+gwC/lCSeh0Y8zeYYv5GALn/BtAPbzL54U3m3Of4YTJ07gN/mEy9CYz5W0wxfyuA/mueUD/QGhz9Vxbcf+XA/ddocP81hqH/Av5AYo0fzCuW7yKmfbgogDNoEdAPbzP54W3mM4jjhyDRZxDwhyDV28CYL2aK+eIAcn8x0A9LmPywhDn3OX54FZ37wB9eVUuAMX+HKebvBNB/PSjUD7QGR/+VBPdfKXD/NR7cf01g6L+APwBd4weBi+X7LtM+fDeAM+hdoB+WMvlhKfMZxPFD1+gzCPhD12opMObvMcX8vQBy/z2gH95n8sP7zLnP8cPy6NwH/rC8eh8Y8w+YYv5BAP3XfKF+oDU4+q+O4P6rE7j/mgzuv6Yw9F/AL1yo8cUDxfL9kGkffhjAGfQh0A8fMfnhI+YziONLHtBnEPBLHtRHwJgvY4r5sgByfxnQDx8z+eFj5tzn+HIOdO4Dv5xDfQyM+SdMMf8kgP5rgVA/0Boc/Vc7cP/VHtx/TQf3XzMY+i/gF7zU+KKTYvl+yrQPPw3gDPoU6IflTH5YznwGcXypDPoMAn6pjFoOjPlnTDH/LIDc/wzoh8+Z/PA5c+5zfBkQOveBXwakPgfG/AummH8RQP+1UKgfaA2O/qsVuP9qDe6/ZoP7r/sY+i/gF0rV+GKlYvl+ybQPvwzgDPoS6IevmPzwFfMZxPElVugzCPglVuorYMxXMMV8RQC5vwLoh6+Z/PA1c+5zfPkYOveBXz6mvgbG/BummH8TQP/1kFA/mJw3AHN+GMA5lfxnLU6cjzjiz0cdwfmYIzgfdwTnE47gfNIRnE8BcZJ2LS+p+Yu/m5bUvND4H2DwMxrjXAcwznMA44MOYJzvAMYFDmBc6ADGh5hqPAJjOOazrMuFd/26/1vr4tYOhRjXVtU1wexVvtX7+jtt32v7QduP2n7S9rO2X7T9qu03bb9r+0Pbn9r+0va3tpLmJTW/WPrbqlW/bPo7y9z3lrkfLHM/WuZ+ssz9bJn7xTL3t2WOSNAcNXT6Hs1/bwCYF7qY/lolPhkV/T/TFxs0/+fPOoVBp/9Q2Pmi70z9CrijQE9haC3CW+xa1Xdk6jR3Q/m4gvM3R5Tk747g/MMRnH86gvMvR3Ai6mUq8Z+uusYd2MK748XWT+AdDfUtU2zQnIF3SNR3jnAG3nFR3zvCGXgHR/3gCGfgHSH1oyOcgXeY1E+OcAbesVI/O8IZeAdM/RIQZ2/dLlU9+Bv49LouUIOY+tNcF+yH6kuV4LCrugD9+Z83CrO5BPGv1uPmbx0zf9uY+VvGzN8uZv5WMfO3iZm/Rcz87WEDm64cxxuu+9i8CVN984XGtxnr326MBxnjwcb4DmM8xBjfaYzvyo/r63+ngbaG2kq1lWkr19ZIW+Pm/9z8aV6y8r6FeaF78/pMWrwEizPCtrb6Z/9W+7b6LeAm2i8V2irpflLhTSb6j6UFcxWWuUrLXNP8nHnVxzqrRlCLLZRNUAUi56kK0FrEsRKy1j/+agrcBEFu3gbrN6918zbTfqnS1lxbi8LN28yyKassc80tcy0C2LwNgJu3GXDzVgE3b3Pg5m3h6OZtuH7zWjfvhtovG2nbWNsmhZt3Q8um3Mgyt7FlbpMANm9D4ObdELh5NwJu3o2Bm3cTRzdv6frNa928m2q/bKZtc21bFG7eTS2bcjPL3OaWuS0C2LylwM27KXDzbgbcvJsDN+8Wjm7esvWb17p5t9R+2Urb1nQfpHDzbmnZlFtZ5ra2zLUMYPOWATfvlsDNuxVw824N3LwtHd285es3r3XzbqP9sq227bRtX7h5t7Fsym0tc9tZ5rYPYPOWAzfvNsDNuy1w824H3LzbO7p5G63fvNbNu4P2y47adtK2c+Hm3cGyKXe0zO1kmds5gM3bCLh5dwBu3h2Bm3cn4Obd2dHN23j95rVu3l20X3bVtpu23Qs37y6WTbmrZW43y9zuAWzexsDNuwtw8+4K3Ly7ATfv7sBNUJ1MddCJqq9S6HoJrzo3Wxp5ako9UwqaUnF7Y2x2l2b3aXanOxtj80AzDzzzQNzdGJt7yNxj5h5saozNx7Pm41vz8W4LY2w+ETKfGJlPlDYxxuZNaPMmtXkTewtjbN73Mu+LVd83q/65hj305z217aXN06a0hbSFtUW0RbXFtMW1+doS2vbWto+2fZv/U7gaGTlnFrVN8+P99N/bX9sBlO/aDtJ2sLZDtB2q7TBth2s7QtuR2o7SdrS2Y7Qdq+04bcdrO0HbidpO0naytlO0naqtVWGh3M9SAPe3zB1gmTvQMneQZe5gy9whlrlDLXOHWeYOt8wdYZk70jJ3lGXuaMvcMZa5Yy1zx1nmjrfMnWCZO9Eyd5Jl7mTL3CmWuVMtc63yc5R8jUvsybd1ftxa/9022tpqa6etvbbTtHXQ1lFbJ22dtXXRltSW0pbWltGW1ZbT1lVbN23dtfXQdrq2ntp6aeut7QxtfbT11dZP25nazipMytYWIm0sc20tc+0sc+0tc6dZ5jpY5jpa5jpZ5jpb5rpY5pKWuZRlLm2Zy1jmspa5nGWuq2Wum2Wuu2Wuh2XudMtcT8tcL8tcb8vcGZa5Ppa5vpa5fpa5My1zZ63FZjhb/91ztJ2r7Txt52u7QNuF2i7SdrG2/tou0Xaptsu0Xa7tCm1XartK29XartE2QNu12q7Tdr22G7TdqO0mbTdru0XbrdoGarutcDOcbSFyjmXuXMvceZa58y1zF1jmLrTMXWSZu9gy198yd4ll7lLL3GWWucstc1dY5q60zF1lmbvaMneNZW6AZe5ay9x1lrnrLXM3WOZutMzdZJm72TJ3i2XuVsvcQMvcbWuxGW7Xf3eQtsHa7tA2RNud2u7Sdre2odru0XavtmHahmsboW2ktlHaRmsbo22stnHaxmuboG2itknaJmubom2qtmnapmuboW1m4Wa43UJkkGXu/7F3HXBSFUn/zQZgd1mYJSuoIKCIadLuzN55J5455xxnd2YQQUABlSCOmBUVFVFEjJeDl+N33+Ucvss555y9nL5umZ6p+W+9njc79ZZp3f5R7JsO/66u7q6uDq/fNsbvIcbvYcZvO+P3COO3g/F7lPHbyfg9xvg9zvg9wfg9yfg9xfg9zfi9nPF7BeP3SsbvVYzfqxm/1zB+r2X8Xsf4vZ7xewPj9wzj90bG702M35sZv7fU0RnequK+TdHbFb1D0TsVvUvRuxW9R9H/KHqvov9V9D5F71f0AUUfVPQhRR9W9BFFH1X0MUUfV/QJRZ9U9ClFn1b0GUWfVfR/ij6n6POKvoCd4a1MQd7G+L2d8XsH4/dOxu9djN+7Gb/3MH7/w/i9l/H7X8bvfYzf+xm/DzB+H2T8PsT4fZjx+wjj91HG72OM38cZv08wfp9k/D7F+H2a8fsM4/dZxu//GL/PMX6fZ/y+UEdn+KKK+yVFX1b0FUVfVfQ1RV9X9A1F31T0LUXfVvQdRd9V9D1F31f0A0U/VPQjRT9W9BNFP1X0M0U/V/QLRb9U9CtFv1b0G0W/VfQ7Rb/HzvBFpiBfYvy+zPh9hfH7KuP3Ncbv64zfNxi/bzJ+32L8vs34fYfx+y7j9z3G7/uM3w8Yvx8yfj9i/H7M+P2E8fsp4/czxu/njN8vGL9fMn6/Yvx+zfj9hvH7LeP3O8bv93V0hj+ouH9U9CdFzyr6s6K/KPqror8p+ruifyj6p6J/Kfq3ov8o+q9uzFMUlqIWRa2K2hS1KxqjaKyicYo6FHUq6lI0XlG3ogmKJk4Bpv/AFOSPjN+fGL9nGb8/M35/Yfz+yvj9jfH7O+P3D8bvn4zfvxi/fzN+/2H8/sv4acGjX4Txa2H8Whm/NsavnfEbw/iNZfzGMX4djF8n49fF+I1n/LoZvwmM38QpwTtDVMXtUTRJ0WRFUxRNVTRN0XRFMxTtoWhPRTMVzVK0l6K9Fe2jaLaiOYr2VTRX0TxF8xXtp2h/RQsUHaBooaIDFR2k6GBFh2BniDIF6WH8JjF+kxm/KYzfVMZvGuM3nfGbwfjtwfjtyfjNZPxmMX57MX57M377MH6zGb85jN++jN9cxm8e4zef8duP8duf8VvA+B3A+C1k/A5k/A5i/A5m/A6pozMcquLGFMUVJRQlFaUU9SrqU5RWlFHUr+hFil6s6DBFL1H0UkWHK1qk6AhFL1N0pKKjFB2t6BhFxyo6TtHxik5QdKKikxSdjJ3hUKYgMcYvzvglGL8k45di/HoZvz7GL834ZRi/fsbvRYzfixm/wxi/lzB+L2X8Dmf8FjF+RzB+L2P8jmT8jmL8jmb8jmH8jmX8jmP8jmf8TmD8TmT8TmL8Tq6jM5yi4p6q6DRFpys6Q9GZis5SdLaicxSdq+g8RecrukDRhYouUnSxoksUXaroMkVZRQOKBhXlFOUVFRQtVnS5oiWKrlC0VNEy7AynMAU5lfE7jfE7nfE7g/E7k/E7i/E7m/E7h/E7l/E7j/E7n/G7gPG7kPG7iPG7mPG7hPG7lPG7jPHLMn4DjN8g45dj/PKMX4HxW8z4Xc74LWH8rmD8ljJ+y+roDFequMsVrVC0UtFViq5WtErRakVrFF2j6FpF1ylaq2idovWKNii6XtFGRTcoKiq6UdEmRTcpulnRLYpuVXSbotsV3aHoTkV3YWe4kinIcsZvBeO3kvG7ivG7mvFbxfitZvzWMH7XMH7XMn7XMX5rGb91jN96xm8D43c947eR8buB8SsyfjcyfpsYv5sYv5sZv1sYv1sZv9sYv9sZvzsYvzsZv7tIZ+j2RuZuTUGsUK9ok+QzQvjcPKUk8AmjAh8RPstO+tKZU8bKHRS8e4ocX7SHa9zZnr2BNcr7PcPnvRc9NG/65uI2wutHVGH+Q/g2zxHyrHn4D0l3r/q9RdF9iu6fUvE3rlW4LRwoiHXvFLm6eWBKOJ1KWn7fF8TaIii/rVNkRwFs2w9MqbThreT5PvJ8P7TtB9XvbYoeUvRwqW1rmkjqhXOLZMqRinhD+5MLg4E0jxEHeDzQAR6/73lOGCgPhqFLdUfSp5jbvaFOugALvXAE7QnxmU+nenv7B/udq8QQ+LzbET5b5bCqPmewfcquv4/gWsh2xqKVtuy3C1oQO0Ky7HcEsOxjjbn4IyE1QqyvRmUsWeYfeG6UWdD6iP/QkTK3CJb5R46UWVDBxn88QmWONebiPxGU3zXtbgykP/Xc4PNnjvD5c0f4/IUjfP7SET5/5Qifv3aEz984wudvHeHzd47w+XtH+PyDI3z+0RE+/+QIn886wuefHeHzL47w+VdH+PybI3z+3RE+/+EIn/90hM9/OcLnvx3h8z+O8PlfR/jUgC7wGXGEzxZH+Gx1hM82R/hsd4TPMY7wOdYRPsc5wmeHI3x2hsRnM+8Ldo1QmWONufj4iJz81jmyX9TtSL+Z4AifEx3hM+oInz2O8DnJET4nO8LnFEf4nOoIn9Mc4XO6I3zOcITPPRzhc09H+JzpCJ+zHOFzL0f43NsRPvdxhM/ZjvA5xxE+93WEz7mO8DnPET7nO8Lnfo7wub8jfC5whM8DHOFzoSN8HugInwc5wufBjvB5iCN8HuoInzFH+Iw7wmfCET6TjvCZcoTPXkf47HOEz7QjfGYc4bPfET5f5AifL3aEz8Mc4fMljvD5Ukf4PNwRPhc5wucRjvD5Mkf4PNIRPo9yhM+jHeHzGEf4PNYRPo9zhM/jHeHzBEf4PNERPk9yhM+THeHzFEf4PNURPk9zhM/THeHzDEf4PNMRPs9yhM+zHeHzHEf4PNcRPs9zhM/zHeHzAkf4vNARPi9yhM+LHeHzEkf4vNQRPi9zhM+sI3wOOMLnoCN85hzhM+8InwVH+FzsCJ+XO8LnEkf4vMIRPpc6wucyR/i80hE+lzvC5wpH+FzpCJ9XOcLn1Y7wucoRPlc7wucaR/i8xhE+r3WEz+sc4XOtI3yuC4nPFmE+1xM+G70j6YSxbpR5g2CZjxzrRnu83pF+s9ERPm9whM+iI3ze6Aifmxzh8yZH+LzZET5vcYTPWx3h8zZH+LzdET7vcITPOx3h8y5H+NzsCJ93O8LnPY7wea8jfG5xhM/7HOHzfkf4fMARPrc6wueDjvC5zRE+H3KEz4cd4XO7I3w+4si67A7BNcrDHVmXfVSwzL2OrMvudKTfPOYIn487wucTjvD5pCN8PuUIn087wufLHeHzFY7w+UpH+HyVI3y+2hE+X+MIn691hM/XOcLn6x3h8w2O8PmMI3y+0RE+3+QIn292hM+3OMLnWx3h822O8Pl2R/h8hyN8vtMRPt/lCJ/vdoTP9zjC5/84wud7HeHzfx3h832O8Pl+R/j8gCN8ftARPj/kCJ8fdoTPjzjC50cd4fNjjvD5cUf4/IQjfH7SET4/NULnAhrd144IlvnTjpR5oWCZP+NIe/yswFmIWGYgm+1LZsKsm1bBMv/fCLXHWGMu/jnBcyoPTnGjPX7ekbr5gmDd3D3FjTJ/UbDM2x1pj19yRI9/2RE+v+IIn191hM+vOcLn1x3h8xuO8PlNR/j8liN8ftsRPr/jCJ/fdYTP7znC5/cd4fMHjvD5Q0f4/JEjfP7YET5/4gifP3WEz585wufPHeHzF47w+UtH+PyVI3z+2hE+f+MIn791hM/fOcLn7x3h8w+O8PnHF+A+4J9egGV+1pEyS+6v/dmRPZy/CO5nxB159/2vgmVe3+6Grv2bI2PC3x3h8x+O8PlPR/j8lyN8/tsRPv/jCJ//dYRPPQi5wGfEET5bHOGz1RE+2xzhs90RPsc4wudYR/gc5wifHY7w2ekIn12O8DneET67HeFzgiN8TnSEz6gjfPY4wuckR/ic7AifUxzhc6ojfE5zhM/pjvA5wxE+93CEzz0d4XOmI3zOcoTPvRzhc29H+NzHET5nO8LnHEf43NcRPuc6wuc8R/ic7wif+znC5/6O8LnAET4PcITPhY7weaAjfB7kCJ8HO8LnIY7weagjfMYc4TPuCJ8JR/hMOsJnyhE+ex3hs88RPtOO8JlxhM9+R/h8kSN8vtgRPg9zhM+XOMLnSx3h83BH+FzkCJ9HOMLnyxzh80hH+DzKET6PdoTPYxzh81hH+DzOET6Pd4TPExzh80RH+DwpJD5bhPk8mfDZ6LuLmx25c/MUwTLv3RVOmWcLl/nU6vYYjzXg0l11yi/tK7/4h6N110XaD+sj0WHUa4bH+mh0WG0kw2F9bHhY/X2FoVgfjw677cYQ6xPRBvpBohrrk9GG+lSMYn0q2mD/TFWwPh1tuK8nDNZnGsdK5neBxT8rglXQaPH/E8JSaPHPCWAZ3fh5xMoNGyt+8OQhfMWHi3XIZKaMseFhHTqZlVdsOFgxHiveX6gfKz7Ztx4z9WIlJlvaRLo+rKQNK5Mq1IOVmlyjraaCY/VOrtnue4Ni9U0O0IdiwbDSkwP1x1gQrEwwrHhvujZWf1CsTO9gLawXBcfKJdJ2rBfXg5VJJmxYh1VjJRvQhXGPuNmlvwY71piLn9Yix+cXBHX2F6NyOvtLUTmd/eWonM7+SlROZ381KqezvxaV09lfj8rp7G9E5XT2N6NyOvtbUTmd/e2onM7+TlROZ383KqezvxeV09nfj8rp7B/Ua79a5qY/FJyb/khwbvpjwbnpTwTnpj8VnJv+THBu+nPBuekvBOemvxScm/5KcG76a8G56W8E56a/FZyb/i7qxrrd6YK23e8Fbbs/CNp2fxS07f4kaNs9K2jb/VnQtvuLoG33V0Hb7m+Ctt3fBW27fwjadv8UtO3+JWjb/VvQtvuPoG33X0HbzuuRs+0i9WJZbLuW+rF8bbvW4WD52HZtPXK2XfswsTjbbszwsYbYdmMbwQLbblxjWFW2XUejWMS26+yRsKF2YXX1yNhjGmt8j5xt1y2AZWy7CT1u2HZnCNp2E3vkbLtoj5xt19MjZ9tN6pGz7Sb3yNl2U3rkbLupPXK23bQeOdtueo+cbTejR86226NHzrbbs0fOtpvZI2fbzeqRs+326pGz7fbukbPt9hG07WYL2nZzBG27fQVtu7mCtt08QdtuvqBtt5+gbbe/oG23QNC2O0DQtlsoaNsdKGjbHSRo2x3siG13pqBtd4igbXeooG0XE7Tt4oK2XULQtksK2nYpQduuV9C26xO07dKCtl1G0LbrF7TtXiRo271Y0LY7TNC2e4mgbfdSQdvucEHbbpGgbXeEoG33MkHb7khB2+4oQdvuaEHb7hhB2+5YQdvuOEHb7nhB2+4EQdvuREHb7iRHbLuzBG27kwVtu1MEbbtTBW270wRtu9MFbbszBG27lwiekX6p4BnpwwXPSC8SPCN9hOAZ6ZcJnpE+UvCM9FGCZ6SPFjwjfYzgGelj68Oy2nbH1Ytlse2Orx/L17Y7YThYPrbdiZPlbLuThonF2XYnDx9riG13SiNYYNud2hhWlW13WqNYxLY7fbKEDVUahybL2GMa68zJcrbdWQJYxrY7e7Ibtt3ZgrbdOZPlbLtzBd9/O0/w/bfzBd9/u0Dw/bcLBd9/u0jQtrtY0La7RNC2u1TQtrtM0LbLCtp2A4K23aCgbZcTtO3ygrZdQdC2Wyxo210uaNstEbTtrhC07ZYK2nbLBG27KwVtu+WCtt0KQdtupaBtd5WgbXe1oG23StC2W+2IbXeOoG23RtC2u0bQtrtW0La7TtC2Wyto260TtO3WC9p2GwRtu+sFbbuNgrbdDYK2XVHQtrtR0LbbJGjb3SRo290saNvdImjb3Spo290maNvdLmjb3SFo290paNvdJWjbbRa07e4WtO3uEbTt7hW07bYI2nb3Cdp29wvadg84YtudK2jbbRW07R4UtO22Cdp2Dwnadg8L2nbbBW27RwRtux2Ctt2jgrbdTkHb7jFB2+5xQdvuCUHb7klB2+4pQdvuaUHb7uWCtt0rBG27Vwradq8StO1eLWjbvUbQtnutoG33OkHb7vWCtt0bBG27ZwRtuzcK2nZvErTt3ixo273FEdvuPEHb7q2Ctt3bBG27twvadu8QtO3eKWjbvUvQtnu3oG33HkHb7n8Ebbv3Ctp2/yto271P0LZ7v6Bt9wFB2+6DgrbdhwRtuw8L2nYfEbTtPipo231M0Lb7uKBt9wlB2+6TgrbdpwRtu08L2nafEbTtPito2/2foG33OUHb7vOCtt0XHLHtzhe07b4oaNt9SdC2+7KgbfcVQdvuq4K23dcEbbuvC9p23xC07b4paNt9S9C2+7agbfcdQdvuu4K23fcEbbvvC9p2PxC07X4oaNv9SNC2+7GgbfcTQdvup4K23c8EbbufC9p2vxC07X4paNv9StC2+7WgbfcbQdvut4K23e8EbbvfO2LbXSBo2/1B0Lb7o6Bt9ydB2+5ZQdvuz4K23V8Ebbu/Ctp2fxO07f4uaNv9Q9C2+6egbfcvQdvu34K23X8Ebbv/Ctp23hQ52y5SH5bVtmupF8ti27XWj+Vr27UNB8vHtmufImfbjRkmFmfbjR0+1hDbblwjWGDbdTSGVWXbdTaKRWy7rikSNtQurPFTZOwxjdU9Rc62myCAZWy7iVPcsO0uFLTtolPkbLueKXK23aQpcrbd5Clytt2UKXK23dQpcrbdtClytt30KXK23YwpcrbdHlPkbLs9p8jZdjOnyNl2s6bI2XZ7TZGz7faeImfb7SNo280WtO3mCNp2+wradnMFbbt5grbdfEHbbj9B225/QdtugaBtd4CgbbdQ0LY7UNC2O0jQtjtY0LY7xBHb7iJB2+5QQdsuJmjbxQVtu4SgbZcUtO1SgrZdr6Bt1ydo26UFbbuMoG3XL2jbvUjQtnuxoG13mKBt9xJB2+6lgrbd4YK23SJB2+4IQdvuZYK23ZGCtt1Rgrbd0YK23TGCtt2xgrbdcYK23fGCtt0JgrbdiYK23UmCtt3Jjth2FwvadqcI2nanCtp2pwnadqcL2nZnCNp2ZwradmcJ2nZnC9p25wjaducK2nbnCdp25wvadhcI2nYXCtp2FwnadhcL2naXCNp2lwradpcJ2nZZQdtuQNC2GxS07XKCtl1e0LYrCNp2iwVtu8sFbbslgrbdFYK23VJB226ZI7bdJYK23ZWCtt1yQdtuhaBtt1LQtrtK0La7WtC2WyVo260WtO3WCNp21wjadtcK2nbXCdp2awVtu3WCtt16Qdtug6Btd72gbbdR0La7QdC2KwradjcK2nabBG27mwRtu5sFbbtbBG27WwVtu9sEbbvbBW27OwRtuzsFbbu7QrLtIqW/QtjxS1uk5JcvUD5bgM9G5bkhIlfmy1rCqZsW4brJtsjJ75SxbrTHgRY3+Bx0hM+cI3zmHeGz4Aifix3h83JH+FziCJ9XOMLnUkf4XOYIn1c6wudyR/hc4QifKx3h8ypH+LzaET5XOcLnakf4XOMIn9c4wue1jvB5nSN8rnWEz3WO8LneET43OMLn9Y7wudERPm9whM+iI3ze6Aifmxzh8yZH+LzZET5vcYTPWx3h8zZH+LzdET7vcITPOx3h8y5H+NzsCJ93O8LnPY7wea8jfG5xhM/7HOHzfkf4fMARPrc6wueDjvC5zRE+H3KEz4cd4XO7I3w+4gifOxzh81FH+NzpCJ+POcLn447w+YQjfD7pCJ9POcLn047w+XJH+HyFI3y+0hE+X+UIn692hM/XOMLnax3h83WO8Pl6R/h8gyN8PuMIn290hM83OcLnmx3h8y2O8PlWR/h8myN8vt0RPt/hCJ/vdITPdznC57sd4fM9jvD5P47w+V5H+PxfR/h8nyN8vt8RPj/gCJ8fdITPDznC54cd4fMjjvD5UUf4/JgjfH7cET4/4Qifn3SEz085wuenHeHzM47w+VlH+Pw/R/j8nCN8ft4RPr/gCJ9fdITPLznC55cd4fMrjvD5VUf4/JojfH7dET6/4Qif33SEz285wue3HeHzO47w+V1H+PyeI3x+3xE+f+AInz90hM8fOcLnjx3h8yeO8PlTR/j8mSN8/twRPn/hCJ+/dITPXznC568d4fM3jvD5W0f4/J0jfP7eET7/4Aiff3SEzz85wuezjvD5Z0f4/IsjfP7VET7/5giff3eEz384wuc/HeHzX47w+W9H+PyPI3z+1xE+vVY3+Iw4wmeLI3y2OsJnmyN8tjvC5xhH+BzrCJ/jHOGzwxE+Ox3hs8sRPsc7wme3I3xOcITPiY7wGXWEzx5H+JzkCJ+THeFziiN8TnWEz2mO8DndET5nOMLnHo7wuacjfM50hM9ZjvC5lyN87u0In/s4wudsR/ic4wif+zrC51xH+JznCJ/zHeFzP0f43N8RPhc4wucBjvC50BE+D3SEz4Mc4fNgR/g8xBE+D3WEz5gjfMYd4TPhCJ9JR/hMOcJnryN89jnCZ9oRPjOO8NnvCJ8vcoTPFzvC52GO8PkSR/h8qSN8Hu4In4sc4fMIR/h8mSN8HukIn0c5wufRjvB5jCN8HusIn8c5wufxjvB5giN8nugInyc5wufJjvB5iiN8nuoIn6c5wufpjvB5hiN8nukIn2c5wufZjvB5jiN8nusIn+c5wuf5jvB5gSN8XugInxc5wufFjvB5iSN8XuoIn5c5wmfWET4HHOFz0BE+c47wmXeEz4IjfC52hM/LHeFziSN8XuEIn0sd4XOZI3xe6Qifyx3hc4UjfK50hM+rHOHzakf4XOUIn6sd4XONI3xe4wif1zrC53WO8LnWET7XOcLnekf43OAIn9c7wudGR/i8wRE+i47weaMjfG5yhM+bHOHzZkf4vMURPm91hM/bHOHzdkf4vMMRPu90hM+7HOFzsyN83u0In/c4wue9jvC5xRE+73OEz/sd4fMBR/jc6gifDzrC5zZH+HzIET4fdoTP7Y7w+YgjfO5whM9HHeFzpyN8PuYIn4+HxGcL8JmM9aVS+XQiH0/Gs7FE/0CmN5bqHejLxDPx3kxvLpFJJvOZVCbdP9CfjvXHU8l8vNDbnyyUsPcTLPMTI1TmWGMu/mSrnPx2THGjntsE5feUI227XbDMTztS5jGCZX65I2UeK1jmVzhS5nGCZX6lI2XuECzzqxwpc6dgmV/tSJm7BMv8GkfKPF6wzK91pMzdgmV+nSNlniBY5tc7UuaJgmV+gyNljgqW+RlHytwjWOY3OlLmSYJlfpMjZZ4sWOY3O1LmKYJlfosjZZ4qWOa3OlLmaYJlfpsjZZ4uWOa3O1LmGYJlfocjZd5DsMzvdKTMewqW+V2OlHmmYJnf7UiZZwmW+T2OlHkvwTL/jyNl3luwzO91pMz7CJb5fx0p82zBMr/PkTLPESzz+x0p876CZf6AI2WeK1jmDzpS5nmCZf6QI2WeL1jmDwuWWUF5em/8R6UC/0DRD/VvRT9W9BNFP1X0M0U/V/QLRb9U9CtFv1b0G0W/VfQ7Rb9X9AdFf1T0J0XPKvqzor8o+quivyn6u6J/KPqnon8p+rei/yj6r848ov4palHUqqhNUbuiMYrGKhqnqENRp6IuReMVdSuaoGiioqiiHkWTFE1WNEXRVEXTFE1XNEPRHor2VDRT0SxFeynaW9E+imYrmqNoX0VzFc1TNF/Rfor2V7RA0QGKFio6UNFBig5WdIiiQxXFFMUVJRQlFaUU9SrqU5RWlFHUr+hFil6s6DBFL1H0UkWHK1qk6AhFL1N0pKKjFB2t6BhFxyo6TtHxik5QdKKikxSdrOgURacqOk3R6YrOUHSmorMUna3oHEXnKjpP0fmKLlB0oaKLFF2s6BJFlyq6TFFW0YCiQUU5RXlFBUWLFV2uaImiKxQtVbRM0ZWKlitaoWiloqsUXa1olaLVitYoukbRtYquU7RW0TpF6xVtUHS9oo2KblBUVHSjok2KblJ0s6JbFN2q6DZFtyu6Q9Gdiu5StFnR3YruUXSvoi2K7lN0v6IHFG1V9KCibYoeUvSwou2KHlG0Q9GjinYqekzR44qeUPSkoqcUPa3o5YpeoeiVil6l6NWKXqPotYpep+j1it6g6BlFb1T0JkVvVvQWRW9V9DZFb1f0DkXvVPQuRe9W9B5F/6PovYr+V9H7FL1f0QcUfVDRhxR9WNFHFH1U0ccUfVzRJxR9UtGnFH1a0WcUfVbR/yn6nKLPK/qCoi8q+pKiLyv6iqKvKvqaoq8r+oaibyr6lqJvK/qOou8q+p6i7yv6gaIfKvqRoh8r+ominyr6maKfK/qFol8q+pWiXyv6jaLfKvqdot8r+oOiPyr6k6JnFf1Z0V8U/VXR3xT9XdE/FP1T0b8U/VvRfxT9N7JL6UYUtShqVdSmqF3RGEVjFY1T1KGoU1GXovGKuhVNUDRRUVRRj6JJiiYrmqJoqqJpiqYrmqFoD0V7KpqpaJaivRTtrWgfRbMVzVG0r6K5iuYpmq9oP0X7K1qg6ABFCxUdqOggRQcrOkTRoYpiiuKKEoqSilKKehX1KUoryijqV/QiRS9WdJiilyh6qaLDFS1SdISilyk6UtFRio5WdIyiYxUdp+h4RScoOlHRSYpOVnSKolMVnabodEVnKDpT0VmKzlZ0jqJzFZ2n6HxFFyi6UNFFii5WdImiSxVdpiiraEDRoKKcoryigqLFii5XtETRFYqWKlqm6EpFyxWtULRS0VWKrla0StFqRWsUXaPoWkXXKVqraJ2i9Yo2KLpe0UZFNygqKrpR0SZFNym6WdEtim5VdJui2xXdoehORXcp2qzobkX3KLpX0RZF9ym6X9EDirYqelDRNkUPKXpY0XZFjyjaoehRRTsVPabocUVPKHpS0VOKnlb0ckWvUPRKRa9S9GpFr1H0WkWvU/R6RW9Q9IyiNyp6k6I3K3qLorcqepuityt6h6J3KnqXoncreo+i/1H0XkX/q+h9it6v6AOKPqjoQ4o+rOgjij6q6GOKPq7oE4o+qehTij6t6DOKPqvo/xR9TtHnFX1B0RcVfUnRlxV9RdFXFX1N0dcVfUPRNxV9S9G3FX1H0XcVfU/R9xX9QNEPW3bZAz9W9BNFP1X0M0U/V/QLRb9U9CtFv1b0G0W/VfQ7Rb9X9AdFf1T0J0XPKvqzor8o+quivyn6u6J/KPqnon8p+rei/yj6ryJPGSMRRS2KWhW1KWpXNEbRWEXjFHUo6lTUpWi8om5FExRNVBRV1KNokqLJiqYomqpomqLpimYo2kPRnopmKpqlaC9FeyvaR9FsRfrb8vq77fqb6Pp74/pb3vo72fob1Pr7zvrbyfq7xPqbv/p7uvpbtfo7sPobq9qY0t8G1d/d1N+01N+L1N9i1N851N8Q1N/n09++09+V099s099D098a09/xeu4bWYr0t530d5P0N4n09370t3T0d2r0N2D091X0t0v0d0H0Nzf09yz0tyL0dxj0Nw709wP03fz63nt9p7y+r13fha7vGdd3eOv7sfXd0/peZ31nsr6PWN/1q+/R1XfU6vtf9d2q+t5SfSeovm9T32Wp74nUdzDq+w313YH6Xj59552+T07f1abvQdN3jOn7u/TdWPreKX2nk74vSd9FpO/50Xfo6Ptp9N0v+l4VfWeJvg9E37Wh77HQd0To+xf03Qb63gD9Tr5+312/S67f09bvQOv3i/W7u/q9WP3OqX6fU78rqd9D1O/46ffn9Ltp+r0v/U6Vfl9Jvwuk37PR77Do90P0uxf6vQb9zoA+j6/Puutz5PqMtj6zrM8D6zOt+oynPvOozwDqM3H6jJg+M6XPEOkzNfqMiT5zoc8g6D15vUet92z1Hqbe09N7XHrPR++B6D0BvUau14z1GqpeU9RrbHrNSa/B6DUJPUfXc1Y9h9NzGm3jt+wyib02r2KbG1caLnWXeS5c2/D6vKc+/6jPA+rzcfq8mD4/pc8T6fM1+ryJPn+hzyPo/Xm9X633b/V+pt7f0/tdev9H74fo/QG9Xq7Xj/V6ql5f1Ottev1ptqI5ivZVNFeRns/p+Y0+P76/ogWKDlC0UNGBig5SdLCiQxQdqucsiuKKEnpepSilqFdRn6K0ooyifkUvUvRiRYcpeomilyo63Ns19zlC0csUHanoKEVHKzpG0bGKjlN0vKITFJ2o6CRFJys6RdGpik5TdLqiMxSdqegsRWcrOkfRuYrOU3S+ogsUXajoIkUXK7pE0aWKLlOUVTSgaFBRTlFeUUHRYkWXK1qi6ApFSxUtU3SlouWKVihaqegqRVcrWqVotaI1iq5RdK2i6xStVbRO0XpFGxRdr2ijohsUFRXdqGiTopsU3azoFkW3KrpN0e2K7lB0p6K7FG1WdLeiexTdq2iLovsU3a/oAUVbFT2oaJuihxQ9rGi7okcU7VD0qKKdih5T9LiiJxQ9qegpRU8rermiVyh6paJXKXq1otcoeq2i1yl6vaI3KHpG0RsVvUnRmxW9RdFbFb1N0dsVvUPROxW9S9G7Fb1H0f8oeq+i/1X0PkXvV/QBRR9U9CFFH1b0EUUfVfQxRR9X9AlFn1T0KUWfVvQZRZ9V9H+KPqfo84q+oOiLir6k6MuKvqLoq4q+pujrir6h6JuKvqXo24q+o+i7ir6n6PveUPcYedZ2u3ZTf3zEHld96lVH03gfs4R9thR2xmUn9L9kac/5NEyP+37pPl8K2znpmuL+y7/dQsO+Ykn3bUvYPuN2/X38NXu/feaPWy6gYbMtYfMtYftbwg61hMUtYS+yhL3EErbIEvYyS9gJlrCTLGGnW8LOtISdawk73xKWtYQNWsLylrDFlrAVlrCrLGHXWMKus4R9oss/7FOWsC9Zwr5iCfuaJewblrAfWMJ+ZAn7uSXsl5awX1vCfmsJ+6sl7B+WsH9bwv5rCRs73j+swxI2wRIWtYTtUQq7de4fJ73pNQ/Pp2E/6PZP9yNL2K8tYb+zhP3REvasJexflrD/WMJaJ/iHtVvCOixhXZawyZawqZaw6ZawPSxhcyxhcy1hCyxhCy1hB5XCuHHzOkvYulLYp7d+7mOvvj2bo2EbLOk2WtIVLelusoTdYsG8zZLuDku6uyzp7rGEbbFg3m9Jt9WSbpsl3XZL2A4L5k5Lusct6Z60pHu5JeyVFsxXW9K91pLu9ZZ0b7SEvdmC+VZLurdb0r3Tku49lrD3WjDfZ0n3AUu6D1nSfdQS9nEL5ict6T5tSfdZS7o/W9I9G/VPN7fHP2x+jz/m/pZ0B1jSHWhJd4glLGbBTFjSpSzp+izp+i1hL7ZgvsSS7nBLuiMs6Y6yhB1jwTzOku4ES7qTLOlOtYSdbsE805LubEu6cy3pLrCEXWTBvMSS7jJLugFLurwlbLEFc4kl3VJLuist6VZawq62YK62pLvGku46S7onLOnik/3TvdgnbIrJc79dfztKv83ihl4q0Wufi0q/Y425eAfBlcbPxLJ9HV61E+Y/2UEwQ8BPGPy2cPCfe29fu5cXq/E9yLe79DtCZGnSmDC6APaKUti4Urh5vqn03AF4YdQ75UlabpMZ/ltI2bQ7shhG3olBg39UCd+rwi6k0slcOts3OJDJDSQHU9lMOpVNZ3v7++LxXDaW6++PDSQGY9l0IdOb6c0X4gP5fHywP1uIZXqzSYN9NOFd8N6SmME/Jhz8sj45Nhz8hME/rsjJPpkfSMeSvdm+zEC8kO0rxAZS6UwyW0inc9lcfyqf7o3l4oN98cFEvJDJZHt7s4O9/fF4Id/fW8iUddXxLHY+kxnsH0gXYoVsoT+RjSViiYHBXKE31qfyKOQHewuFZKo/1pvM5LKDufRgvH8wmUkUBvP9hVh/uV5PYLFzid5sYTCXG0jFCv3JdDadUW2nPz2gADLxZF88O9iv2lQhns8OpgcHsvmYyisfz+bS8Vw62WuwTyQyl2vvFfyTQsGvtJmTQ8FPDBj8U8Lhv9xuTi16TN3W5eLoYbBPC4X3eBn/9FDwk2XZn8HKJhPPKv2Yy6XimdxgLhnLJwtKM2ayqVxfPKO7bjIzkEv2pvNKocYz2XSiN9/bl82qPpwdjJfbzZksdj6RTqWS/fF0Kp7uyyX78rlYZrCQySXj2Xh8IJ7LFQpKLw8opVDoS/f3qX6bH8yn85mBPqUcyv31LBa7MWewzw5F5rEy7+cwvMczyUQindRndTO5WDyVG0xkEgmteJTgBxP5/lS8v5BKpJKDOTWApTLZuFZ4g/2FTDXv54bDe1m/nxcOfsrgn0/wI568LrsgHPxy3V4YDn5Z/heFI/+Cwb84HPycwb8kFPyKzrk0FPkny2PJZaHwnyy3/2wJ3xPDjpXthAF/7GGrH4M9yGAnssnBmLKysr1qiMhnepXuV+Z1fiCTL/QlsgODqVgiF4/H8yn1XyKfS/UPqOFloC+vhpMBlV1Zp+VCkXm8PF/IC+P3ZWP9+b6+tMEvCOMPDPSls0qeBn+xMH5ysC9fSKbLOudyYfxsb6pQ6E1mDf4SYfzeeCzfm0iX2+YVwvj9A7HePjXrMPhLhfHVHCiZ68+WbbRl0vIZyMcGc/F+s/5wZQnf5KGdyXu5cN4l1x+B/Dyven3Fg/w7gVfpuU4E8qP8UPmYtQwjuxXFobxGmTCqYzCslfEz+XBYBUGsxYJYlwtiLRHEukIQa6kglunX4fa1VHkcXREKfjJj8FeGgh/LG/yrwsCPV+ZOVxN8T47/Mv4qgh8JAX91OPIv468JRz5l2/2aEn4Y2NfKY5fto+uKodRreU6wthhKvZbtx3Xh4Jft3/XhyKesdzaEw38Z//pw8PsN/sZw8Mv29Q3h4Jft02I4+GX7+sZQ8ONl/jcVw2ifibLevCkU/hNl3XZzOPyX12xuCQU/WZbPreHgl+VzWyj4qTL+7eHgl/XzHeHgl9e07gwHv2y33RUKfm95fr85FPy+cv3eHQ5+2X64Jxz88pr0veHgl+2TLeHgl9v/feHgl9v//eHgl+2fB8LBL9snW8PBL9snD4aDXx5/t4WDX7YfHgoHvzw+PhwOfll/bg8Hv6w/HwkFP10e33eEg1/Wn4+Gg1/WnzvDwS/rz8fCwS/rz8fDwS/rzyfCwS/rtyfDwS/rt6fCwS/rt6fDwc/p19n02cGjZ+zC485cCtpbMXOe0Zx9NHnQvNuJv+BcLRdkv4Dm3wm8hrFfQPMz/KB86H6BDhvD8BplwrAOxzD5jGHyiTJhaJ81grVDEOs+QaztgliSZXxIEGurINbDglj3C2JtEsSSlL1kH3q0SbE2C2JJtglJ2Uu2r3sFsST7tmSbuEcQS1JHPy6I1azjo7F7OzzePlhU+h1r0Bn8ceHgJ40sxlpkQfM3thK1rSI+fw0Whpm8OgFLuGxxW9ko/1jPYwk/VAZ+WGPrxOpgwsKo0zGWcmP+fvE5e9nE77Dg0/gTvaFtuANk0RmOLBK2eqPv8Zn8xxM+c/mBNYtPWrHYA+dn/8+CeGbPv8UbKu9xPlge/J4Ffq0EjzrN98TScyG/evDys7KLF+dzivtVEHNI0qOKvD9Oi2ickJtwYriqJCQ1HA+iJrUzTV5XR+lGG2/ZimzuyOzKVWuW5VtAlHQGjOKkcFhsrKoIYcmzxDuqWP3bvJ3U6vk7I0qDN46EcSIwmKbX+7V6rK42Jl/j18LEHwtYY5l0hvdWS3qKQdNhU7J1hyDN1ZRDO25VAd9ata3khNPt4snhdruwV3JsdUXlGq61FE/Y+sA4Rj6mLjuYMINlRp52jx+ZxpEy4kjZSfhoB78/lf5GAVM784aWbSSnfka+ur3+BspG6wbbaTj1kIoHbacm/04v1OEqbmsXnHXY4Q2tZ8lTpUHqlfJr6rKTCTNYZjij7ZTG7yBlpPHps0lfFV6qsKg3tE1jO+1kykP9aDv9Z+m5w6c8i0q/Yw25dBr7uMmD5h2OdRsfDNoPTP6dXpjtrtIPuHri9ImRXRfDa5QJQ2u5i8mni8knyoThakAjWNsFse4RxNoiiPVok2JtFcR6WBDrfkGsTYJY2wSxJNt9M8rLNg7Wi6WdZFvdKYj1gCCWZFuVLONmQaxm7dtPCWLdIohlTlmgnWnwtevwhvY96bkbzc+Ug/rR/DuBV1l+KrYSJ1fOpjXyGR+OfMr8jGf4Gc/Ix9RlNxNmsEoXUFbNGWj88aSMND59Nump34mlCosCpnY4Z+hmykP96Jzh6Eh12WjdYDsNsx5ofoZv6kfz7/TC7Dcxa7vg+n+HN7SeBeUTC1KvlF9TlxOYMINlVs5pO6Xxu0kZaXz6bNJTv/OhndI2je10AlMe6kfb6ZnQTmndYDsNpR7ihcDt1OTf6YXZbyrtlGsX4xk5dnhD61lQPrEg9Ur5NXU5kQkzWOZNZdpOafwJpIw0Pn026anfYmintE3jm7ETmfJQP9pOsyXcDp/yLCr9jjXkelNcXcrhp+PdTDmxn1FZy7XrZOB+ZvLv9Ia2izD6WRT48WsHRnY9DK9RJgzbSA+TTw+TT5QJw3lNI1hbBLE2CWLdI4i1TRBrsyDWVkGshwSxJNvEvYJYdwliPSqExennRvjaIcSXdjsFsST79lOCWJK6ULI/PiyIJVmPTwtiSbYJSdlL9W1PuIySbWK7IFaz6glJvl4INtPomLb7ZC/ZH+8TxJIs4xNNypekPSFZRtwfoHPLSOlvhze07wnOs/MRyM+Ug/rR/DuBV1l+KvNsTq5RRq5GdpMYXqNMGM6zJzH5TGLyiTJhOGY0grVFEGuTIJZkGbcKYj0siLVTEEtS9k8JYo3WY31YTwtiSbaJewWxtgtiSeqvRwWxJGUv2VYlZd+s+kuyrUq2r4cEsSTrUbJ9SfYhyfa1QxBrsyCWZBmb1ZaTLKOkPdGs9disttwTgljNaudI2pij9sTzow9J6glJvqTal37GddVG+HpMiC/tJGUvaQOYsRbPuxl87cJdQ0sEPmOLa2ihnMGqsYbGna3r8Ia2Q0H5xIPUM+XX1OVkJsxgma8f0zNhNP4kUkYanz6b9NTvwpJQooCpHZ4Jm8yUh/oZ+eozYWe3VJeN1g220zDrgeZn+KZ+NP9OL8x+E7O2C24NvcMbWs+C8okFqVfKr6nLKUyYwZpa+k3bKY0/mZSRxqfPJj31WwLtlLZpbKdTmPJQP9pOB6Gd0rrBdhpOPQQ/C27y7/TC7DeVdsq1C26c6vCG1rOgfGJB6pXya+pyKhNmsKaVftN2SuNPIWWk8emzSU/9roV2Sts0ttOpTHmoH22nV5V+TPT8+2e9epqzx1CGNB32h1DqO56PBe0PJv9OL8z+WekPUwLK1chnaijyyRWCtB/Kr6nLaUyYwZpe+k37A40/lZSRxqfPJj31ux36A+072B+mMeWhfrQ/bAK9TesG22ko9RCLFYK2U5N/pxemnqy0U65dcONfhze0ngX5yQepV8qvqcvpTJjBKl20XNVOafxppIw0Pn026anfNmintE2fVazmYTpTHupH2+mW0o8On/IsKv2ONeTyca4u5fCz5RsKp4eCn+jvYOpLDn8gY/D3CAe/z+DvGQp+ply/M0PB7y3LZ1Y4+DmDv1c47afM/96h4CeTBn+fUPDzZf5nh4KfKuPPCQV/oNx/9w0Fv7/c/ueGI59y/c4LBb/Qa/DnhyOfMv/7hcN/Wf8vIPiSaxEGf2Eo+JXbUg/wKq6VKZPJ39gi+5P4EZ+/BgvDTF6dgBWW3ceVjfKP874DCD9UBn5YB9SJ1cGEhVGnCyzlpvl3W3jFcmh3S1FGJtrdK4h1pyDWDiEszrZthK9bi3J8TRPii7N/G8GaIYjVKoSlHX5NsRG+9hDiSz/v2aRYMwWxZgli7SWItbcg1j6CWLOFsLTDr1w1wtccQb4eEeRrXyG+9PNcQSypsUM/zxPEmi+ItZ8Qlna4dtosWOeXsDo8vl4XlX7HGnKp/nDXu5LZcNe7Urlw17t6k+Gud6XS4a53pVLhrkelBs1cwIyRJg/adumYJzdvSQV+B83k3wm8yvJTmT/uDfygfEy/N7Lbh+E1yoShDtiHyWcfJp8oE4ZnCBvBelwQa7Mg1jZBrK2CWPcKYm0SxHpIEGuLINajTYol2VbvF8SSkj1nFzRLW5XsjzsFsZq1Pz4miCXZh5pV9g8IYknqCcmxVlJHS8peUl7N2r4kbRPJepSU/QtBTzwlhKWfcY7cCF+3C/I1Q4gvSSztbivK8bWHIF9SstcO7yZsljaBa/WNYLUKYWkn1Sa0u1MISz/j+k6z1KMkX1JttZl1YbcgX5L6S7IeJflqRnlpJ9lWcW21WcYOKf2l3dOCWJL2132CWJJrCpI2ueRcQXLt0dj3Zh17JgmLlP6GuwcQG/YewMxw+LHuAcxk5MqdhxXkJxeknim/pi5nM2EGa07pN313gMbfh5SRxqfPJj31e3Wp4qKAqR2+OzCbKQ/1M/LV7w481VpdNlo32E7DqYfg3540+Xd6ofabuK1d7M3IkWsXJm2UCUObfjaTz2wmH67udxTlsLYLYt0jiLVFEOvRJsXaKoj1sCDW/YJYmwSxHhHEkuxDkvX4uCDWZkGsnYJYkn1bsn1J9iFJvfpCkP1DgliSOtroQvN+PLWH2r3qfOqdO9D0Jh5nd2laVPoda8j1JsJ9H6y3L9z3wVIFY3ftS+QaAdnRc5pyNmIm8H0aJv9O4FWWn4rNOg/4QfmgzTqf4TXKhOH5qvlMPvOZfKJMGOrWRrAeF8TaLIi1TRBrqyDWvYJYmwSxHhHE2iGIJSn7Zm2rOwWxtghiSbYvSZ2zXRDrhSD7hwSxJMv4aJNiSfbt+wWxpGSvn/HsZLO01Wa1ASSxRsft0XHblbFjdNweHbdHx+3np+ybta0+JoglKS9JnSMp+wcEsST7kOS43aw6ulntCckyStq+kvUoKfsXgp54Sggr4g09Q9EI1j6CWFLr5Pp5thCWdrcV5fjqFuTrdiG+tLtLEOtOISz9PMeTw3q+y14/4/n2RrBmCGLtIYSlnaS85grxJdlWtZPsQ83a7pu1jM93XSjJl3ajY4f7Y4d2dwhh6WfJMw9S8tLPs4T40s97CmJJjbXaSY6PUvLSrhnHDu2eFsSSnPPdJ4gluacjuQ4guT4heT4H30GiZ8Mipb/cneE6n0Wl37GGXCLwux0m/07gVZafyjk5Tq7zGLka2e3H8BplwlCf7sfksx+TT5QJw/beCNajglj3CGJtF8R6XBBriyDWjibl615BrE2CWE8JYt0iiPW0IJakvB4WxJLsjzsFsSTbvaQulKzH+wSxJHWOZJt4SBBLUvabm5SvRwSxJNuEpG0iOW5L1mOz6i/J9iXZH5tVR0tiSbav+wWx8JvtdH4TKf3lvt8kONdLRSA/Uw7qR/PvBF5l+anM9Ti5cnNoI7sFDK9RJgz3oLlvBC1g8okyYaibG8HaLoh1jyDWFkGsR5sUa6sg1sOCWPcLYm0SxHpEEGuzIJZkf9wpiCXZviTltU0QS7J9SfYhSb0q2SYk9Wqz9m3J/ijZhx4XxJLsjy+E9vWQIJakDYD3RFB7u92rzqdem5+mN/G6mXSR0t9wv6naH/geBJN/JyOTMGz+BQHlWs/3OvWz5PcncWxqBOtxQazNgljbBLG2CmJJfit1kyCW1Hf4tNshiCUp+2ZtqzsFsbYIYkm2L0mds10Q64Ug+4cEsSTL+GiTYkn27fsFsaRkr5+lvhutnWRbbVYbQBKrWcdtSdlL2gCSOlrSnmjWtjo6bu++MW3UJq8Pa9Qm333ta9Qu3H3tqxntQu0k5dWsbfUxQSxJeUnqHEnZPyCIJdmHJMeOZtXRzTqmSZZR0vaVrEdJ2b8Q9MRTQlgRb+gZp0b4uq0ox9c+Qnzp525BLMn9IUl5zRLk6y4hvrS7UwhLP8/x5LCk2oR2+M5oM8hesm9L90epPqSfZwthaSfZH18I7QvvcWkEa4Yg1h5CWNpJymuuEF+SulA7SR3drO2+Wcv4fB9rJfnSbtQ2cX/s0O4OISz9LGmTS8lLP0vZ5Pp5T0EsqbFWO8nxUXIO04xjh3ZPC2JJrincJ4gluW8luc4kuf4leb4Q73GhZ1sjpb8d3tD+ovNZVPoda8wFvsfF5N8JvArzE7fJlTunbeSzMBx+BiKAT/lZyMjH1OWBTJjBOqj0u51g0fgLSRlpfPps0lO/T43Z9TcKmNqdVazm4UCmPNTPyFdDfmRMddlo3WA7Dace4rmg7dTk3+mF2m/itnbB9X+uXZi0USYM13CC1hdX93g2oRGs7YJY9whibRHEerRJsbYKYj0siHW/INYmQaxHBLEk+5BkPT4uiLVZEGunIJZk35ZsX5J8SdajJF+SekKyTUjW40OCWJL6Ht83pLYVvm9os0+5fGh6E6+bSWdsqw6Pt1EWlX7HGnKZ3gjkZ8pB/Wj+nYxMwrDvDgwoVyO7gxheo0wYrl0dxORzEJNPlAnDPtoI1uOCWJsFsbYJYm0VxLpXEGuTINYjglg7BLEkZd+sbXWnINYWQSzJ9iXJl2Q9SvIlqVcl24RkPT4kiCUp+0ebFEtST9wviCUle/2M7y42S1ttVntCEmvUBhi1AcLUq6M2wKgNMGoDjNoAtbAk5dWsbfUxQSxJeTWrnnhAEEuyDzXr2NGstm+zti9JO1qyHiVl/0LQE08JYUW8oecgGsHaRxBLav1eP88WwtLutqIcX92CfN1elMO6SxBLii/pepSU151CWNJtQqoe9fN0Ib708wxBrD2EsLSTlNdcIb708xwhLO2ata2O9sfdV8ZmbF/ajY5Do+0ew+4QwtLPkmdEJNvXLCG+9POeglhS47Z2kmOtlLy0a8b+qN3TgliSc9H7BLEk960k1yck100kzzPh+02tJCxS+mvOFVJ9ruMtKv2ONeYCf7vM5N8JvArzUz5X2O0NlWsrI1cju6kMr1EI0+6sYiUehrUyfi0jjMXVt6ZFpd+xhlxvbzeTN7Y1er5Brm7jmaBtzeTf6Q2t2zDa2jTgx6/ejOymM7xGmTCsw+lMPtOZfKJMGO6zNoL1oCCWJF/bhbD08zhPBku6jJsEsR4SxHpUEOt+QSxJee0UxHpSEOsRQawtgliSst8qiHWvIJZkGZ8SxLpFEMvMPdC20G5R6W8sVkilk7l0tm9wIJMbSA6mspl0KpvO9vb3xeO5bCzX3x8bSAzGsulCpjfTmy/EB/L5+GB/thDL9GZT4doOvekOb6iOF7RNEgZ/Rjj4SYO/Rzj4ZfnPCge/1+DvEw5+n8GfHQ5+uf3MCQc/E+77X/F+g39QOPhZg39wOPg5g39IOPh5g39oOPgFgx8LBT8RM/jxcPDL+i0RDn5ZvyXDwS/rt1Q4+GX91hsOflm/9YWDX9Zv6XDwy/otEw5+Wb/1h4Nf1m8vCge/rN9eHA5+Wb8dFg5+Wb+9JBT8ZFm/vTQc/LjBPzwc/LL+XBQOfll/HhEOfln/vCwc/LL+OTIc/LJ+OCoc/LJ+ODoc/EGDf0w4+GX9c2w4+GX9c1w4+GX9c3wo+KmyfjghHPyyfjgxHPyyfjgpHPyyfXVyOPhl++qUcPDL+u3UcPDL+u20cPDL9tXp4eCX9ecZ4eCX9eeZ4eAPGPyzwsEv6+ezw8Ev6+dzwsEv6+dzw8Ev6+fzQsHvLduH54eDX9b/F4SDX9b/F4aDX9b/F4WDX9b/F4eDX9b/l4SDX9b/l3oVJ4MdL7edy8LgPV4ot/0sy3syP5COJXuzfZmBeCHbV4gNpNKZZLaQTueyuf5UPt0by8UH++KDiXghk8n29mYHe/vj8UK+v7eQKY9bA4T3iJhsMmXeB0Op1wp+LhTZ58p6Lc/IPpHK9Q1kY+lCOpvNFNQglMipP31K8oXeRLY/OZhVNZEbyGfVdkl/YjCXyCXzGdVX88n+vny+ovMLbL02wnesLJfF0tixZHmsvZzFzmcyg/0D6UKskC30J7Jq7TIxMJgr9Mb6lDQK+cHeQiGZ6ldiyOSyg7n0YLx/MJlJFAbz/YVYf1nPLGGxc4nebGEwlxtIxQr9yXQ2nVHy7U8PKIBMPNkXzw72qz2qQjyfHUwPDmTzMZVXPp7NpeO5dLJPX8P7eGnj39wJdwVpN2PIs6alpd/mnmHtVhcrca4g4TT+YxN3/dV4T5fyC3KGq434S+4NRCA/z+PP1Zj8R+oMVxvwg/LBczXtDK9RCNMO91nbmXzamXw4rKcFsTYJYj0iiLVFEOthQax7BbG2CmJJlvF+QaxmbV+bBbF2CGLtFMSSbF+S8tomiCXZviT70HZBLMk2IalX8Sw4DUM7gtoxguN2IqgdYfLv9IaO22HYEWO8YHIdr6ir9LxsRTZ3ZHblqjXL8i0gSmqGoTgpHBabioWGocmH8Y4rVv8+qTg0ncdgtxK8DhLGicBgGrOXlqnDJx2Vhcf4tTDxxwDWGCad4b3Vkt7zQm/O5Wl7Zzj4SVvd0DKZ/Lu9oTKP+Pw1WBhm8ur0eJkvEpKdrWyUf1RpHYQfnG5xWB11YnUwYWHU6RhLuWn+3RZeuXLgteTckMFNkUz8TgtfNP5EJm+T1siwi4RJDyN+MqR90eSv1bY5rp/LD6xZfNIKuqpRTk/lYOQ2A+IZPdji2fUgxfLg9wzwayV41Nmm/EH6s+FTuyiDZZYiRk2Cshs1CZ7fJgGnarEpdXhDy7qo9DfWiIunEx0MTxXsTDybymZyuVQ8kxvMJWP5ZGEwls1k1TJxPKMX5ZOZgVyyN53PpbPxTDad6M339mWzanU+OxhPaMyukuA59YxqyahK+hW0Dka27RD/GLI6ObGUQHeDaCl8YM2ypWfkV1+9JH9NXmnaVR64Wm33jGL17zOLQ9Nxzmb+NKsaC9u8srV97epUY9iEwlZjpuqNk1JjbQxmEDWG1cXlq10LE9+mxnChvNWSXrtuxg+bekgWbOCmjjOJsGZhtnqm8mmwqVNxUjgs9u4csTnjfQyDaTPebc3TY/xqGcK2UajVJ78OS35mNOK6RjvEPagEFHKXiE0iuFiG0VGp7EZHpef3qNTKpEPeGl2jMuXQLur5l7/DGyqPRaW/sVg+kU6lkv3xdCqe7ssl+/K5WGawkMkl49l4fCCeyxUKqWx6IJVPF/rS/X29yUx+MJ/OZwb6EvFCiuu2EU/uVRuNe7jFkMfJJBry2tFjBh0knMY/uhSg8zuSGPJ7l8KvyS5bksuuzh+9/Ko1+TX53CkrVudXHbE8d/Q1+eWr6zbrjy9W/z6hODQd57QCMFLoIfgoBaqEWyG+dqZHmfiTS/5jvAoPNI5J2w7xTyhJSq8onVhayuFaouGnG9KbcO1MS5oCvC8q/Y415gIPACb/TuA1rAFgCvCD8qlzAKDNAsVJ4bDYu3MA4O7ymcxgmqZPyzTVJx02efRrYeJPAawpTDocALj0FIOmw6aE3Y+uPkxi8sbudyHpfqfM8M93kjdUDtgFW5n8dt/9Rb3poN21We8vCthdaROj8OcAnIlD41J3DmHJ84nHVfslTDp0aK9MgzDtTHOYCWkWlX7HGnLxwNrb5N/phdk8K81hJvCD8mkB+ewVjnzK/OzF8LMXIx9Tl3szYQZr39JvqpZo/L1IGWl8+mzSU7+rSmorCpja4TVvezPloX5GvtpyWdpRnZ/pW5uIbbcKbEna//BTc5w6n8LkHWXSm3hcPmMbzGcskw/ujWp3dbE6rNMSRvcnpwHmeJIO98no9TZnQdgEgjkWMCdaMKMMpq67aV0VPE37k3icKkazYT/CD01Lf7dDXO2uKVaHmbj3k3Z1G7QrOgxhfdd7dSFNb+IZWdF2gnVK+zPWKdUTKH+uP5qwfZlymbB5Fsz5DKaWW3dXdTwqdxxb9if+gqZGX9CxxeTf6Q1tT2GMLVz7pvLBsWVBOPLpjQA+5WcBIx9TlwcwYQbLfLacji00/gJSRhqfPpv01O8JGFsOIHFxbDmAKQ/1o2PLIx3VZUP9wf01uOiH/ZvKxtQvZ2uZPqX5eUVHdVlMOipPOh5dTMJp/CTZwHy1RYdh/e0HZayle6cxZQyqx88FrP0sfC2ogXU2YNH0CwDrgBpY5wEWTX8AYC2sgbUWsGj6hYB1aQ2sUwCLpr8UsC6rgbUOsGj6ywBroAbWBsCi6fGVucEaWNcDFk0/CFi5GlgbAYumzwFWvgbWDYBF0+cBq1ADqwhYNH0BsBbXwLoYsGj6xYC1pAbWSsCi6ZcA1hU1sC4CLJr+CsBaWgPrNMCi6ZcC1rIaWJcAFk1v0nYzWEbPmzH5SuK/O+bDJv9O4FWWn4rNcqU3VK5UPvga2nKG1ygThnOz5Uw+y5l8OKz9BLH2F8RaIIh1gCDWQkGsSwWxLhPEGhDEGhTEygli5QWxCoJYiwWxlghiXSGIheOPzX7Wz+bqXZv9bNJRHYTrnThvpPEphp99Trcp9q/B8wzgebh2un7eA7CGa6fr51mANVw7XT/vA1jDtdP182zAGq6drp/nANZw7XT9fCBg0fT12On6+SDAasROv7FYjdWInZ4DrOHa6fr5YCjjcO10/XwIYA3XTtfPhwLWcO10/RwDrEbs9JuK1Vg2O/3KGnzFgS+a/krAWl4DKwFYNP1ywFpRAysJWDT9CsBaWQMrBVg0/UrAuqoGVi9g0fRXAdbVNbD6AIumvxqwVtXASgMWTb8KsFbXwMoAFk2/GrDW1MDqByyafg1gXWPB0u7kYjUWTX8NYF1bA+tIwKLprwWs6zx7GV8EZaTprwOstTWwXgxYNP1awFpXA+swwKLp1wHW+hpYLwEsmn49YG2ogfVSwKLpNwDW9TWwDgcsmv56wNpYA2sRYNH0GwHrBguWdpcVq7Fo+hsAq1gD60TAoumLgHWjZy/jEV41Fk1/I2BtqoH1MsCi6TcB1k0WLO1WFKuxaPqbAOvmGnwdCXzR9DcD1i01sI4CLJr+FsC61YKl3enFaiya/lbAuq0GX0cDXzT9bYB1ew2sYwCLpr8dsO6ogXUsYNH0dwDWnTWwjgMsmv5OwLrLgqXd8mI1Fk1/F2BtrsHX8cAXTb8ZsO6ugXUCYNH0dwPWPTWwTgQsmv4ewLq3BtZJgEXT3wtYW2pgnQxYNP0WwLqvBtYpgEXT3wdY99fAOhWwaPr7AeuBGlinARZN/wBgba2BdTpg0fRbAevBGlhnABZN/yBgbauBdSZg0fTbAOuhGlhnARZN/xBgPVwD62zAoukfBqztNbDOASyafjtgPVID61zAoukfAawdNbDOAyyafgdgPVoD63zAoukfBaydNbAuACyafidgPVYD60LAoulN2m4GK1L6a/aMHif+cns0qXgE8jPloH40/07gVZafyp7R495QuVL54J7REwyvUSYM1xyfYPJ5gsmHw1ogiHWAINZCQaxLBbEuE8QaEMQaFMTKCWLlBbEKgliLBbGWCGJdIYi1VBDrSkGs5YJYKwSxVgpiXSWIdbUg1ipBrNWCWGsEsa4RxLpWEOs6Qay1gljrBLHWC2JtEMS6XhBroyDWDYJYRUGsGwWxNgli3SSIdbMg1i2CWLcKYt0miHW7INYdglh3CmLdJYi1WRDrbkGsewSx7hXE2iKIdZ8g1v2CWA8IYm0VxHpQEGubINZDglgPC2JtF8R6RBBrhyDWo4JYuOZY65yc+USV7ZycSef3PlYricOdjaMYfufwWgnPtc7jXQw8c3ly7zeuKVaH0fcb8Uw+fecZ332k7zDj+1b7kjBcs51HwvBdt/kkzJSHe7+xw1Ieel8vvtdL38/Fd7jHk7C9IKybhO0NYRNI2L4QNpGEzYOwKAmbT8pq3s9th7LuUfIP+YYX9uox2/vREZ+/njd0XVw77Lf0HqII5DNFMB+KZa7Gs13NMdx8aB/FNfdpgvnguxw0n72YfEy7of1WsN0EfpfG5N/pDdUxYeyLcHcf7MXINeBVI3i9AxUnhcNiU7HQsFbww3gSNwPtS8I4EeBrprRM+/qko7LwGL8WJv7egOV3bUarT35cVdJ02JQi4N9O/CcxebdD/N5Se9A3A50+oxLfLy8qD7wczPDudzkY8mDi9xMeTpzBY7b5lGsvH8yTuiq8HNbFY3oMJleufaFcyMPewIOJv4iU6yy4dWlfJr3n42fk7zFp8TfXZiZB/Hk1yoP1ZOIfY6mnmQwPtE+iTJEHjLOvDw8nMDxQtTa4YuXaklrzwOHtiRH4jSLHG5BmMjh+zohBF880xVbARRWF+VAc5EkX2Vhsufyy/Oq8T6FRV0d8MmvxeIcmtOcNHW5DGt4CD7cm/06Pb4uLZPixXp1E5YMmEXcVUpQJow0DG6Atn/FexbRftXrF1X5tIeg4HGH4wfReDSzze7T9DL/9BDTXsNlQcVI4LLZfldVqJhKXbtvMHIppzDWbiUWrazKTr/FrYeLvBVh7MekM7zZzjGLQdNywiEMsNwTTix5p/MvJ8HfKDL6c5neWPONFjSM/e4oHPlX2PJ09RQHOxKFxqYsSljyfeFyTN5dbBOmO4V4I1ddvmtsShgcTRg/o4IIVPXCDC1b0gop28oyulSm7Ka/uRufOqOBiPOSVdu0rIIx2m6UQRi10XICki4VXQhhdLFwOYfSl6RUQRhdfV5ae26EMN8JiW0ijHrvYZvKa6A2VK13AxPbdyvjhohFNP9mSz4QG85nA5BOyLOPh9tfKh/ZsFgrNH/uFCef+GiwMQ+sr7Gu0bUO2dljP3GqQDWuvOrFCtoKTaHJw5eb0K8crVw5c/Sh/WLM0JdFT4IcsmxtofoTzYdBk4MsbTf6dwGtY7ZH7/gz3AU5ug8ekRd2n3R3FSjwMa2X8WixY2wWxHhPEelgQ615BrE2CWJJllKxHyTLeI4glWcaHBLEeEcTaJoi1RRBrpyDWVkEsyTYh2R8l+5Bkm5CU1/2CWI8KYknK/j5BLEnZ7xDEkpSXpC7cLIglKa9m1YWS8pLUOS8Em0myTUiO21Ky18/jPBks7STbvaTsHxDEkmz3kmWU1BOSNoCkvJ4SxHoasILO6038biY+ty5l1jLpYU6T1qyh0LVJ6R1VPznRA6Qmf82j0Qe5/MCaxSetoPcaltNTORi59UI8syXY4g3VOeN9sDz43Qt+rQSPOvoxySBbZuGsxyYD72Cb/Edqy4w7bM6te3If+DBpo0zYXPJMw2g+3Ic3okwYjtuNYD0kiPWIINY2Qawtglg7BbG2CmJJtomHBbE2CWJJtglJed0viCUpr/sEsSTl9ZgglmRbvVcQ64VQjzsEsSTlJTkObRbEkpRXs45DkvKS1PeS7UtS50j2R8k2IWkzScleP+MaTLO0e0nZPyCIJdnuJcsoqSea1f56ShDLrMFwLwzjMWnbRyq5fGj6BQGwuPmwic998MO21sN98KOj9PsyEhbGWg9XH9xHQ4az1mPkFod4uNZDddtCHywPfsfBz2+tB88tFUuLSUa+IZ1HY89F4nlFehZqPpSPW1+kfth+afpOSz5dDebTxeTDfVjalDtkOecikJ8pB/Wj+XcyMgljDW1yQLka+YS0pjcY8Ybqq1YmT8OvqUubbjX9lb7eQOPjB+Fp/6b6ph38tpb6ZtQbqnfPKlbzEFS/67Xee8ZXl22451kpLjduBOkPw82HYq0u7vrLvT6DeqTeM6w0/V4+WKbetTMfJ9Xh+EFFUx9tDKZ25kPl7RD/yVJ96fHmfeT8vo5Dz7kaOeg6fnq8nVealvKKb0xPJR9CfmUJk5OzqXeuHeBbgJ1Mvhwm6uZ6666L4cGGRetrPMSnl5dw8fHNbBP/TaTuzoK3iPHj1NrR9rOXDw+0/dAP5vm1n7cNo/28Y7ydV2w/473qvE38v06oYL4b2g+Vsa39jIcw2n6MjLixHd95qHdsp+ltNsRUCKO8T4OwqUy5IhBG+Ztq4W88w4MZP/FjhYtKv2MNufrfcZoAYUtJ2EQIo+84RSGMXiCM4wq9EBjHbXrB774QtpKE4WU+9ALe8RBGL9TF10+pa4XftF50X/xgHe9i0XaD72LRfkjlS2VFb5Tg+jzOC75G3md4e3d1fja7ll6QJNjukkHsBJr/SNm1E4EfP53CXRJl0kYhTLvbipV4GNbK+LVYsDYJYj0iiLVZEGuHINZOQaytgliS8tomiCXZvh4WxNouiCXZJrYIYennMZ4MlnaPCvGlnWSbuEcQS7JNPCSIJalXJfu2VFvVrln1qmSbkNRfkn1Isk1Iyut+QSxJed0riCXZViX5Gh23d5+8JO1VSR0taQM8Joglqb+atU1I6olmHYck5zCSZXxSEGtUrz4/9JdkPd4tiCUpr2bVOc1qF94niCXZHyXHWsl6bFZ79WZBLEm+JPXqA4JYknqiWXW0JF+Ssm9WPSFpk78Q5rWS4/bjgliSfEnOayXrUbI/Ss5hJNd9JbEk2wT2IbPvSa+WN2dXtDMfAGqH+G8r7UN3QB4RT3SvOWU7F2fynhdS3hHIz/P4fW48r0D5wbOdNKytAV778+neZCKfi2cHMwP5gfJZynnAK/rhefD9mPi2s6Ah3debMOcuWosVfPrhK+3aSNg8CGsnYfSO3adnV/Mf0lmcRBD50/yjTPyzipV49dTlJK+6rdH+yJ0ZoecksC+F04+Tgc+MmPw7gVdZfipnRjhdOpGRcbdFxlEmbE/yjPqrlfHzO7urHdr7jWA9Koh1jyDWdkGsxwWxtghi7WhSvu4VxNokiPWUINYtglhPC2JJyuthQSzJ/rhTEEuy3UvqQsl6vE8QS7IeJfWXpLweEcTaLIglKS/JPiRpT0jKa5sg1qhe3X16VUr2+hnvE2iWdi8p+wcEsSTbvWQZJfXE/YJYzWqv3iqIZexVXCvUz/T9k3DX02KJcNeQKt8b4da0aJkkvyFj8hqpb8hwZbO1A7reRWXgh7VfnVjhrqtV6nSepdw0/24Lr1w5ooIy2Ruwgq4t1Vu3E72h9WnShtzHyuuce1vkRPMfzt0cRm4JiHdusSIHlPc8HywPfifAr5XgUWdkTNcf8aPwnE4eT/zwU5K0rU0GrGk1sM4FrMkWvvaugXU2YNH02Ibn1cA6D7C4OrG1b4q1FrC49m2wFtTAOgWwuLZpsA6ogbUOsGj6AwBrYQ2sDYDF3S9jsC6tgXU9YHF39Risy2pgbQQs7p4dgzVQA+sGwKLpBwBrsAZWEbBo+kFIN0jC6J0C3Luyq4u7/ur9kdMnVPPE3c9A3131+6L9PeT9+rMmVPNN03d41WEdJGwK8ExlYXSU0fH03mtpHU/z8zze9jH5dwKvwvyUbR/unnIqHzM+BvxcKl5pQcVJ4bDYVCw0rBX88NXsDkg3nK8XTyBhQYYc7mp0TEdl4TF+LUz8bsDqZtIZ3lst6SkGd606lp9ebWH8JzF5t0P8Qqnw2hQ5Ha7+4PKi8jAyxXZirh/BOMiDiX8F4eHEGTxmm0+5xvtgFonKuXICj+kxmFy5JkC5kIfyVjvEv4qU6yz4MjRtr9gHrilW8zaRycvz8aPYNC2G2fKtlVY/95BnDOPa7SSIT7fhg7RXE3+dpa10MTzQ8mK9Ig8YZ4IPDxsZHqhqHVyxcm1JtXrg6GkiThViVWIVdDE4fs6IQRevOIHHMb9tzY+qsPFMHuN9eKRpx5PnXH5ZfnXeR0A4tnT6ZNbi8Q4/yWnSadfhhTocBzYPTP6dHt9uF8nwE0c9bvhB+eBRjgkMr1EmjDaMevIZT+KuWr3iar+2ENRu4MYrTO9B2gjjpx39zMhIXdXG5TO+wXzGB8wnjOvLuHwmNJjPBCYfxOKmJdotL1bCafydRI8/M5vHbPHBNEsFJn6eKQ93LZaJX2Di55kyGlnmSFjBq503lSWOe4vr5HUJE38xiZMHXil/S+rk9dwR5nUvhtduJm8cQ2i5dscYYvLvZMoYxhhik6t2dU4xaVNHcVI4LDYVCw3DoWIixDu+WP17OFPMK0gYJwKcYtIyXeGTDrsE+rUw8ZcA1hImneG91ZKeYtB02JS4dPr35UyaIF3nCsBfVPoda8jFe4N2HZP/SHWdWu0Gza+lDK9RJoxOC2kYzWcpkw+Hta8gVk4QKyqINVkQa5og1t6CWPMEsfYTxFogiHWAINZCQaxLBbEuE8QaEMQaFMQqCGLtJYjVLYi1P2Bx0x4/M2o4U2RcL1rik/8UJr0HaSPgN8UHy+BoP8ogTjvMuDDGs0952iH+L5ll1FaIg/wE+UIo2kqLSr9jjbnAJrzJf6S+EFpr6oV2SIHhNcqE4XifC5iPRBvXztj2EYYfTO8BVoTxo2FcG6fLAKaN404qTUt3Urldd2OXcLvoncAPtyNP48+E+AsJD1x8+lUIGv/fTJ/jdtO7fPKj/FE/2/LRQh8s7jZ37S4p8ry3Tqzwjss63MkBbonSxL+MiU/HecMPJ5vLPD5vWh5an0UoT/mrQkx5bG+FmmXRNhImqE9ymo83Ez5Qru3F6nJfRsJamfgoc+4UxWUkjpFZFOJT+XMnpi+FMNq30D7lTuTQtof9nvtKBf1Cge1rFM3U72eStmbr9/N98qP82fo9TV9vvzenaJD3OXX2+/kMf83U7/cP2O9Nmxrt9433e268D9rv6Xj/tM+XSQwuxdLhuJ5g+KJthtoMl5BwGj9t6QOcDrEtpXN9ms698as4VJYLIYzybuZEu28M6+3j2nLVV66KwWWhHcqO0zdUR5j6jnpDdcsCCKNzSFz74MYpemIW2yttZ3ScegVsedKtVdNeR7fWy67urfWA2yI47OOOdqPbIhjvuGL17+Fsi9hOrFFM7oNK3T7pqCw8xq+FiT8esMYz6QzvrZb0FMPvI4y0/PSkkvHvYPJuh/jnElV9ygz/fPF0JNcFs0x+u++gbDwetLs6flAWu6uBjwKciUPjUhclLHk+8bDatTutODQdOiPKcL/pWf83t7CZ0lVT/JbVMhLWTp7RtTJlN+XV3ezcOr5lRbs7fsuKdpulEEYPqiyDMLpjdyWE0Z2u5RBGD1uugDB6aHJl6RlVzVWljE0bCOl7U+z3c7GeR62H5431cEax+vdwrAfuVbGg1sNkn3RUFh7j1wzWA5dO/x7DpAnSdUJ6vTbw9WQm/5HqOrXaDW5mTGF4jTJh2C+mMPlMYfLhsHAjsZal3OjGSAR+j/fJv4VJ71mwaJoIwze2d+1w88/wMsaz9w98P+UeZkHSll670aFmaH+p9ww4d+g/yoThmNMZMB+JNq6dGYMiDD+Y3quBFQlQFjobwzZuyjnGq28m+CjTxo2sW5n0Gr8LFmzo517HQDlWkd+tEJ8rx2ooB8a5Gsph4j9NynEilIPyZPjphvQmXDvTT9cA74tKv2ONucD91OTfCbyG1U/XAD8onzpNQtosUJwUDovt1zVqdcejitW/h2MSXkPCOBGgSUjLdI1POmzy6NfCxF8DWGuYdIb3Vkt6ikHTYVPC7kcXlFYxeWP3e5tlQYnmu8obKgfsgt1Mfqa7XgNxtTPd9Voo06LS71hDrjcTtLua/DuB17C667XAD8qnzu5KmxiFPxfgTBwal7pzCUueTzyu2qcx6dAZUbYDz58tNT+t6d9Xep7oDW3qbcAP5cGm8aJMehOPy2dsg/mMZfLBhSztzKXw3EJWG6RbRtKthnRXkrCzIGw5Uy78eDyHudKCeRUTpusu01PJy0+N0SaO6phTgUG7C17mQtNfC1jX1cDCy1xo+usAa20NLLzMhaZfC1jramDhZS40/TrAWl8DCy9zoenXA9aGGlh4mQtNvwGwrq+BhZe50PTXA9bGGlh4mQtNvxGwbqiBhZe50PQ3AFaxBhZe5kLTFwHrxhpYeJkLTX8jYG2qgXUxYNH0mwDrphpYKwGLpr8JsG6ugXURYNH0NwPWLTWwTgMsmv4WwLq1BtYlgEXT3wpYt1mw9PN0rxqLpjdpuxmsSOmvMaNuJ/6C+3KBV/NM/p3Aqyw/FTPqdm+oXKl8cHXiDobXKBNGxyIaRvO5g8mHw1ojiHWtINZ1glhrBbHWCWKtF8TaIIh1vSDWRkGsGwSxioJYNwpibRLEukkQ62ZBrFsEsXAss9n1+tlcWGSz6006qs9wWYNbPuHmAX7zBro0cm0NnvcAnoc7f9DPswBruPMH/bwPYA13/qCfZwPWcOcP+nkOYA13/qCfDwSs4c4f9PNBgNXI/OHGYjVWI/OHHGANd/6gnw/2qrGGO3/Qz4cAFk2POndTDaxDAYumr2f+oJ9jgNXI/OGmYjXWcOcP+jkOfA13/qCfE4Blmz/cXgMrCVg0/e2AdUcNrBRg0fR3ANadNbB6AYumvxOw7qqB1QdYNP1dgLW5BlYasGj6zYB1dw2sDGDR9HcD1j01sPoBi6a/B7DutWBpd3KxGoumvxewttTAOhKwaPotgHWfZy/ji7xqLJr+PsC6vwbWiwGLpr8fsB6ogXUYYNH0DwDW1hpYLwEsmn4rYD1YA+ulgEXTPwhY22pgHQ5YNP02wHqoBtYiwKLpHwKshy1Y2l1WrMai6R8GrO01sE4ELJp+O2A94tnLeIRXjUXTPwJYO2pgvQywaPodgPWoBUu7FcVqLJr+UcDaWYOvI4Evmn4nYD1WA+sowKLpHwOsxy1Y2p1erMai6R8HrCdq8HU08EXTPwFYT9bAOgawaPonAeupGljHAhZN/xRgPV0D6zjAoumfBqyXW7C0MzffTWTSvxywXlGDr+OBL5r+FYD1yhpYJwAWTf9KwHpVDawTAYumfxVgvboG1kmARdO/GrBeUwPrZMCi6V8DWK+tgXUKYNH0rwWs19XAOhWwaPrXAdbra2CdBlg0/esB6w01sE4HLJr+DYD1TA2sMwCLpn8GsN5YA+tMwKLp3whYb6qBdRZg0fRvAqw318A6G7Bo+jcD1ltqYJ0DWDT9WwDrrTWwzgUsmv6tgPW2GljnARZN/zbAensNrPMBi6Z/O2C9owbWBYBF078DsN5ZA+tCwKLp3wlY76qBdRFg0fQmbTeDFSn97Sg9v5v4y+33pAK/F2by7wReZfmp7D+92xsqVyof3H96D8NrlAnDNcf3MPm8h8mHw7pOEGutINY6Qaz1glgbBLGuF8TaKIh1gyBWURDrRkGsTYJYNwli3SyIdYsg1q2CWLcLYt0hiHWnINZdglibBbHuFsS6RxDrXkGsLYJY9wli3S+I9YAg1lZBrAcFsbYJYj0kiPWwINZ2QaxHBLF2CGI9Koi1UxDrMUGsxwWxnhDEelIQ6ylBrKcFsV4uiPUKQaxXCmK9ShDr1YJYrxHEeq0g1usEsV4viPUGQaxnBLHeKIj1JkGsNwtivUUQ662CWG8TxHq7INY7BLFwzbHWObmLS8+2c3ImHV13wlcFWyENjU8x/M7htRKea53HuwR4buQ83jTA4s7jce+NrSlWh9H3xvBdAXoBEr6LdiUJWwNh9L0xXP9dQcKuhbCVJOw6CLuKhJmy0vfG2qGsLy75h/xGN3v5EMqDyj/i89fzhq5Ja4d9hl5mFYF81gjmQ+WF69DXCOZD2zSW51rBfCjWUcVdf7l+2AH8cHroOks+NL2Jx+WztMF8ljL5IJZ5lVs7844m7dftEP+0Up/Rr3J/fHY1Jqfb6Oco8H1MTreZvriOhEnuqxj8DeHgJ40suPPNtEwm/25GdvW0Y5pXpzdUz4exJ8WVjfKP7ZDunVAZ+GGtrxOrgwkLo07XWcpN8++28MqVw69v0nw6GJmY+BssfNH4tvPvRoZ0P0lQhgmbDLkz9PpagnGl51x+YM3ik1bQr9GU01M5GLnNhHhG77R4Q9vgeh8sD37PBL9WgkfdSOlxLp/OBvPpZPLpZtI1Os5yPHM37pjxSNtwV8G7/6Z906tIaNpLipVwGj85o4K5uoTJvUfk1ycjJD96ZwLeVETtz1YmDo6vJv5aMr7iV8SXQZlpOTmeDSa9l4LybO6HQB42gl0c0ljM2sUmr4nAr36+AsKonbsGwqhtiu/acu+XUT9sr7Z7I8xvPzuK2lk0/q112lFBrxkyabk5H8qBy8c2jq8OmE9Xg/l0Mfk0aidx+XA845xXO6qHHgA9ZNor1UM0rbkPoB3izyF6aJtFD+GcH2071M2oh0x+fnoI26eJv8Oih7i5w2lFf54NJtVDlGfUQyb+E6CHQrLvWD1k8uLGWby9st5xdjwjh7DHWby4ep1gPhTL9BXO1kT9U6/tT9Ojre3XX5/p4fPk+ittu+0Q/xfTK5hvhv5K27vNPsOxbR2TL/YZzxs6f9TOpsvW+WAFHaNM/HdbxijbXEg721zfj782j+9Tq4qVMvtheYyfiU/HR1z/Wg9x11ni+s1d9XP5k2il3+GsL6Rzpr3T95SNM2EbGZ5NGH2P+JxiJR66VvhNy6Tbw6dmV3AxHvJD5bTRB5PTCdcUq+OaMrcwuBsAl/ZzlNdZxeowE/frpfau+/hne3g8bCfaZUt44c6h03msX+qwflE+6Lj6NXzr+v377AouxsM8aR3eAGFUL+N9dFSfGwwt+x/CuN9sfWk4/aUeeXL9hZMn7tNw4yOVZztgtE+qxPkxtPdyHG9oezf9x/RZI782Jr12aN+Z+D8n48vRc/j8bf3N83i9QOWA90hu9HheuDKbuC0lOZn2SPuYXHtMxU09FoFnmveNIeUdgfw8j19rNvl3M/wUS8+dTFhbA7z2xtPpRF8q11sY6Mv09uYjgG94RT9cJ93ExI8y8Y2sb/LCkHUyx31ebhORq3ZtJOxGCGsnYYZH3Yeenl3N/6aQ+A8if5p/lIl/bbESr566jDL54LyiEax1w8Sa5FX3AW4spLYNjoXUfjH6VevlOZMq/pxetOk6o9tQ79Nyoh7cG3QdHf8E21CKs0dR1xVDyjuorjP5d3v+ddvJhDWi63K9qXiq0N87kCsk87l0IeINHRNaGT/UdVy7ncjED1lXxDhdh/qsjYQVIYzqOsMjp+vCGReTsSDyp/lHmfio62xY2rX4YHG6rhGsdcPEMrqO2kFop1Jdh3bqBqY8VNfhvGwe6KSQvnTArgOiTqX8akfn0BuInFC+iEP9qN1M0+C6jIl/ELHbD5jE82fKcBbDH3eui5brkEn+8TYw8fTaotEti/Orz7w8e3U+d2Z+8Or86laPZw+LiMXH6ZQH8bRrA7+r4Dcu3ywFHDMEt3m1HW0SFIurOoqNQ2+iJDKtwo6bs+uZO36m3aLS31iDjps64lAbzhZfIvC0wuTf6Q1tcmEcYeGWL6l8cHgMZ+shEdMzYFze1u6q4lDZIB94hJD7WE0Q+dPyckvt2G5MvpwK9NvuPIWorEWTKvFRBwQ5Nkb7ie3oTISJPwBhdHssYsHHZZBjSD8+C77dSU0dU45wvxqeiHNfDaf6j5pRfu2fxjcyxy0eKhPb9riWp6lz25Y8t+VJv1OK7ZrbDse2O4HJJ+w+MgHKQ9slHhmod7uQa4+1tr0u8OljftteMRJO43+TbHtdHKA+uT5g4oXcBxJcH6ByDdIHaHxzrSe3zXkphHFHh4IcK6q3bdP0fn1IuyuLw88H05t44doK6QFu6mAcN3XAvkCX8U3dcVsmdOsTHbeMb8r73FGIORVcjIe8ctsbqJsp35zuwOlevbojyJE2+ooLHQPMp2Wwv7T75O131GUDGSufmV2NyR0B4Nqlic8ddeWO0nJb7HjUNaQj4CnD6/WET5Qv5k/baAuJf70lPtqkiL/RR3Ymvna0jvGKG5M3/WgkrS+TFpcQbyP1fSJ87W2jpTxcmXH50XZkOAKE20LarS8OzZ/b1tG0qPQ71qDD+qXHHG5g5IHbT/fDWH6jVy3TWu2kyORrMKhM2iH+/aQePzWnGtPw1uXxrzdgneByM/bl64rV4Sb+w2TesM1nWUI7avs8NonPu9Pj2yHyuoHhlY4tm4rV4Sb+o0Ren53D80r54Xjl+qj5XNhw+ujZwKuJ/5Slj9raEqdz8bgD10eRb9RhQduFif9a0i5eDe2CO46m470LZI1HOrSz6QfUp4tKv2MNOqxL2k85fYl1+RYoV7Hk38qUlavTG5h8DQaVSTvEf4tFP5g8aJ8bJPn6teN2hmftsM+Z+O+w9Dlu7OfaAffJB66/Yp2M8YmPZTHx3xtwzYDa29q1kTA5OyXOrhlQndperC530DUzlBONb1tHsOlk7suz1FY111XjUvmXiZ74GMxfuTUuzI/ybpuXcUvpu/Ej0v0RyM+Ug/rR/HfnR6Rtbeg6hn8zN+Xic22Uqze97orrGFGCZfIdR/zWgR93XAvrno5ldCz6Fuggrr1x63EolzEeb/vT/kLjf91HB6G+NTKutWX3LcuaEOr4el+74da6uXyWNpjPUiYf0z/xta9Fpd+xhlz9Rw+XQhg3b+COj5l1kAiTD7fWQdv95+dUcDEe8srNO237TkH0k3b46iqtjx7yzOkK9MN6p+lH6jWMHiiP396Ony6zvQLAvW5se90j5HWQwGMQtRVRJmGMQdwaEqcfTHzOPlxviW+ze2h8OgYZnugYRI9je4A9jsRHHYZ17/dKrTe5mm98lRHTmk8n497eM2SPoLWEaVv75nQ4PXoxHB1O0+O+aFhXnkyC8lxnKU+9uommHyndNAny8VtfmQTtZrivQN5L2s1US7uxjf22163CWDsPci1TvfkEfX3s+dym5gu1qetJm1oAbYqbez5f5bxeMB+Kha93UtsB10m4cXaDJR/b9Th+7SY9mc8zaLsx8fOk3bwoQLvh6sDvihea70idD9hde4kUi7N5THxu389mg3FtiZvXc/Mq07bDPdIeD3zWzeTfCbzK8lOxd7lPx17PyG68V5nrZfOr4onMUfnBq9euXI2VYQCjIOSNAGjie/Ab02mm2iDOdUwe2tF7BmhDikJ6NKgRPwhPteLWCuc64fU+5fS8YJ2QpvfrhH7veeO7byb+GSWFF/Q9b9p4grznbVv8RVkb/06PVyR0g4aG0TKfZCmziX++pczra5T53KJXVWa/+6Tob4zXypRhnDe0DVAMTsaTvWre621PNP1IGSuTIR+/wT0Pg3utuxtyJJzGP4MM7pfD4M4Z32GX3+9OF1quHInjd+9AG4OpHR4+N/GvKpU95IUf9j0K27sHdEN81eTasrHVuYl/FKnzawLUua3/cHcV2XSF04ZMPB8L0sZp/s4bMt+LVAs5qCGD6WyGDMb169SNGjIcT35x6zVk6AzAb4fW84LtmNL0eMI0nF3RRAzrhJ5WoZ0JZ2RrSRm4AXqNjywiPvg4AJj0bT6yM4MirrzeSYyYm/fd9czV1RQf/jwvWF3R9CN1on4K5BPGKq52uKIx0sa6XxuMlZ5rGUnb6xww6SSBxn92WgXzURgwg5w6p3IN8qZOvSv8tv4WtP+gjNoYTO38LsZ8FxhQ4exU9cZsq3jhGm+9gQd/NOi4036dTFhDF4GkC/FYX186WUhkM/nePhwjDa/oF2RHby8mfrgrRin2IpDriVy1ayNhGyCsnYTRnUF8OT4cwyyVCyJ/mn+UiX8NKUM9dclhnTRMLPNCOzdZ3126zG8RB0/2mPjvsyxocBew0nEryIWyOBnCMqJO1G5R6W+tllSo4Ux+pn7GMrzgCXMT96NELrftW10W7rI/o6NaLXl4jF/E85cd5sFdEJD3qnlbH4A3buGJYqzx4VNjcBd0Yruu94JO26IVzWdmg/nMZPIJc+eL5lnLHvtanTtSFxcr4TT+D4k99k2wx6g9h6eGuIVV7vJolL3fBcGob0z875F+hRcE42ldWk5bO6P2GOXZb0Hrx02woIVlbvMqJ+mpfjy6yJe51qWsNpvF9pa87Q2p65m8bZdCm7J9cOquv7qt/AraubmM3a/8xxSrMU38ToL52zoxj/XB7JhSwfwD9B16afxUj89Pu1bGD/UDTV/O2xvaRyUXwwz+leHglz92soyRBS2Tyb/RD1jRvDq9oXUUxkIiVzZbPdOPEOBpYw5rWZ1YHUxYGHW61FJumn+3hVeuHGgDcflMZWRi4i+38EXjmz5M275Ja2S4goQJyjBhq2/6MTuT/3A+YGPkNh3i4QdsqOyv9MHy4Pd08Gv1+A/YaJ15Ysn2mMiU7wDA5eqO+mH7p+lNPC6f9gbzaWfysWEdwGDh2E7jtzPxTTlWkvQjs7ZdaZ8rGF65NbrhtE8jt1kQz9gtLd7QPrjSB8uD37PAz699tjJ54EcxbP1Su4kMBur1FZY8TVm1405gm3j4tuKhJbskXF2VSePHMk0eNO/VIeUddMz320egfHNvpTWyfpjIFlKDg8lYvD/eW8gm+23923YLBbfes5CJb2Qdzgf5MinbbTvc+iHe0tNOwgyP3PphODorkwoif5o/d1Marh/Wu7dlmxsHxTLrh1Tvm749UrrGhsWt9UWA5zEev7eJuszE7yvpMvomYavnLweP8WvxhuqpU4u7/nJjKY4hK5myUj+UG01v4u0+XRnrrVdXdvrIZJEMP3Fbu+fkyr39txpkTnXlWcVKPD89als3b3Ys2rbxY9YmnPtr8kE/zAftBZpPWPvwQfrJcPOhWMaGDHu/36wlhjs2p7Pcm5fGcW+OY7vh3rjGQ2Fc/XDnWLi3hheTZ3St8Bvtgzv3reBiPOO4w3Y47tX7YUDuQ13c+hNdjx+cwudJ1+PpGojf+Yg/kjXFwpTqMnIfosT86No25dXvrMFSmCvsjo9wdjDlE+wj/dxHHY3jbnHBPhLk5gWuj9D+g7cuU8f1AyML3Q8+XEc/uIIph+0jndzhclMObjy4AsKoDl8LYdR+wLeWqK40F7dHID/tuP6KexC2ModtD3cwZd2dbRdvcFjPyC1oGzRl0m3wnwHaINoiyBvKcDjzBoyDetTE30zmDbhvuJKkMZhFgul3Sw/VrdSmQN1q4t8HujWkNTlWtwa5tXsk1gppfp7Hzzua4XYgbr6t1y67Ss/LVmRzR2ZXrlqzLN8CoqRdn1P1GJ/G9ZiwVvBbBvFOKFb/Nt0BuzBit5J8uSOm3BKF7VgSt4SyksnX+LUw8dcA1homneHdtmRDMbhlcYPBpdO/l/ik8ZMVHSZQVrYXWNfWwMJ3vmzv86yrgXU2YNm+3bq+BtZ5gGW7UGZDDay1gGW7NPD6GlinAJbtOMLGGljrAMvvglhNN9TA2gBYND1eAFusgXU9YNH0RcC6sQbWRsCi6W8ErE01sG4ALJp+E2DdVAOrCFg0/U0+6ehQrZ3tIqhwv7UXTwYd6kz+I/UBEk7u3EV4RnY3M7xGmTC6NUzDaD43M/lwWMsFsVYLYl0niLVWEGudINZ6QawNgljXC2JtFMS6QRCrKIh1oyDWJkGsFYJYVwhiXSmIdRVgccf7OJ07vkTarVq94up8aX7hgbPNB/TvNT75T2LSe5A2An6TfLAMjvajNj5O1005x3i8PW7w8INlP7Ns8y1l0mtnOxIY8vHFwFNbk/9IHTm8EvhB+eB4v5zhNcqE4ZLI0oD5SLRx7cycN8Lwg+k9wIowftpxR9C4pbQIhJn80M+2XIivjRh74K+k3fu9TsNtIWiHR/pN/H8QTPwQSr2Xa6+3lJnyw80xTdpm+6APLu9zr4hz21y4vE9tAVxuK5IwKhN03LIrvaclyBYYtheDi+3F6GrUmzQt3crijsHOhzw5fUP9sE/Q9CYel097g/m0M/nYsOYzWCY+d/zDdiyTO5YY8hGP8rFM7sgptx42nGOZRm5zIR4ey+SOQyKWB7/ngl+rxx/L5NrKUh8+Tb612gr3ugFi0a0Cs0anw3H7wcQ/tHQO3dT7cijbotLvWEOuP2k7/hHu1lR/4DUPv6MdlG/uyFFbA7wmMsl4PBOL5/OxVCybi9n6MnfkyMTnjijtx8QPdyulP2b7gAd3BHMlhLWTMMMjdwQzHP3UH0j+NH/u6A4ewaz3WB4NO3eYWOYIJtXx+HpB2LoJX09MlXQNtSFHmhdjQ/UzvNjGJmp74t4H9/oN9woHlqveVziWBsxnQYP5LGDy6WbSRXz+mnzQD/PheK51fOmYqZU0tH37zT3M2n87xH+GvGZ5fOmZO6aBa761jgVgfzXp6bEA27hs4p9C2iceC1gOZabl5NqZKXMbUy7t8FiAiX8m2AYhHbNljwXgWDzydkPwtRN8PSOkV+7itjGAOw4U8FgANnEqTgqHxaZioWG1lkiOK1b/Hs6xAM7csW11c0M3t023nMnX+NV6mwvzQVO61ZKeYnDTEoPBpdO/sz5p/GTFTbe5aSFuU62pgYVDI3cEwmBdVwMLjwXYbpxZVwMLjwVw1/IarPU1sPBYgO2IwfU1sPBYgN93JDVtrIHV6LEAitXosQCK1eixAIrV6LEAzjSwHQvAdHR41S7IVj7dphLcyg98v7rJf6S28jm527byb2J4jTJhuORxE5PPTUw+HNYGQay1glgrBLFWC2KtEcS6ThBrnSDWekGs6wWxNgpi3SCIVRTEulEQ6wpBrN29Zb7SJ/8ok96DtBHwi/pgGRztR+3fIFvm1Fb12zJ/mkxlR7fMhz+uPl+3zM18MMLwg+k9wIowftrRLXMTj3uLhpu7mPj49gVi4La2if8W0t5xW5ubi9m2tW1vAFB+uHku3j7MzXO55Xr6xpB2bSRMsF0Pct/bpvJpLwaXhXYoO25OSO0YfEPM9mYZ7S9oV9VqV7btbJOWLm1y8929Ic9638im6W23Urc3mE87k48Na28Gy8Tn5qi27WxujmrGiiIJkx4r/NoaN88dzna2kdtMiIfb2bT9bvTB8uD3TPBr9ezb2bROl/vwafKt1VZoelubDON71rgd9HNY6g7phpck9xY82jUbQ8o7qF2D36um/Bi+O5mwRrbBC5lEbDBZyMd6kwMDg7HyTdrcmhf1C6Iz9mXih6sXMuw2+A1Ertq1kbCNEEbHPsMjtw1+Q0j8B5E/zd/0NRoft8GD1iWHddIwscw2OHez9UjrGrO+8BvLNnjYvIR8xDGHRxWp4/QJvgVO+2+9b4HT44j1vAVOZY5rLfW+BU4/3dXKxMHtXhP/X5btXu4zhra3wA0m3e6lPON2b7ktlOZLpo2sh7IvKv2ONei47V7bJ/2C7BvV+z3YcMtYfz/AYxZUr+Mx4CIJw23yG0nYFRBG9yHwZtubSBh+yYR7PcyE3ULC8GjxrSQM5/TUcX3Z1IvuDx+cUcHFeB7kSdsN2jFU5xn5ckc+5pFnGmZ4RT9sbzT9FT7pKD/ahXxbbzzc250qNyrbjiZw7We4x4loXp2AJS07W9lsx6i446M2rCBHAilWyMdfynW6wlJuTgdxvHLlwHV6rp/NY2Ri4q+18EXjc2tjJm3IY531FmLuFZThrA8YuR0I8fCWbL9zKxTLg98Hgp/f+oCJzx01XMPwFOSo3YoaWHjWxO/cjF9/o1h41oSTla3dUSw8a8K1O4NV63OpeNaEazMG6/oaWI2eNaFYjZ41oViNnjWhWI2eNaFYjZ41oViNXkFBseq5goKbT2rHrbfTY7bHwt6JSUv3Qug6OL42aOLfQr7acwJ5xtcZqR64xqsOo7bjtcA/3RMzOincV1mC7w+a/DuBV2F+4jbdyx2TD3gsFG/OoOKkcFhsKhYahtuAuLW7FNIN51goN2RcyWDahgxMR2XhMX4tTPzlgLWcSWd4b7WkpxjcRy6w/PgWmPZbxeSNb4FdXOqO2vQ4HZYfuLyoPHAJhDvxTuMgDyZ+lvDgd+K9zadcV/pgXktUTm4aj+kxmFy5VkC5kIflwIOJfzkplzn+4HlD2yv2AbN8itMD5J3zo9g0LYbZ8q2VVj9fTZ4xjGu3qyC+OV7jJ1NsKyb+VZa2sozhgTsa7scDxlnhw8MahgeqWgdXrFzrcyKijTxzqhCrEqtgGYPj54wYdPFMd0Ac89vW/LjTJJ6PH1aDSUs/RJ/LL8uv9jsygmPLFT6ZtXi86/b4AmrXrMeHQvrYlfX4EPdhLnzjhqaNMmE4bQuaz3CPD/nZDdx4hek9SBth/LTTneXxcdXxbCawdsuLlXAa/3aiJ/A4kInT4oNppqUmPnf7D7f0beLfwsSny7kmf2MP3UTCbvFq5819cNHEv7VOXm9j4tMl5JuBV8rfbXXyeu4I87qU4bWbyRt1FC3X7tBRJv9Opoxh6CibXLWrcwpDmzqKk8Jhsf3UAqoinBYcX6z+PZwpzO0kjBMBTmFomW73SYddAv1amPi3AdZtTDrDe6slPcWg6bApcen078uZNEG6zu2Av6j0O9aQiwf+Ro3Jf6S6Tq12g8P7HQyvUSYMlwHuYPK5g8mHw9ogiHWTINYVgljLBbFWCGKtFMRaK4i1XhDrekGsjYJYNwhiFQWxbhTE2iSItUYQ6xZBrKWCWFcKYuFbStwbHH5mlMRbSrf55D+FSe9B2gj4TfHBMjjaj9oyOO0w48IYzz7laYf4X2GW6VohDvIT5O1ftJUWlX7HGnOBTXiT/0i9/Vtr6oV2yC0Mr1EmDMf7mwLmI/WWkrHtIww/mN4DrAjjR8O4Ns595AJ37WhabteO+8CBbcpuxk+6xEExVhYr4TT+Ty1LHNxOsm1qze0W07HY8MPtPOOpLprO2BncyWwTr6P0t42ECfaRPPfGEy1ve7FaFkVGFjQ+yu5GJn6RxMFv1tPx/3oIo3YZPbmOOsTUh25/X5tcHY97yyGI3qJlizJYZxWr81kvmA/FuhryoSc/6G75v3z6He1H1GaOkXAaf8b0CuZ/YYecO/mBF+q2lNLrdpaY65/eyJK7wQS/t0bbAdplXDmp/FBfmPjjCJ+9JT65fkm/u6ddGwkT7JcFrl9SvYf9ktNRND72yyITn84JjMyi3tA+i3Mt7vSR37fTqAzHMPEpHp4Gn0zqyNhDhj86/mwA3tfUyTs3HnF6hl78u72kZyYCDzge+I2BXF1FmfQbfLBaGP5pv8Z6b2Xy5uKbNkG3uYskDtquJv5sUlefmsNjej48rPXheYxP/BuABxN/HtNebHqCtv+NgGni708w8ZLGWpg5H8yFBBNtlaJXcQaTnqqrd7xFe4TK8UYIo7zjuFkk+WPcAuRPw2g7x3w9C7845tbiF8cjE3YEGc96S88dgCesy5O2utyfKU/QulxrKT9imXRt3tD2autDVF6HTecx2+vEPJyxCThbx3zbdAzhw6ZDue+cop1E01I7ibMt/L4zfCzTXzlbgV7ir10bCRNrX/F8jLMVqCzaSb5BZIc6hTvFS+sZbXgaf1WxOsz2UT6psXjV5Grc9TVwLylWx7fZkPr5MhJO459j0eOcDG0y5+ao1A7At9NofWyEMK5NN1t7pfLB9mqThXb1ztexvXLjE9de0Y6r1a5s7dWk1e01b7EdTf7c2gLuU9RqM7hWfAPhgYuPNpCJv9RiVxUZHrgPvQQd4/A4SJAxjvZbKpPTitXlMfGvCqjPTb2EO/eLx7n+UawUY0j/sMlQO5T5JiY+laWRWRTiU/lz/aMIYba3OYKuA9Za30mDrq/1kR6ci1I7Edsrp+tN/Bstul56fMW1EU6uNt3RbG25WXQ9rnFwup5rf3T9Yn4AW8N2IxTXVtYz/HPrYrjuzK2L7bZx3qfubWtYtn6gXb02EtY9d2sMt0aEayy1dMppUI5aOgXXWk38x+vUKbZ2JalTKO82nTIya6PN3a5sOqXedmUbA6kOmgT2o+1DfFw7stlntdqRbW3+ep98aDztOhhc7RaV/sYadLY9mQ5vaP0Krv0EPptn8u9k5BjGnjhXr1Q+eCtVODeAxVI9Hr+fdlVxqGyQD7/+ZNbCtTuP4OAHCukbrHTv7H0+a01Un3NvV+N6wEfI2tkHAbPWzZG2/XWTVuN6k3leKS530xS2gzE+8WnZafxPWOaAnP7k2paJX8uGw9uxgu6vX+eTD3eWgBuXTfzPBZwfjsyefSK+u/fscY3kRhKGe/a0DvDMIddWuZsZsL/StFx/XVcDF8tb60OtaIPTMuE6HLdvvftspUSCayu0vNhWbPMR7aTWhqkcuT1cXNvibtgKaiuZtLqtXFC66ovTJasDlI2bi3L803NLtDy/tewfcvMGbp6BmH+oc93ZNm8Iavty9t5GSzrO3qN5LSr9jcUKDTmTn9E1Yz1/GwL1/N+JHG/bl+c1MoTfxhy3JhIBOYVzo2YiFoH8PI+3TU3+nYwsw7BNOXuA63fh3pgaL1DblLZfapv63eaCN71RvUptzVawnTgdQPXpoSScxu+YUcEc44PpeY3tUzzTU40rvVZnW88KYufZzi2gLeR3RuMyEk7j95RkWut82IjYgPHCbt8jwH0AukeAYzfX/vxuVaUyHOPZz6a1Q/xZpI7wfJhtn2JdnbxvYHjHfo59B/u55D6FdmYPG/XCfCKTZlpT5M57je5TBNunoOcmgu5TPAC6mztrwa0/YHv1Oz88nYTT+GlL+6s1LtW7V4LnoYLulez2MxGxeGJ3r2njx8NteyXcmja3TkXP5FxVan9hyjGdiZVtWlOH9IZq6tpIOI1/Qqm9dpJymL8NfU0gnY0XktlCtjeby6UGs3jjtHamzrpCyD+RyfT1JwZiqXRusJBLJUc6/8GBvoFUfmCwL57qS6ZiuREvfy6Xj6fi6f5MPpXK9feOdP6p3mx6MJuOx/tT8XwqXjN/rQ+OLrVFer5Su5XE1r+A3EQdATzzbOZJVCcIztsGI5Cf5/HzSJN/J/AqzE95HtkC/ER85N1BeAiBn4EI4FN+Whn5mLrsYsIMlnl/kI7HXcC/KSONT59Neup3OdjNXSSueccpwoS1Mn6GZ91OB6CdtpF4+E5TO5OnCRtjCRtrCSvdnFTVBkxYB0m3GtJ1Mpiah3eAPc/VLW1/eEcKtn2K1VUDC28Zpum7AGt8DSy8ZZimHw9Y3TWw8JZhmr4bsCbUwMJbhmn6CYA1sQYW3jJM008ErGgNLLxlmKaPAlZPDSy8ZZim7wGsSTWw8JZhmn4SYE2ugYW3DNP0kwFrSg0svGWYpsf36qfWwCoCFk0/FbCm1cC6GLBo+mmANb0G1krAoulN2m4GC8fnGcR/d4zPJv9O4DWs8XkGI1cqHxwP92B4jTJhqLf2YPLZg8mHw+oWxJogiDVRECsqiNUjiDVJEGuyINYUQaypgliot2qN1xcVd/21jdcmHW27NF4ricON0RTDzx6gtnktu+A04JnLk7MxzbtkaGOafGnYGOCNho0lYV0QRm1M1PsdJGw8hNG5pikPtTFxbkfLhmWlPHI8d0IYnVe0QxiV0TgIo+PHGAij8jPlDmNOPZDrG4z1J+O5bDYdS/dl6plT4xyLpjPjMbbzRcPks9oNxiMMn9x4bPLvBF5l+amMx9xcgZvPGfl0hyOfmE1/dTPyMfxMCIWfWPkLqVEmb8OrGffofJzG7yYypPHps0lP/b4K7ZWbb0QhTDucq3NzJOrXspuwuPkWlZupU61TPg2yoO014vPX4KIf8kjrE/V6l2A+FMusNXD9SdOi0u9YQy6ZMOWYwJTD5E3blVzf6U0H1XUm/04v1L4ct7VhKh+ce0QZXqPe0DZ8W7ESr1b7pvlwWDubFGuLINZDgliPCGJJymurINbDglj3C2JtEsSSLON2QSxJvu4RxJLsj5L1eK8glmQfelQQS7IeJdvq44JYku1rhyDWk4JYku2+WXWOZBmfEsS6RRDraUEsSXlJ2iaS7atZ7ULJdt+sttxmQaxtglgvBFuuWdu9pG0yOqbVh9Wstlyz6kJJW05SF0rWo6S8mtX+ulUQq1ntr/sEsST7tmQfkpSX5Dgk2YeaVfaS+ktyXa5Z14Yk25ek7dusNmYzjh36GfesJMaOiT7Y9Nm2N8zlE2F45vaU6VmTDm9oeSX3lQ3+pJDwTbm5c6i0TCZ/3GM24dxfg4VhJq9OwBIuW9xWNtteNN13pzLww+qpE6uDCQujTqOWctP8uy28cuXoFpRJuyDWGMDi+j+3f2vic+enuXZiOz9t6paeJRSs24Stbrkz2PrMgjmXlcsPrFl80orFHrhWkIOR2zkQz7wH0OIN7Rs9Plge/D4H/FoJHnUjpd+7mXQmXshnhgJ/C83k38nIJAx9OSGgXLnzRhNA5rT/XFusPNO45jyT7d0cbrwJd+ztSwatH5P/SI1nNr2uHdZPEL2u3e3FSrxGdLF2TwhiPSKItUUQ6x5BrJ2CWJJlvFcQa5MglmSb2CyIJdkmHhTEeiG0iYcFsbYLYjVr35aUvaS87hPEkizjNkEsyXqUbPf3C2JJtvsHBLEk28RTgliSbWLU/np+6GjJsfYuQawXgi58WhBLUufcLYj1mCCWZB+SlJfkmNasdmGzjmnNOreSlL1kH5KUl6SOHh07nh9jh+TcSlIX7hDEGl1T2H19SFL2kmV8UhCrWedDkrLfKojVrOuFknbOqJ7YffbEqJ7YfbJvVj0RxP4aR/zw7kXubIPBmlQDC+9epOmD3LNHsc4GLO6Mh0k3xScfet8Id7eedt3e0LJFSn87GHzp80o0P1Mm6kfz72TKGMY+O3dvIZUP7rNPZXiNMmF4poy703Aqkw+H1QM80HY+QvWXGG799YTDj7X+OP1Rb/353WVlwr0mlvmY3SDzMQ3KXLtrirv+cvd64rk/jocpDA9RJr2Jx+UzqcF8JgXMp6fBfHoC5hOG3PA3d7bL1KXpI7SeF5X+xhpzKdO+pgFfNN+Q7i4N3DdN/p3Aa1h9k7ujlsoH++YMhtcoEzYV5BpCfSZ34924gevz+XI3rqm/iYxc8f5QjocZDA9RJv0MSz7TG8xnOpNPB5NuUelvrCGXTKGMTd403z2J/+5onyb/Tm9onYfRPvcEflA+2D5nMrxGmbDw6zNW6GbKgPU5Mxz5Ba5Pk3+nF2r7KtfnTOAH5YP1OYvhNcqEDaM+E4OFeLI3n+6N9WVTvbm+ZCKXSMdyqd5CPJ6JJ/pTmWSyMJjK5DKJZCGRTgx2M2XA+pwVjvxSQevT5N/phdq+yvU5C/hB+WB97sXwGoUw7Yx9F2HCWhm/Fh8sHBMawdLOfEMkxHGgF9u+4Z3mS8u3O/SGyb/TC7Xdx211RuWD7WxvhtcoEzYD0tH6HBmZJweGK/OQbFWrzDl7qR6Za3dHsRIPw1oZvxYL1mZBrK2CWNsEsbYIYt0riLVJEGunINZ2QSzJMt4jiCVZxocEsR4RxHpMEEuyfUn2R8n2JakLJfl6WBBLst2/ENrEA4JYku3rUUEsyTJKyv4+QSzJdr9DEGtUTzw/9IRkGZ8UxJK0J5pV9k8JYo32ofqw7hLEGu1Du0/2knN3yTky3jVG15BwH6zedUma3sTj8pneYD7TA+YzqcF8JgXMp6fBfHoC5jOmwXzGBMxnVG7V+QSV2/Ot/zzfyrNHg/nsETCfPRvMZ8+A+cxsMJ+ZAfOZ1WA+s5h8Oph0i0p/48lkPBbLpeOFXCHZm+5PDMT7kn19hVQh3ZdJ5Qq9qWwunY+nsslEfz4dK8QzebVrmhxM9xX6c4N9Be4b9quLu/7qvrxlZnV5zDdE6Zli+s3OFhJO40+YVcF8oISJ3yz1yHMH4EU8yX2SRODvXZv8O4FXWX4q+zYtwA/KB/dtWhleoxCmHe7btDL5tDL5cFjbBbEeE8R6WBDrXkGsTYJYjwtibRbE2iaItVUQq1nrUbKtSvZHSb7uEcTaIoj1qCCWZJu4TxBLsk3sEMSSlJek/pLka6cglmQ9SvLVrGOHZD1Kyl6yb0uW8SlBrFsEsZ4WxHohjNuSfTuMsdbMlel8znxPfSKk089dENZGwigGDaP8tVn4o+nbfNJhOcx8NKz35wz+uHDwy98EGMvIipbJ5G/ml+0kfsTnr8HCMJNXJ2BJy85WNso/toOxhB9c9+SwxtaJ1cGEhVGnYyzlpvl3W3jlytEGMuH6WYSRifEfZ+GLxp/I5G3SGhl2kDBBGSZsMqR90eQ/nO8pGLkdCPHMnQMt3tA2ONYHy4PfB4JfK8GjbiJgcHoU+7Nf/UZ90mvXbcmnm0lnytdFeJxNwsdBHrO9oTzOtvBI05t4XD6RBvOJMPkgFrdmqt3yYiWcxp9eWjPVZXhmdjXmHIY/rq6M/75M/DkkjuGHk82+AdJp183kZXgy/Xgu8ZfWhTQ/wy/1o/l3Aq9hjUlzgR+UD/aNeQyvUSYM9cI8Jp95TD4clqnPid7Q+sXvr3Dtbo4ln24mn3DbQiKFsqTOhM1nymjC9iNhtH2ga4XftEy6z2bmVnAxHvJDZW54azY5zYGw/Uh8c0+NCdufhJn3roYjw5PqkCGtK8O30anmWzP7lA546LH2RbOq45g7CxaRvarDZlXnMYcpV7c3tK+fBWHzmDCNP7PEj+l7tO3h2Efl3cr42ca+/Xyw2ghWB8Eydxi1Q/yLS/IwbXN/givXNvvSRm4LCE84lhwQUt5BxxKTfzfDj+G7kwlra4DXwmAmloz19eXyfamB3lQhAviGV/RDe2AhE5/7hpCR9YFeKLJOlL+zWKzgLyRy1a6NhB0AYe0kzPCo2/3Ts6v5XxgS/0HkT/OPMmH0Dpx66jLKhJ1blMGi+kACa+wwsSZ51f2J6hxOZ+J5rHp1Jk2/nyWfngbz6WHyCVenJjKcTjWO02H4zc+FPuVHx43ppky6b26vY0ynMje8TfSGygnXb/YHftDPdm7NxDP1QdueYH30o8w9pvwLmTKaMKqTqZzQcfVhyqTr4w111AeVueGt2eS0P4TRNZLzitVhB5Gweu1UKsNvDLNNowzDsWkSWZSTx/B1ICMLlJN+rndOZMqk5bTfvAouxkN+aFs7EMJoWzO8TfT8ddhwx7BJTDm4fHoazKeHySdc2yUxwNW7cVy943hwsE/50XFtwpSp3vGAyhzrndOVEW9ou29l/GzjAfbRcGzhyh01VCdh+Q9mymjCDiFhVE7ouPqgtnM94wGVueGt2eS0EMIOIfFxPDiUhNU7HlAZfmOYbZryTXlv83jb5oLirr/tEP+NZA3jDbCGQdd0TN463u8g3kKG73DrNvg6rsm/0wtTR1bWcQ8Efvz0B6c3TdooE4bfPz+IyecgJh8OyzY+4fsJ9Y5P05h8mq2fT4Mwqg9p+0BXqy9nGuzLzSYnXLei+hDXcaX04UkNjinYboPqQxP/87BuGZL+ik2CctG8uHlMs+vVcOYjdr3K6aF69SqdHzSqV0175OxMfB+rXjtzOpNPs+mL6RAmZWdmXkB2ZjPoVW5sCmoTBrVHLyzu+ov26LPEHv3jLH++5pO8U3tVxxu1R92yR01dTvSGtjG0R+cz+cy35DONyWfUHh3KD5V5s+rN+RDmkj1qeA+qD038qSXd1gz26Hym/OHuRQXXqyb/Tm9oew5Dr3L7Rpwe4vZgTNooE4b2KKe/D2Ty4bDQHqV1hPZovftg05nyhLy/U9feBOWRG9to+0BXaw+nHr3K7U00m5xwH4zqY9SrB5OwRvbBThrm2OQ3R65lE+7P5BFuPcTyQXUXngEKSZeWddcC4Mevr+sz7Oaeo8X51aetGVi2ZPDE/NpVRyzPnZa9evWS7LIjcrmr86tW0dLQHLqZ0mJrwTjmOcr4U4yFNUqBX+qjtbwQsA6sgYVf6qPpDwSsg2pg4Zf6aHqalv5u94byaU4HtgTAwZ7L8XUe8EW1JVozh9TAWgtYNP0hgHVoDaxTAIump2np73ZvKJ8oLxuOpngNvtYVq/mKkfRxwErUwNoAWDR9ArCSNbCuByyanqalv9u9oXyivGw4mlI1+NpYrOYrSdKnAKu3BtYNgEXT9wJWXw2sImDR9DQt/d3uDeUT5WXD0ZSuwdfFxWq++kj6tE86P11GdQPXd9MknGurtO5pmbsZPxxdM8RfcDTLBR1dTf6d3tB6CWN0zXhD5UflgzODfobXKBOGM4N+Jp9+Jh8Oa6Eg1v6CWAcJYh0siHWgIFZMECsuiJUWxEoKYqUEsYwe42wvvMmu3pk3TY8zPVrncjonWX77gY4lxpmwDFNGTvdQvYiOm82ZMunZ3O/rOK1HZW54M3Ki7Xl3yglnmbR9mXHZhL2IhNU7Izbl1TLca34FF+Mhr7Q9ZSDsQCZtuPINvkpn8u/0hraFMMZizobn+rCRXYLhNcqEoQ632Uw0Hw7L2HXcPAJvvYwx+cQs+ezJ8BxyX0ugLKkzYUmmjCaM6nvaPtDV6k/1rNJRmRvemk1OMQij8y1cpaP2ZiM6qZ5VOlpXSYKPMqTx6Jvu3PyZ4yvC4MQgrglrYdLiraw0DG9/5fQH9cP+NpPht5tJh3qZ6oPdoZdN/p1eqONE3KYvObly/SABMuf6SATCaD5JJh8OC20A27gajn0X/IugJv+RGle5cYj7IuhItG+/eo5b+EmFw0/5LU9u/YqzO/TbEGO8oW2IW2tDvnsJvvELYvPguni965YUC9fF6123pFi4Ls7JANcpv19S5lqGn9+rOo5Z0/0yifNF2BXixhAd77sQD9eHtevwhtbP7uj7Jv9O4DWsvs/VI5UPbdtjPXsbo3Xst99wCFNWbPMH1+AJ2zyXF9cmTDyuTXC7kjreDy3xDmLiIYZpv3T/C2+pMHF/UsLQttoV8/l8DYZ2IZ8iCdxm8RRc2Kc1uLUc22mN3Xl6WAKrWU9k4AmukThpcGUd6yrcPoreBTcnSdQuuNr/Pie7bEkuu3rJiuVn5K9ak1+1ug1g5/uwY37jAVWTFcXxLOxq1wJh+0M43Y7iXJCDEbRJ7Y5picl/pA5G1Nq6RzVxMMNrlAmjh1T8hquDmXw4LNNWuJe38KMi9b68NYvhudkOgc6CMGoe0PaBTvKw7OjLW5U4wz0sS+sKTbA5JP6aYnXYXJJuP0hHL6sz+PTyLBOPXlg6BzD2JmFzIWwfEjaP4C+cvet5IsMjXs5lwrRrZfxsl3PN9cHyu5zL1HM7xD+sVMgOb6jc5Nps5XIumym6X0h5Bx1jsA1RfgzfnUxYGJdzBb0cyMTnDu3aLucKxwzkL+eih0q1ayNh+0FYOwmjphtezhXSJXKJIPKn+UeZMLycq96LnrhLEhvFovpAAmvsMLHM5Vx0mmd0Dqcz8TKWenUmTT/Xkk9Pg/n0MPmEq1MTvZxONY7TYXgZy/4+5UfHjfWmTPVexsKN2RO9oXLCy1jqvax2DMOrqY9wlhgSfShzjyk/dwGZCaM6mcoJHVcfpkz1XsbC2UnhjseJNDff9CyymAdhdN6Cl7HQ+XS99qspb72XsdD2tADC9mPSNuuLUuHUt/1FKW6M4NoAjrc0jMqfhtF8FjD5cFiTS8/cC6iok+p9AXUMw3OzXeCIOokuRdZ7YSC9wHG4L6Di2kOzyAmXL6newTk1d0necGRYz5yauwSzmS5dpLJAOennfckzulrLvPVcGEjbGl7GwC0Bc68QoY1ar/6ZxJSDy6enwXx6AuYzt8F85lryoWGoT+u1uccwPHP5zGswH+4DC83UlzgbqdkuMKX1gf1sHpM25BcyA9tI+EJmOHM5+wuZ3DyHG5NMWu4ybezTjVzMjTZS2H3apUuVaftAV6s/ZRrsT80mJ1wz5474SOukemwkWle45U7X040fte3x0jgT/33kYyHvhb2GOSQPumfwH4g3l+G7WfXh3HD4sepDTn/Uqw/byXOj+hDXL2m7wkuL6l3Hmsbk02z9HC8tovqw3nWs4epDri+7ZKM1gz7kxhRst0H1oYn/PdhfDEl/sZcW4VrcqJ0Zvp2JrwA3oldtczq8tKheO3M6k0+z6Qu8tGjUznz+2JlBbcKg+hcvjTPxW/epYEb2qc6b1u0ckveR+/D8m7jajepNWb0paY+auuQ+zon26BwmnzmWfKYx+bhkj46U3qQyb1a9OQfCXJqfG96D6kMTf15JtzWDPTqHKX+4ZxSC61U87zYnHH7iXN3Z9BC3N2zScvu5aI82sjdsm+ejPVrvPH86k0/I51XqPoeB9ig35gTVCfS8ynDn+Ya3ZpOT7bwK6tVGzqtQGZ40zLEJdZKETRiS7gp8iSbqrrBtQk53cX19+Jdo0tMGWFpsLRjHPNe6RHP/GqXAFydpLQfRshQLXxam6fFFugNqYOHLwjQ9fjbF/G73hvKJl/bZcLDncnzhJZpUWwa5dJRi4SWa9V46SrHwEs2RunT0kBp84SWaB5P0QS4KpVh4iSZ3wafBitXAwks0aXq8bMT8xhfPtUN52XA0xWvwhZdo1vvyPsXCSzTrfXmfYuElmrvz0lHKF16iyV2mgOn8dBnVDVzfpZczcG2V1j0tczfjh6NrSJdWBr5E0+Tf6Q2tlzBGV+4CDe5CLSO7PobXKBOGp0a5y2H7mHw4rP0FseYJYh0giLVQEGuBINbBgliHCGKlBLFiglhxQSyjxzjbCy/RrHfmTdPjTI/WuZzOSaaMDqFjiXEmrJcpI6d7qF5Ex83mTJn0bK6eSzSpzA1vRk60Pe9OOeEsk7YvvESTXsxZ74zYlLfeSzRpe+qFsAVM2nDlG3yVzuTf6Q1tC2GMxZwNz/VhI7tDGV6jTBjqcJvNRPPhsIxdx80j8BLNg5l8DrbksyfDc7htIVFAWVJnwriLQk0Y1fe0faCr1Z/qWaWjMsfLRptFTgdDGJ1v4SodtTcb0Un1rNLRuooRfJQhjUcv0eTmzxxfEQbnYIhrwlqYtHiJJg3DSzQ5/UH9sL/NZPjtZtKhXg7p4rPAetnk3+mFOk7EbfqSkyvXDw4FmXN9JAJhNB/bpcMUC20A27gajn0X/FIyk/9IjavcOGS7RDPM9u1Xz4dY+AnpktjybQzc+hVnd9BLNGkb4tbakO8EwTd+QWweXBevd92SYuG6eL3rlhQL18U5GeA65e/IaaHv7VMdx6zp/ojE+QHsCnFjiI73G4iH68PaNesFuiHdfGa9QJe73I9eounXxmgd++03cBedYptfWIMnbPNcXlyboJ+JxjYxh8RbQOL9wRLvACYeYnCXaM6BMBP32RKGttXwEs05XjW+diGfIgncZvEU3Jxw+LGegqPyGe4pOFyTbeQUnORJ5GY9kTEHwkbipEE9l2hy+yjDuERzjg875jdeXGmyauQSzXkQTrejOBfkYARtUrtjWmLyH6mDEbW27lFNLGR4jTJhc8mz33DFfdmew7K9oI6XaM5l8plryWcWw3OzHQLFSzRHXzJ4/r1kQPUgXqJJL7nECxBrXXLZDviHl/xN3c0h6QW3H3LYbkweNO95IeUdVNfiIUDuEglODzdymWQiPzDYl80WkoOF2GC2kI94Q3WuTQ+b+NyBthlM/HAvCktmTbunl0niUbg2EjYPwtpJGL3c6+nZ1fyHY84ls0HkT/OPMvGvKVbi1VOXUSYfvLQxKJa5tJHqadO3OR2DfTEcPRDc7jH5dwKvYdk9c7yhcm1j5Go7dMtdpoMvCdVrj1Aso/dH+iUhyoPgeJ7i7G/jTNh8powmDC/0Nc/ouDHblKmRl4TwQrhmkRP2c+5yWm7aWq/dQ2VYj91D6wovZZvDpA1XvsF1EtoAIenIuE1XcH3YZq9wY8q+5LnR8cnU5URvaN3iCzZtTD5tlnymM/k0W1/DF2yoTqLtA52kTuL6U7PJqQ3Cmk0ncXodeW9n4s6GMBN3QylAz72eKD1zfWS8Vx02m4R1kWeaLz0yYOJrt7zI83ljKZKWSe9cHrPFB5PWjXbUrqd9Urs2EibX1gbjmu83z67wgbqxvVhdJk6fcTaWiW97GYjKKOoNbdeoSzkdN4f4mW0YTp50vUm7NhIWtjwpjyjPfWuUCeXJyZ/KyciIG0/2Bqy9GSwqY5s8DY+7Q56UxyDy5MZBmx1A5WlkxM0Z9gEsTp6zid9JwKtJP4aJT/HaIf7OUiQtm7NmVPM3nqTHttDFYFMdautnnUw5uiGMptW4W2ZW/LUbW6zGfe4v8WsnuM+Vj8aHsA4S1laszqez9LuN5EOxDB/tEP8Ns3f9NR8KGUPSmPRRJv8xkH8V34wfbYOI1cr4mfhapq+cvetZ12Un4Bj5Lyr9jtXpBnv7BgZTvdlYPq5/JvClfcqLzp+TE9UR2hlZ07oYw5StHeK/fXalzO8sPeM6Fs1Px/uYJV7E5+9zGIxfW7Haj6sj2nZNfJN3Z3Eojyasi4RR/aXd+NJvKi+KZfhoh/gfnr3rr6kT2t5M+iiT/zjIv4pvxg/bbhcTv4uJ/9wFkLNLeCU/WnbpOd5zeQI+9UPeTNsJo1/lB1L96YH+wd5YLtYf70/W6ldarx9d0uu29cSgbRnnfhTLrKeaOQ29cFawThIGfyzwJ4QfN3Jq94bKyeQ9LpSyFQpB6oHm3wm8htH+aX6GH5QP7lt0hCOfvD6qZdoe1R9jGNkgH2OBx86QeORsXMMTt7di+NBx3jO/mseWkHgMt48WyvuIdO6/urjr73NHIGdX8qV1Q+fMtN3TsZ3G//HsCuYPS88TCa5Jb/RUFwkfy4Sb36a+Wpi4uNczFmTIyZXGN21yjE9Zx0BZTfxfzt71V/N24gwek8qP8tXig/kbgvnM7GpMaqfb+ryJ38XEp33M8DPRG9o3uyAd5b3Dq3bUj6ufCMTFMZju+42FuGN98kF5cDyMY3BwnERMzBPbg3Y4R2pl8qF9io75HUz+guNDLzdWGmfC8OJ6GkbLPlCsxEPXCr9pmXR5PzW7govxkB+ur0naRsa/nfhjvq0QdwzExf1IymO7AI9RJp8xgDvWwn8EcNqYdN0e3x+5v0H5jTD8cmNNo/lQrMFidT60numYNnlOBRf1eCuT9sZiJZzGnzGngjmt9FxrTENdQsuQK1b8UGejHYt9EteZcOzCOHQcp/H3KpWDjl2oHyiW9tsH5MnZCJzdhzbC4USe+4I8ORtgojdUNtiGOyAvah+b8QVlsJDwsf8c/7yMXLstZdR+B83h41EeaDzE4MZOg8H1a5NuIsMX9j3UHWMseXDjGZdHO4Q1Wj/cuE1tDc6G4cLpeE7zQb8WJn4t+6PTB5vDHcPgcHp+HIRFmDDUYbS8VIehbcLNyahu5PqdX93ZbG+O9yB21RgL75z8qB6SXsuJZWLx2GC6t1CI5/qyA6laaznS+Sd6+zPZ/oFYPFFIJJKZvuGsJdnWSMKZW8bjEYZPbo3E5D9SayRcX7GtkYwNRz4xW/vndL2py3FMGI77dOzl5jucjqM6E8fEC0p9K+oN1XHGtoowYa2MH12DPcsyNkZ8/hpc9EPbkBuTIvCbs/kiBL8d4l81p8L7ZXOqMWvND815ApST3/oC2mgmfq6UL90LREy/cvlhLiHlWgx10s6UQcdb4VP+iGeXadDyt/jweiUp/4k+eg7HhhVQJmovtZN4q3ziaUfnEKug7IbXVo/fg8YPEIY1N0TdFc76967XMql+4MqN+WvqJGWw2WW2NkXxOyG+Sd/m8fMkU4fYpm4m7X9jgH7N2Va2dh2kD25i+jVXx7RdG745e82kqTUfvg3KW0s3Iv8m/t1EhncCX7Rtj/Hhi9Ztlzd0vPO8xvuKbdyi9ixXz+dBfLoWim2Zi2/aKm2b9HwG6jsT/0HSLj5l0c20Th+aw+dN67Sd4RXzfi2p00egTrm5CjfnC2KjUDmfVqzmxcR/nMjBrIHb9nDCPacUZ88pVdlQxepyc+v0NH696/TYtmlbaocwWgc4/2pn8gk6d6RjJ+qRLkt5sf1oGk+wuPgGrx3iP8PoTcSkbY3Kqc0H862k3b8Z+hytx1XFSrz3z+HzpuVvZcpj4ncz5afxxwOvJv47LeXvYspP+bqpWI1p4r+H6WvIJy0Xp3ON/wQmfjdTroneULmYtNy5MxOPyp7DQJvC5NfpDW0T2q0vVvNKsXAv2ta3xzO82up6PJMP1vXHmLqOMuVEu6jWHiH28XYGi44r0mscfam+eCaTzQz2DRb6U4MDI73GMtjfV+hPJgfiyf5cvj/e1yzndWjfGum5QzjrHpW5wzjCp83ORLuB2mfjLPFxXQvx/dYhqX1G1yNw7mDiT9h3118d97tzqjFtZdQObUQ8j4Nx0JaifZPj2c+u+xHRI3hGgdsPo3Yz2mcm/k8tYwanf2xjRi3bx7bHgWcUqO7FOuewafxWr/Y4EGHKadbXtDPjCcUwfawbcBaVfscadDjWtXlDxx7KD9o/z0I7nggytclM0wQmX4NBZdIO8Z8lbehTwIPhrcsb2ta5OsHzOdiuritWh5v4/yjlq3//rfTMnYOg8y3zAgHmTW2M8RZeuxheaZ/ZVKwON/H/Q+T1WR9eKT+UV27uZNrs7pg7Ub3VDjxx+oPGH67+4OZOtjNBqH8jTD62MYbWAxff4GGbHF+qs1prQxGCb8aliUw+fuvhtcYpPCtC0+o8J0E/oGsanN5fWawur4m/hoypU30wjR2gnfncTYT4hXy+OYay4+wGyg+ul+0F5aplD+H6OWev0HHayATtlb1IWzI61rb+TmVJ240nKEtujTICeYdUj/0RyM/Ig/qhTufqZpEMP9Z9SiqfEbLXM/QsN93Puqo4VDbIB65BUxnT8XMB9AXaZzi9Ya6JbYf4BxO9cSDoP1qX3Jksg9Hikyfa6rhupt1KiEOfObuayhP7q4mfIP0V7epaexN+58hofO4sGmdX++3NeD7lCbIvEmS/s58Z+xCTO0+tHcrUxD/MIlPu7JBNprZ1XcoPtzaOdmAtmZp2j7wGlamJf6RFprYz6tqhTE38Yywy5WRkk6nEGfWgMjXv5COvQWVq4p9skSmnz2wyNfFP240y5daqOZ3BrbPgeMmVGddZKeY4H0xOf/mNPX51aTuLauJfYKlLrlzjAparQ6hcHXWWy8S/LKRytfqUq7XOco2rUS60pU38AlMubgzDdVXurDId13Gty8S/gumX3Hza5L075tO0r7UXq8ttswO0Q93BjYm0j+J+I7eOaXsHwdZeIsQP9ykiTD7UnuTmvtgGuPMONE9sAyb+2oBtgNrp2rUVq3leVPKPNeT4NkDbMraBoOcgbeMorodoF2XiG1ufawO4FtHC5BO0DdCzhWYtQvzd7lRyoBAv9KcHkoVYMhMf6b2q3mwskU/FBwZ64/lsf3+hnr2qenQit+6lnblDCnXilpK8Qz57FpvEyDPIOw9c+bAda3e2T/leR+aWW/etnZ/tDD03F2iBMKpDsY648zy2Mpj4OwLqLPoOtnZtxeryLSr5xxpzKU5nUbsWdZbNhtUOdRZ3BoPOD/AdF7pG77dGSrG49xSwnfnZMnTcofFfaVnrpW2+E3inZcf17VYmX9s7r5rPD0F/Dmn9Lc3ZK8ZxZ94jEEb7SQuE4XkNGsadA4owPLTCbyoLzdeHYT/FY7A4PYG6gHsPnNMT9O6/5/grDuVrd/TbRs6+mb4T9YbWG7ZX2gc6IIw7P8CtXWJ+3Jll2geCvFdD1zM/5rMf6DfPQH1t4n+HjDmfhDGHO7thex8PefE8+16a7d1j2/saIa9H90YgP1MO6kfz7/RC1V9x1PdUrrb3ikbqbD7lh6tnvb4/wRtaZ9z7ltw7DVx7tOk2tI843cb1ddQDtK/jOM6t19n6Or1vJIjtyPVj7Oc0/g9IP/6bxXYMsl5v2/cOOk/n6qUDwrgx16bPuXe8TPxaa4/IF7ee63lD865VBlu74+zr3Tim9nJjKi07jqk221Y7rAPu3C5n70YhPpW57V1krl92QVjQfknt0L/5jKW0HEHPstLzFx8jdvbRsBbK3YdJ1yWKxer49AwExqd4uIZkLhfl1mNxXUq7i4tDMZFnbm1FO5y3l+MTHj47f9ez7UwrdxZAsB8E/r6MyX+kvmnBzf+4e2ZDni8N2voBZ/dx58FwrLbto1LcFm/o2ED1Pq7LTyq1LW5N0HxPLsKE2dakNS/j51aXLawz0XjPOp1DUHt/+tzqstD+zu05Gv2BfXHW3ArmnqVn7vyC4bHLs+ssWl4cD7izaK1M2XFOMtuis7h5DuXr4iKPOZdgBjnjwNUftmUa33Z/DLdvxt0tT/vTc9jFoZgh2wi53b3Pg3s51IZCG5z2I1wDtbVV7XAM59ol7Xfia/zxeLzQlxrI9A0mYoXc4Eiv8acK6WxfIR3rTeRS+UQuW88av03GEUbGEy0yDmoPIVbEglXrfUP8BLhfH8R0I2SfBP4kMdonYZ8XrCVXXBvlbAXufVGcA9e7fsSteUpg4dhMsf36BjdnpzLyPN7eobI9tbjrb7j308YGuDmgB2Uez/AcYeJza9j0PtvPE7sf42GeVHbjIYzq+W4Io+MIvtdJx5GJEMatMQbpg9rZ2k+7T7kk8uHGPm68bjQfbr0uzHsTaF1x6yjYv233sHH5RJh8at3FcsVcPk8/GxTX2k38W4jtfeXc6jhGRitInHWl5w6Gd0E90M/tr3ggG6qDcI2euxeA0x/YTun6D7Yt+k43vacXHad3TDyN+dsAeoeTdUhjaVPJOqg8jSx0uv33q+BiPCwHba+mTHQ+aetHNF/sR7eTPrIN+qb0e6A4l+PWjZt1nObqHtvMBBKGbWYiCcP+GSVhVCboatkFQfvnNh8dbPJAHYzzO7+13yvIukCY85v2GlhB5iQ2rKBzpdH5zRDn1PymTRArAuWhsq8196/VnrEN2ubYNN0ItcHAe/zYBiPh8BMPKtfhtkHJdtPsWCN9X4rfmv2HYMwy6fzW7HHeYOJ/nNg7H7Ws2XPvHGI5MU88U8jJn9OBJn6tM9u4J87NW4f7HgUtG95DYuJ/jln3b7Y9+JFcXzcy49bXbec20TZsZTBpmx9dExtdExtdE+P/Bs2nmdfE/lrnmhjqZxN/0rwK5j981sT+Rca/saX4o2tilXjopNbEUNaja2KVOM22JjaV9KO58yrxaT6eN7om9nxaE8N6lloT+ytjw5l4+E4RtePMeSucv/yEtM2F86rjGLxDSZyD5lXzSct9QbE6jDvbrP1+aNFdmhaVfscacumszY4J9z2F1GAQu4LmP1LfPwn6ngJno+KZXWpP3VmsxMOwVsavxYK1XRBrpyDWFkGsTYJYDwhibRbEelQQS1JekmWU4ovTg83SVncIYkn2bck28bAg1qj+GtVfYZZRUvb3CGJJtvvHBLEk+3az9kdJHd2sY61kPd4riPVCGIdeCGWU5EtSrzbruH2zIJYkX5LyekIQa6sglqRt0qxj2mh/3H1lbNZx+4UwT5NsE3cLYjVru39EEKtZ1zoeF8QKU0ebuHRvw9w9oN2a0jPuUXwP9gRCWpfP2c4CmLw7Qso7Avl5Hr8ngPv83DdyO5mwRt45HYgXkvnYwEAqMZDr7evriwC+4RX9cM2y1rfmTHwj665wZD3AnSPrJHLVro2EdUBYOwkzPGrZPz27mv9w9lBTA0HkT/OPMvHxjoWgdTnJq25rtD9y+37mO5jc+STDA933s51T4/Y/6V0Fv5lX4ZWmw3bGnXfEs/qtPv70OQL+NF+a34XF6nS454i8YHlbGT45WbQwsuDOL7QCBu2n9CyqruPn2fnxfFA926znx0O+QyaH7ZHy02x3yERK5y24831+55A9hgeTt1fi5Z/Qd3b3efQx86vTmHRB75Ax8bvmVzA7Ss+j59Gry4b30Jj4k0vy0m2vCc6j5zUfz+fz6GOIvEfPow8t4+h5dL5cEvmMnkf31wHS59FfPJ/PM+g9YSb+OWRse+n86jhGRotInBNLz6Pn0Svx0HF6x8TTmEHPu6KsR8+jV+I023n080kfWQx9c/Q8+vPzPPpiHx1s8kAdbGz9WufRjW6XvgMvnRjszSZ7+2OD+d50ti9dzx14ozZkJc6oDcmXSyKfURvSX5dI25B31WlD+t3z9Uoy9t3jY0NuIXF2jNqQz7mRsCF3jNqQzzkXbMjXkD7yzlEb0necfj7ZkO8MyYa8i/T75/yKlXiCdZgw5WkvVng2smkrVvgeQ/jWbhwJM/EMrx3h8BozvHaW8E3/pHnSsrRAfHxuB7/PkLqkZTTloH4U38TvImEmfivxMzya9juGhHUV68MaB1hjG8AyfEWZ+GOHyReHNQawOhgs6kf3pt5Xqpsw7hbPpvP9qb5kYjBZ6M9mYpl65lW4l1xVPq+67Qj3h8D30hm/kbqXrhX4QfmYZ04HmrS4h6Idnt3g7jvkvj8yUljcfia2hZC+yRL4fjiTf6cXatuM2+TaysiVm2Pjt8/oPBXrjztHwJ2xcgXLpNeOmwea84OcTYsyxf5Ow7i995H8RvKzML8ZB7wuKv2ONeh21zeSJ5bmJTru3+bXzq8Zv5H834BnAEa/kRzs7lsqczw/MtxvJHeW2pmWze78RvJ+JT5CPq/l/DeSFwVYrxj9RnLFcWuopu9EvaH1hu2V9oEOCKN9QOIbyaYP+I2jnI1jeDR1wZ0f1Q7HURP/YOh3IX1rmB1Hqd7H8gnm3cftixjH7cNgn+fGTU4fYJ/n1t2C9nkji3r7PGcH2r6Pa/u+K9cHsH/QPoDjGx0H/L5Rqp15jyUCmJ5nH/u4s5i15tu0T9A9kSP3q+bB5EdtHprW7zvjFxC77Zj9qvnk9lBHvzNe+Tv6nfGh/HD1PPqd8fC/M34J6cdroB9zejQC/HmevQ5tdU7la3gd/c44P0fdjXbp6HfGSRidy63xGUtpOaiexb0trn/SMbq/5GfyDGtdGvcBJfEz8VgM98yF+U+Gu3Y8MBiy3R4z7e2oYgWfm9+0QjxMo8NxvZPGCfOMRCaW6g1XTgPZkO23ZJB+TPPn1p0jPn8NFoaZvEbqm/Rc2Wz7OJL2Ooe1O+vU7/2j5+IUK2EtENZGwsZAGB0L6dx2NomHfRC/c0Pnyf8tVjAOJHgHlZ7DPGNmdHdYOkO7yQz/eG6A7t1ze+pG5tzZi1YIo/vnbcXqfMw5B7OHgViGDzwXsbD0mzu3gPv9NH/c76/im/FDudRzPmBu6bnLq6wZJAmeXx/h9qW5eRW1RUPszwnDK7dvSvWLyV/bkVNLz6tWr7g6f/zyo6/LD65ZvWTF8iOzg5fnPXC4OR0hhfcbmGlBOYxWkp5zukLCNOLTmcrhINMh2r2hC3I0/3aInyn9lj5cUkhn44VktpDtzeZyqcGaH66fWXp22iiOpTIjZRSHZLSmQt7AYo1iTuGYNnxMsSLLY4rVPJk4x5I4x5I42tkMZ+4Q09EQRvvSMRBGlZXJVyvgHq/ybNp9qAN6qd3trgHdDDxGIWvlPLv0vHzF6iWFtUcvv2pNfk0+d9qagWVLBo9Zs3xwl6JetswDh0Z3BH63wG/UyW0MDjqaLkLK0Oy6es/S792tq6eVnh3X1b0jpavDlA+25bB1te1QFadjtV4wi37jPGKwe6Hqw95m0IdmcqDLb/rMLn145NX57Op87pQ1y5YtKSzJX+2BQ60XYfxNTs2utcyosLu1VqL07LjWyo6U1grJAuwL+6gGp7W4KaRpw8cXK7I8vljN03CtxzA1s2oDYcswEWS7PaTt5CSn67glVrz+Muzt9qBbo9xSYyuEtRWHloNbajT1q+PMIvGwbeExCWr9HlesDqOrG6a9P/cqIclrQek55FE6O7oMWYnvtwxZ2jVs6mXIfUrPdBnyIIKHfcX0H2pHGDxtLZkZdLW1tGL1kGU9XKpDw6nFhwmcRuK0s53B9yx5ISaNpwvpgqEWL/0enV42jj+S08tIOPih7xFxhhqnqP2mkN2W9CHviadCnnrHJ/vwrx03vTTvjS/Orz4juzy34spjluSX5YJOI9GNTiuDa6u9S8+Oa6v06GKY3Ukthpmeqp/pzUfaHU2wIxB2DJNvyNPM3pDf3k1MZvjHG8nNh61bmbi0L9ATsly9eIxfxPMfdXB09Ui548lkPBbLpeOFXCHZm+5PDMT7kn19hVQh3ZdJ5Qq9qWwunY+nsslEfz4dK8Qz+Xy6NzmY7iv05wb7CljWFkvZ6n3Tlcqv2XX4XqXfu1uHzyk9j+pwq0uGrGMTIesbVodzume4y3619DvV4SNkqfY1g6VqDnegnNs9f93WDnHNrFDP4Cf74I3xauvKVp90e5SeuVmVJygvjo8Iwwen96lcm123zy793t26ndYrDRvV7VVuVLd7o7odXCDdjrrYhAfRxa7qNjMn2d26zQS4rdvSA26/SZQI+1BmWbfRw422N4lMPExD+9lxJM5xPnH8tsZpnBNInBN84pxI4pzoE+ckEucknzgnkzgn+8Q5hcQ5xSfOqSTOqT5xTiNxTvOJczqJc7pPnDNInDN84pxJ4pzpE+csEucsnzhnkzhn+8Q5h8Q5xyfOuSTOuT5xziNxzvOJcz6Jc75PnAtInAt84lxI4lzoE+ciEucinzgXkzgX+8S5hMS5xCfOpSTOpT5xLiNxLvOJkyVxsj5xBkicAZ84gyTOoE+cHImT84mTJ3HyPnEKJE7BJ85iEmexT5zLSZzLSZxWEmcJibME4oR8NCEdrk5PxG1vGYZ7BCuRiEB+nldtQ3qQf7O9xcgdsYlAWFtxaDlqvc13FImHbQvnD3SOYNov99KAabca/1SS11leNe80TSvk73lD16XDqItMrC8bbruPx+o9HoU3JQSpO+3WkXgjs19SkV04/SQet+2XmLYytuiVXSvImspvdx1nOqX0u5mPMx1beqZz0SOLFbww5lZHhYIfL9/ScHQ4/KcM/jGh4KdiZp3h66bOvDD1Uyy2+26aiseDjsvNcNMUd/Q13KPB8VgE8Ck/ti+UdzBhBou7HZbGH0fKSOPTZ5Oe+uVKf21fTI1AmMfwYPLWTsv8EihbWF8Xwts3uRvluHVBvFFuPeH9CsDk6pHaQbimSm/pwfgUD79Qsrz0V4d/1+Mx/crlh7mK8HJV6ZnTHaYM2m+tx5c/4tllGrT8LT68XutVyv8DH14pP5RXnKfQNPrv9ZZ47Uy8CPDa6vG2vhmvbPp4uO2cuwHN6C68EXNR6XesMZdCfcOVG/PX1EXK0OoN1UEYn2tTFL8L4tOb9jhdijcvm/j3lP5qWd7uw4PnDW3X2lFbyq9dB+mDm0t/ab/m6pi2a8M3d+sc3nZBMbRbVPoba8zFw21riTI+bScROf7LJ4O7wsHPcOeaqC55EPI1p4OD6nATfwfBfLj0zN3KivaE33krE05vvmtUV9Fb8dBumEDScP3M6FATP0rybQUMLr6Zo1HdQL80heONif906a+W+49Lz0Y23A2AWv6v8Pi8aZ2OZ3jFvN9FMF9dep7I5N0NYVTOaCNOYHihcj6qWM2Lif+G0l8th5+Vnrn1D/pStHZtJExyfqH5+CXhA+u/vVhd7okkjGsvtB/QtkHj06+WYdumbWk8hNE6mAD5cDdRcuML119NWk6PRC3lxfajqYdgcfENXjvEf2/pL2eP9pA0XJ9r88H8IOHl/V51+WkddJJ4n/XJm5a/lSmPiT+JKT+N3wO8mvgf9fzLH2XK30PidACmif8JgvkzHz5puTida/wnM/EnMeWa6A2Vi0nLyd7Eo7LnMLqBH5Nfp8e3iS7glYbR/GnZub7dw/Bqq+seJh+s6y+X/nI2WrcPn3780X6PfXw8g0XHlWY/U/Kd0u/dfaZEOv9UbzY9mE3H4/2peD4V7x3p/BOZTF9/YkDt6OUGC7lUcqTz70v1xTOZbGawb7DQnxocGOn8B3v7BgZVJcTy8efEUSt/bl2e2irambV9uvZP41O7kMb/rYmr6PelZ9zXofnpeP+1xIv4/H0Og/FrK1b7cXsCdK/ExDd5dzI8mjD6xUdqR2k3vvSbyotiGT7aIf6/Sr9NndD9DZOe++Ik/YIn5sXlj3sl3Ncuu5j4un7+bPBKf2nZpdein8sT8Kkf8mbajm7XC0sAbp+V6xt0+6xcPDFSZ+XoWTTbWTm/82utJI7f+TUax+/8Go3jd36NxvE7v0bj+J1fo3H8zq/ROH7n12gcv/NrNI7f+TUax+/8Go3jd36NxvE7v0bj+J1fo3H8zq/ROH7n12gcv/NrNI7f+TUdPlJXrIR5noP2MY+UJdxzTMH3S19o55gSJB62Lds5JtN+uXNMpt1q/JeQvI72qnmneLa5drhncXoHQx7HYvXeKN8KYbTu2og8EyCfcN4dqcgnDPlr+djeHcF5hOfx9reR0e46q3RY6Xczn1XqLT2PnlWq6ZLhnlXa9Y6bdseGg18+a3VcOPh5g398GPhq+cGc5aJzej/bIcjYrh3uKeCXRWk+7YL5cF9DDPd8WOUMwTjCJ7ffiftXdM7L7fFjfLTXEL9jZMo75LwX9xVymj+3r+55svpPY4a0r55ph/KacxW6rOdAnnTNH+tIO6qDNI2HOsI4eN6rm+SNMqdp2yH+haW/ugztkWpM7gwZ/YLcUYBp4l9CMMdFeD49z25vGv8JTHy6D2H44b6WOAHS2fYGOWwav9UHB/d+sJwtxK+TwTZtFPdvFpV+xxp0Bo+eDYgwedI9cxp/GfA1CWRqk5mmHiZfuqbdCfn2QL66DXVBGzK8dXm8fsFLy8eEI9sUypHej0HlMAbCTXzbmURO3+t466AsdK7M7eGjLCaEIovEkHZGZcG1D2xn15X+PvfefsRfFmMYWdjm5SNxRqMH+KV6tx144vSf7YutQfVf1Btav/jlTe5MKNVZmA93DgPbnd8ZQIOHY8Otpb/PXWEcqeavnUlPzytOZPLBNHS92DbOcmst9HzTZsCle2TcuGVs/HaI/3uCeW/pOcy1AuUyKAvuvJnJk/IT0hXhMWwzfmdXW71qGZr4D3vVdWHaIq3jdgbHxO9i8qXtGc/FdUG+dAxqZfKg85SQz6LGbHOjkOuxPwL5GXlQP5p/p8fXzSIZfqxXvVP54HyvKxx+Mtp2wS8Za0fn57RuKB94JTyVJx3/nyb+2Gc4vWTWTtoh/qsJ5itLz9xZWnpeFvNs8ckT5zK4vq4d3mFBn7mvqNN2hv3VxH9D6S837wjaRlBn0PicruK+JI7nrGu9N4Pn6036oO/NmPhv8yrl3z/CY7b7lMdPB76TYKJMuXOdNplyts94plwTvaFyxHlWve8i0XOkQWRq4r/Pq5R/f5/yB5Wpif9BghlkfmyTaS37EGVK5Y1zgVoyPbrI8xpUpib+J7xK+VGmnD6zydTE/zTBHGmZ0jLjmoPfuh3Vm/T9UC5dpwWzyweT019jmTLY6pLTaViXXyn95eqSK1dXwHKNFyrX+DrLZeJ/K6RytfqUq7XOcnXVKBfa0ib+D5hycWMYrsvTvszNW48qVudn4v+E5Gf6JTdfp2vC2rUVq8uyqOQfa8jx83Wq99qL1eW22QHaoe7gxkTOzot6fDunYbQOsP659hIhfnjeOsLkQ+1Jbm6NbYC+W8jleVSxEk7jP1v6W6sNUDtdu7ZiNc+LSv6xhhzfBuh4gG2AOx9iGz+4cRTXW7SLev5jBNcGcK2j1tkNWxuge9JmraPZz9y3lQCeb2fud/eZ93rPnD/vztz39xX6k8mBeLI/l++P9+3OM/dTSwC6X04HXdnO5Kfj7WeJF/H5+xwG49dWrPZr9jP3c4kNo10znrmfBXqLll16Pey5PAGf+iFvpu00w7tEO0vPbp/5782P1Jn/SDj4I/YlsaOLFXzONtF20STyPNWrjl/L/sF139ZQ6jvs7+7E+8M6u7oS5BPO2dWKfMKQv5aP7eyq02csyRm89Za6isiVJ8adJY9A3iG182wQG4Xm3+mF2a4q+0ttwA/KB/VMSO9u9OM8nPLTzsgHzyNg3dH5JreuQ3FbID59Nump3/zSX9sdThEI8zx+bYnaK/tA2cI6i9oK+bQK5BPyHcUx3HukeXFnU7Bfh3MuNDF6T6JdPk7dk/ii0l/unkTs1/Xck5iCslHbrtF+Tfmy3RkWhg0d0t2j/Vyb9OT4j3NrhvTM18uIPw3j1oZxnKHxjyWYR5eea51DmOhTd5Qf7p48blzDO+pOJPycW3oO/sVePPXj57iT6dotKv2NNehQQ9A8wj0FE1zbm/w7vaGaJAxtz+3kcNrIyGd8OPKJ0VNC3A4a1g3lw7QXTrN1QBi1WMzsh7Zqrhe1QBjWiXkOMsJgDzPxLyr91ZrrRsDk6sh2OrbWblsHlIf2t/EQxlnJ3MybjiDatZEwydmQls/NhA+UT3sxuCy0q/c0jumr3O1P2A5tN5Zy1j3td3j6id54xrUrPE1v4tM3Bh4B/lqZ9Db+Igx/9YyI2pkVfYP73F/i105wn+ObxoewMN6WNafnm/ltWfOGhAtfmSv9ed7tTjbTjVS3m7iK7iw919od226JF/H5+xwG49dWrPZr9t2xbaXfzbw7Zt6KaMbdMdN2RnfHpHYD+lKju2N2N7o7Vo+LF0Z3x+zyGd0dez7sjiViQWwUmv8LbHesEAF8ys/o7lj9tu7o7lg1X6O7Y6O7Y/TZpKd+o7tjwVzIu2OF0d2x0d0xfze6O1Z2o7tj3ujumHu7Y4nY6O7Y6O7Y6O7YLje6Oza6O6bd6O7Y6O7YMJ3zu2PHlgLc3h1Ljdi7YyGtCifCXQWv7I7hd108b6htiraKScOtophvwDx3/6RXeZ5O8LSj34HBOWNIO0S5kOss3kw7RN7wsePogffTN4Ad88M+Jhy5JHfH3fRhyCeUu+kJ/gnh8B83O4uHlvD+v71r6Y2jCMI1u35g7MQJdhBHJCQkXtLGwYZIHGKwTXyL5Aghbst6ZSyFdeQ4KMeV+CU5ceDGnQv/Ak78ByQOiANuu2v328/ftMdkex9KWlrNzHZNdfWjqqurqnvC2s+9K6dWrt3OfvtZe/9h8+DgsHOw124dt082n+y1T/8+ZuMsO0dcRCEcwzOOgp5rCRxm2siIzqCUgyivI+b82GQsz+k1ore3JLOsU0rPBKYch2WfAeKlsr+rHHpsGqrq0Bumc1DhGsX0dZrW1RE7nlJOWM9DR5SLW3V0E4syo7bBhPUNONahTIZjWpWJYxqW4O5EGvcSHMWqctCzTMN2rtnFsbTVPb8qt8EQx/G3yszoyfOWBM1Vx6PTHdrnR8DLcFwmtt0S5aGD7RrloXPsOuXhMmeZ8pSTvIpMDyklj2ZL6jWMcrCN2FE8P8Ry1JF9Sla9aDnYd2zGx74r6L6q0/mGeH+B6oNzo6t5oT/3SspEVwi+6zKdnY1H1sf5lQ3CeBt9DTD78Z4DQEO6F6+NF0u3M8+Vd5Vr0pPnoXzjY6PRvcD8hLKJeUAdb+p5fEysWXWZhnPsc8DLcJ5UP74Mbf1/2vMPwMtwXA/sN68THumd4lEsl3n0OF5D23QBHssx064j1mWVexPb3+lRcs7fnVQdQPU9jxnkMx4z+EkX5k/8jA+bJzFdpnM8B7wM50n1s5pTUL6zi3BG0IvzBuqHqYCnzGaxyuvUnsnfssqr3jq1bhfbG9uH16kqcJNd0yFtd/twnJdaD48K1/iCrxvrVcfCpAZfq7WCv8s6ckjcf6mgaixnWnD5+yEpfdZtCWr+5DZVZnM1Vl1H5jVwKsTGy/b5QH3CCenlQPOf4jVvkG6jwWt+LKtKQCLWT9mxdkrq91u8BtifK5SnjjovKE99bkDpHNxHKuQrVQeH/yVeQ7l/xXsVWjWaI9IbHwc6/gY6kNYz+ruD9U7pbSFdNSwtdUQ686/if2xzDp/CT+kwPOLjcfZrvIa2WSoG6cMxnwpB5M+x1UW5KmQMdaTf433mAO1PlG3Ek7IfsSxVge9qTcXyEscBtgEnpct6WwS6los+XobzpOQEy4J5UQ8lJ8YfEqn5FnVz5lu1PlOhhzfsYr/xeEUe4FBb5AE+3r6eKE99/gB5oGweVTqO0+h9oY7VD4nnUYf/M17zblzQ8+g8lZ3JL7eh7LuelD2ZeV7Nm0oeMM+rNX5Vnve2uCrPKz2wSsg393tIigeYP5AHeH7DeaDs8w8hoasbcZql5z61YeRlCYn8x2FPf//G+8tCIheLcrii5HqGQ/w30x38b9JDIv3zLJMcElnElyYxJNLHziSERCo7Gs516LN5o+jjQjmCaxl8l9cyDv9e0cd5C8YSy1yWq0oHZ1rMqsU44Ptsfx39Bt/qtqNJ2OCrbCeZbQe9z6grO7Lq57BF7Lpd7DPlE8X500PpqugAap5P6f2j0AGw7KobPdUBBoo/eL37EfDxFvFxKh4p9ekrs2qboLF9nVbVL+z3VutRv389UY6i6zJfFNOlfFEmyr6sDqlxp2xPY1xvrqv15ii34DF/pbbg4XhgOwyWu0h5VfkSbTRbJXMp1gPlLPvHFH/iHO0h6VO+1WHj1VaHdPLxttUdxG92UQbgGMd3lP90O+a9ZrC90vr+Z46fydHvzHfDbLcVQT/rxTfjc5An78b7w07ruP19u3Oy+fjxQGD3WbC3R3cbJfZMF/R8WaT2NESOvhmfxx05ejfeT7nka45K8mWSTBuZLZFS8imLbZ3g+J2Qn5KOozraL9dOiswr1ztVNBgsP7WrhK+Oi/O8rFHt+lB1S0WmDNNSoXCNs0+xrbFPz2C6/bwa5c1A3hzl4SoArfVvAxzzIGs2Kooi4PgA8H0Y7zNrL81xai/+n1u3zbQV2dt8XIdnvB+fJ/nwjHfi/aL1tcI7gK+MR1CPYyumWrll5uc1p1VFgqF88fKDxutHBT85OTpu73a2n7VbT08OjzpfNFvftY0SMh8OzJqVT8xYUYWjDu+rNA1K8afxedxK8TfxfsqV4taolOJMZvX13KEB6lxwxeA+ht1Fg/dOk8PcB5j7JTC7AIO7uUNSyrXTp0wPO5SH/PYl5aXCMZUbC89AD/dvAY0hsfsc8/A0CXZ75DAfoSKRScFdWxH0z0DdQhrVqQ7DrptP2J9BP/KEXdhgP+ZUqLE8s8l176nFSFAIVuJ9q/no0YPjwx+aJ+2dp51W0AmwCoi2JqrI0zlHZSg4FhEsFlgUIPurHeX8Pv+XEl1FydXE+2bp3ZLsea4NoZzMFu2G8ojUqexcOyyUaDdqQxWpqSLTeGyaaF8DGPzsw+eAl+GYHuyHOcCP9VD9pdbbKpJZiW7/fxqjAav2B9oJrtIfZfYL5k2OQFS2h2lYgmzG50k40cGn4mW7OHYLylM7Sx0OZbuyx211z69KnTcb3jQ6S/Tsxmuo60OiWdkJ6qKtqkzNWF9lV5ivULbafcllz5mWQ2URIQ/iNdTfD0lW816d8lTUi+JJr+MkRKROQuReSC5/Mu1mXluAMjPgb6jdIxgNw7uovQ1mxHtFybPyr5bBFgm810Se43T1GOn1eizQFT/DlWNJtZoHv+yrW3C/SvXE9r43JBocn8sQpQvymqJnFyb6iuHTd9soKV3dk4+ZVfjP2/Mm0ZrLj4pRSRnw98ZkrqW1GpP8WSUz3Q88JzGfDpnWZiHoq1OZTCPCKJlXo2c+ObBeAVaNTYxaZfr4PY7Q5P/Y32cC3nE5j86W4MJoVYTnna+5+nBF0OS0/wePr83nQpkaAA==",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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EwAqGBMUHAoKEwIcChEKAgQqEy8RBCoKORMAKhETCi0IAREAAAECARwKEhMAJwISACAnAh4EPy0IAD8tCgtALQoSQQAIAB4AJQAAI9MtAgAALQpAGAQqOxgSACoTEhgnAhIAQCcCHgQ/LQgAPy0KC0AtChJBAAgAHgAlAAAj0y0CAAAtCkATBCo8ExIAKhgSExwKPhIAJwIYAEgnAh8EOy0IADstCgs8LQoYPQAIAB8AJQAAI9MtAgAALQo8HgQqEh4YACoTGBInAhMAaCcCHgQ7LQgAOy0KCzwtChM9AAgAHgAlAAAj0y0CAAAtCjwYBCoQGBMAKhITEBwKOhIAJwITAHAnAh4EHy0IAB8tCgsgLQoTIQAIAB4AJQAAI9MtAgAALQogGAQqEhgLACoQCxItCAELJwIQBBgACAEQAScDCwQBACILAhAtChATLQ4SEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATLQ4LERwKGgsAHAoXEAAcChkSABwKGxMAHAocFwAcCh0YABwKFRkAHAoUFQAcCgoUAC0IAQonAhoEDAAIARoBJwMKBAEAIgoCGi0KGhstDgwbACIbAhstDgsbACIbAhstDhYbACIbAhstDhAbACIbAhstDhIbACIbAhstDhMbACIbAhstDhcbACIbAhstDhgbACIbAhstDhkbACIbAhstDhUbACIbAhstDhQbHAoJCwAcCgcJAC0IAQcnAgwEDAAIAQwBJwMHBAEAIgcCDC0KDBAtDgYQACIQAhAtDgsQACIQAhAtDggQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAtDgkQACIQAhAuDIBKABAuCIBG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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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DWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENsPmkygXFrCCDeyggAoaOEBsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGltjZ6OLYwA76TTgnDbKgETQvGuedTKcSVINaUA+SIA2yoBEUjhKOEo4SjrOtzbGDAvomnI4GHpvQb8n77MkLva0vLGAFG9hBARU0EFvF1rA1bN7WPkPAZ08u7KCAChroNt863tYneltf6MO4TjWoBfUgCdIgr3gcLv5iyu6zFnxaZPdJCT4tcqGACvqS+l7wJr1wBnqTXlhAv9Hl1IIOl99S8EmRCxU8XD5m5JMiF85Ab9HzSPIWvfBYs1PhLXphB33NnDTIgkbQXOTdeZJX9M3mP97ndvUf7zYcBzgD/cf7wmNJffKET3Fc2MAOCnjYfPH9t/uk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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3bziQ7cmb5LnWti+DBaEa9SqMhqNXVjQIKpUa1NMBA0LtPuJG0xcxUMP2P+Pfc1F61d6YtP/ELd5JO/48//c8//49//9//9Je//a9//b9/+sf/9h9/+h9//8tf//qX//1Pf/3Xf/nnf/vLv/7t+W//40+P639Sbn/6x/IPz3/qn/5Rrn/an/5Rr3/2P/1jf/6zPP9YShekJ1x/suQFZUFdIAvaAl1gC/qE+liwKtdVua7KdVWuq3JdleuqXFfluirLqiyrsqzKsirLqiyrsqzKsirLqiyrcluV26rcVuW2KrdVua3KbVVuq3JblduqrKuyrsq6KuuqrKuyrsq6KuuqrKuyrsq2KtuqbKuyrcq2KtuqbKuyrcq2Ktuq3Fflvir3Vblfla/rqNcFsqAt0AW2oA/Ij8eCtCAvKAvqgquyXdAW6AJb0Cekx4Jn5ZwueFbOckFZUBfIgrZAFzwr535Bn5AfC9KCZ+XyuKAsqAuuyuWCtkAXPCuXS3E1QYerDQ5IC/KCsqAukAVtgS5YlcuqXFfluirXVbmuynVVrqtyXZXrqlxX5boqy6osq7KsyrIqy6osq/LVBst1Tq82OMAW9AlXGxyQFuQFZUFdIAtW5bYqt1W5rcq6KuuqrKuyrsq6KuuqrKuyrsq6KuuqbKuyrcq2KtuqbKuyrcq2KtuqbKuyrcp9Ve6rcl+V+6rcV+W+KvdVua/KfVXus3J5PBakBXlBWVAXyIK2QBfYglU5rcppVU6rclqV06qcVuWrDdbHBbrAFvQJVxsckBbkBWVBXSALVuW8KudVOa/KVxusckFakBeUBXWBLGgLdIEt6BPqqlxX5boq11X5aoPVLpAFbYEusAV9wtUGB6QFeUFZsCrLqiyrsqzKVxuUfEGfcLXBAWlBXlAW1AWyoC3QBatyW5V1VdZVWVdlXZV1VdZVWVdlXZV1VdZV2VZlW5VtVbZV2VZlW5VtVbZV2VZlW5X7qtxX5b4q91W5r8p9Ve6rcl+V+6rcZ+X6eCxIC/KCsqAukAVtgS6wBatyWpXTqpxW5bQqp1U5rcppVU6rclqV06qcV+W8KudVOa/KeVXOq3JelfOqnFflvCqXVbmsymVVLqtyWZXLqlxW5bIql1W5rMp1Va6rcl2V66pcV+W6KtdVua7KdVWuq7KsyrIqy6osq7KsyrIqy6osq/Jqg3W1wbraYPU2WC/IC8qCukAWtAW6wBb0Cd4GHVZlXZV1VdZVWVdlXZV1VdZVWVdlW5VtVbZV2VZlW5VtVbZV2VZlW5VtVe6rcl+V+6rcV+W+KvdVua/KfVXuq3KfleXxWJAW5AVlQV0gC9oCXWALVuW0KqdVOa3KaVVOq3JaldOqnFbltCqnVTmvynlVzqtyXpXzqpxX5bwq51U5r8p5VS6rclmVy6pcVuWyKpdVuazKZVUuq3JZleuqXFfluirXVbmuynVVrqtyXZXrqlxXZVmVZVWWVVlWZVmVZVWWVVlWZVmVZVVuq/Jqg7LaoKw2KKsNymqDstqgrDYoqw3KaoOy2qCsNiirDcpqg7LaoKw2KKsNymqDstqgrDYoqw3KaoOy2qCsNiirDcpqg7LaoKw2KN4G7YI+wdugQ1qQF5QFdYEsaAt0warcZ+X2eCxIC56Vm1xQFtQFsqAt0AW2oE+42uCAtGBVTqtyWpXTqpxW5bQqp1U5rcp5Vc6rcl6V86p8tcGmF8iCtkAX2II+4WqDA9KCvKAsWJXLqlxW5bIqX22wXQfzaoMOVxsckBbkBWVBXSAL2gJdsCrXVVlWZVmVrzao6YKyoC54VtZyQVugC2xBn3C1wQFpQV5QFtQFq3Jblduq3Fblqw1qe8LVBgekBXlBWVAXyIK2QBfYglXZVmVblW1VvtqgXmfnaoMDZEFboAtsQZ9wtcEBaUFesCr3Vbmvyn1V7qtyX5X7rKyPx4K0IC8oC+oCWdAW6AJbsCqnVTmtymlVTqtyWpXTqpxW5bQqp1U5rcp5Vc6rcl6V86qcV+W8KudVOa/KeVXOq3JZlcuqXFblsiqXVbmsymVVLqtyWZXLqlxX5boq11W5rsp1Va6rcl2V66pcV+W6KsuqLKuyrMqyKsuqLKuyrMqyKsuqLKtyW5XbqtxW5bYqt1W5rcptVW6rcluV26qsq7Kuyroq66qsq7KuyroqexvsF9iCPsHboENakBeUBXWBLGgLVmVblW1V7qtyX5X7qtxX5b4q91W5r8p9Ve6rcp+V7fFYkBbkBWVBXSAL2gJdYAtW5bQqp1U5rcppVU6rclqV06qcVuW0KqdVOa/KeVXOq3JelfOqnFflvCrnVTmvynlVLqtyWZXLqlxW5bIql1W5rMplVS6rclmV66pcV+W6KtdVua7KdVWuq3JdleuqXFdlWZVlVZZVWVZlWZVlVZZVWVZlWZVlVW6rcluV26rcVuW2KrdVua3KbVVuq3JblXVV1lVZV2VdlXVV1lVZV+XVBm21QVtt0FYbtNUGbbVBW23QVhu01QZttUFbbdBWG7TVBm21QVtt0FYbtNUGbbVBW23QVhu01QZttUFbbbCvNthXG+yrDfbVBvtqg321wb7aYF9tsK822Fcb7KsN9tUG+2qDfbXBvtpgX22wrzbYVxvsqw321Qb7aoN9tcG+2mBfbbCvNthXG+yrDfbVBvtqg321wb7aYF9tsK822Fcb7KsN9tUG+2qDfbXBvtpgX22wrzbYVxvsqw32qw1avqAukAVtgS6wBX3C1QYHpAV5waosq7KsyrIqX23QygW2oE+42uCAtCAvKAvqAlnQFqzKbVVuq7Kuyroq66qsq7Kuyroq66qsq7Kuyroq26psq7KtyrYq26psq7KtyrYq26psq3Jflfuq3Fflvir3Vbmvyn1V7qtyX5X7rJwej0dQCspBJagGSVAL0iALCkcKRwpHCkcKRwpHCsfVKE2dNMiCrsH1x0VXw5yUgnJQCapBEtSCNMiCwlHCUcJRwlHCUcJRwlHCUcJRwlHCUcNRw1HDUcNRw1HDUcNRw1HDUcMh4ZBwSDgkHBIOCYeEQ8Ih4ZBwtHC0cLRwtHC0cLRwtHC0cLRwtHBoODQcGg4Nh4ZDw6Hh0HBoODQcFg4Lh4XDwmHhsHBYOCwcFg4LRw9HD0cPRw9HD0cPRw9HD0cPR1+O9HgEpaAcVIJqkAS1IA2yoHCkcKRwpHCkcKRwpHCkcKRwpHBEO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTtP0c5TtPMU7TxFO0/RzlO08xTtPEU7T9HOU7TzFO08RTvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO08RzvP0c5ztPMc7TxHO8/RznO08xztPEc7z9HOc7TzHO3c5xD17FSDJKgFaZAF9UXezgeloBwUjh6OHo4ejh6OHo6+HD6paFIKykElqAZJUAvSIAsKRwpHCkcKRwpHCkcKRwpHCkcKRwpHDkcORw5HDkcORw5HDkcORw5HDkcJRwlHCUcJRwlHCUcJRwlHCUcJRw1HDUcNRw1HDUcNRw1HDUcNRw2HhEPCIeGQcEg4JBwSDgmHhEPC0cLRwtHC0cLRwtHC0cLRwtHC0cKh4dBwaDg0HN7Oi5MEtSANsqC+yNv5oBSUg0pQOCwcFg4Lh4XDwtHD0cPRw9HD0cPRw9HD0cPRw9GXwycuTUpBOagE1SAJakEaZEHhSOFI4UjhSOFI4UjhSOFI4UjhSOHI4cjhyOHI4cjhyOHI4cjhyOHI4SjhKOEo4SjhKOEo4SjhKOEo4SjhqOGo4ajhqOGo4ajhqOGo4ajh8HZ+9Wr4VKdJKeiatv14OBawggI2UEEDe6BPxJ+YQGwNW8PWsDVsDVvD1rApNsWm2BSbYlNsik2xKTbFZtgMm2EzbIbNsBk2w2bYDFvH1rF1bB1bx9axdWwdW8fWw+aTqRYmMIMFrKCADVTQQGwJW8KWsCVsCVvClrAlbAlbwpaxZWwZW8aWsWVsGVvGlrFlbAVbwVawFWwFW8FWsBVsBVvBVrFVbBVbxVaxVWwVW8VWsVVsgk2wkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiI0uKYwMVNLAHjiwZmMAMFrCC2ASbYBNsI0vqhSNLBiYwgwWsoIANVNBAbIpNsSk2xabYFJtiU2yKTbEZNsNm2AybYTNshs2wGTbD1rF1bB1bx9axdWwdW8fWsfWw2eMBJjCDBayggA1U0EBsCVvClrAlbAlbwpawJWwJW8I2ssQcE5jBy5YejhUUsIEKGtgDx+IDAxOYQWwFW8FWsBVsBVvBVrFVbBVbxVaxVWwVW8VWsVVsgk2wCTbBJtgEm2ATbIJNsDVsDVvD1rA1bA1bw9awNWwNm2JTbIpNsSk2xabYFJtiU2yGzbAZNsNm2AybYTNshs2wdWwdW8fWsXVsHVvH1rF1bD1sPtlwYQIzWMAKCthABQ3ElrAlbAlbwpawJWwJW8KWsCVsGVvGlrGRJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0t6ZEl+RJbkR2RJfkSW5EdkSX5EluRHZEl+RJbkR2RJfkSW5McDW8KWsCVsCVvClrAlbAlbwpawZWwZW8aWsWVsGVvGlrFlbBlbwVawFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFZtgE2yCTbAJNsEm2ASbYBNsDVvD1rA1bA1bw9awNWwNW8Om2BSbYlNsik2xKTbFptgUm2EzbIbNsBk2w2bYDJthM2wdW8c2sqQ4FrCCAjZQQQP7wjSyZGACM+hPHd2xggI2UEEDe+B4xhmYwAxiS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYyvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1iE2yCTbAJNgmbT1wbS2GNxKyOfh02xx44snFgAjNYwAoK2EAFsVVsgk2wCTbBJtgEm2ATbIJNsDVsDVvD1rA1bA1bw9awNWwNm2JTbIpNsSk2xabYFJtiU2yGzbAZNsNm2AybYTNshs2wdWwjG/0yG9k4sIAVFLCBl21cnp6NE/tCn+O28LLl6pjBy5bVsYICNlBBA3ugZ+PEBGYQW8KWsCVsno3ZHA3sgZ6NExOYwcvmS9z53LeFAl624kfHs3GigT3Qs3FiAi+br1VWxhKUAysooNt8y8ZSlAMtcKw5mRy9WHe8/lod//b6a9XPm4fCxB7ooTAxgRm86la3eShMFLCBbvNt8FCYeNmutX6yT3RbmMAMFrCCl02aYwMVNNBtfvg8FCa6zTfSQ2FiASt42ZqLPRQmKmhgD/RQmHjZmm+Oh8LEAlbQbb6RHgoTFXSbX30eCgM9FCZW0Iv5XoxlKf0iGAtTXsXqWJpyYAIzWMAKCthABQ3ElrAlbAlbwpawJWwJW8KWsCVsGVvG5q1bzbGAFRSwgQoa2AO9dU9MILaCrWAr2Aq2gq1gK9gqtorNm//1Tmn2SXALKyhgAxU0sAd6KExM4GW73iHNYzbcxAoKeNls/DUFDeyBHgoTE5jBAlZQQGwNW8PWsCk2xabYFJtiU2yKTbF5KFwT2vOYDTfQQ2FiAjNYwAoK2EAFsRm2jq1j69g6to6tY+vYOraOzbOkX7EyZsNNTGAGC1hBARuooIFuu343x7w3j7Yx761XxwoK2EAFve6o0AM9NSYmMIMFvG7tH9lRwAYqaBf6pl+pMfFKjYXpQt+yKzUWFtBtzdFt6ui27qiggT2wPsAEXjZ/LPF5bwsrKGADFTSwB16psTCB2ASbYBNs4nV9j6UHtgeYwAyWQHX0A6UVdIWfQmXTlU03Nt383/qB6g8wgRksYAUFbKCCBobNJ4QtTGAGC1hBAa+6+WqmPskr+wLRPskr+w29T/JaWEEBG6iggT3QV4yemEBsGVvGlrFlbBlbxpaxFWwFW8FWsBVsBVvBVrAVbAVbxVaxVWwVW8VWsVVsFVvFVrEJNsEm2ASbYBNsgk2wCTbB1rA1bA1bw9awNWwNW8PWsDVsik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbAZNsPWsXVsHVvH1rF1bB1bx9ax9bD5JK+FCcxgASsoYAMVNBBbwpawkSVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlvTRIMXRwB44GqQ6JjCDBayggA1U0MAe2LF1bN4gffDGZ0otrKCADVTwsvmnh3ymlGPxmVILE+i25ljACrpNHRuooNvMsQd6g5yYQLd1x6uuf4XG50QtVNDAq27N/rWeq24tjlfdazSq+JyohQWsoNt8j73pTVTQQLf5vnl7q7693t7EN8fbm3/TxCdCPXulHAVsoIIG9kBvbxMvm/hR9/Y28bI1F3t7myhgAxU08LI1Pw7e3iYmMINu883x9jZRQLf5lnl7m2ig2/x0+2+3+jb4b/fEDBawggJetmu4qvhEqIUG9kD/7Z6YwAwWsIICYlNsik2xGTaPCvVr0qNiYgH9KvEryqNiYgMVNLAHelSoH1+PiokZLGAFBWygggb2hT4RamECM1hAr6uOChrYAz0UJiYwgwWsoIDYEraELWHL2DK2jC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKr2Cq2iq1iq9gqNsEm2ASbYBNsgk2wCTbBJtgatoatYWvYGraGrWFr2Bq2hk2xKTbFptgUm2JTbIpNsSk2w2bYDJthM2yGzbAZNsNm2Dq2jq1j69g6to6tY+vYOrYetvx4gAnMYAErKGADFTQQG1mSyZJMlmSyJJMlmSzJZMn4AuY1eF7GNzAn9sCRJQMTmEFXVEcBG6iggT1wBMjABGawgNgKtoKtYCvYCraKrWKr2Cq2iq1iq9gqtoqtYhNsgk2wCTbBJtgEm2ATbIKtYWvYGraGrWFr2Bq2hq1ha9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshq1j69g6to6tY+vYOraOrWPrYSuPB5jADBawggI2UEEDsSVsCVvClrAlbAlbwpawJWwJW8aWsWVsGRtZUsiSQpb4HMPn6Xc0sAd6llxTborPMVyYwQJWUMDLZm7zLJlooNuu21tfb29hAjNYwAq6TR0bqKCBPdCzZGICM1jACmITbIJNsHmW2HV761MTFyYwgwWsoNu6YwMVvGzX3JniUxMnepZMTOBVt/uJ9XzofoY8Hyb2QM+H7mfI82FiBq/t7eOrrRUUsIFu8x3yfJjYAz0fJnpdP3ze5q+pMcUX1FtooB/f8Z3YB5jADBawggI20G3d0cAe6G1+YgIzWMAKCthAbAlbwpaxZWwZ2/iE9sOxgQoa2AP909kTE5hB6vontCcKiK1gK9gKtoqtYqvYKraKrWKr2Cq2iq1iE2yCTbAJNsEm2ASbYBNsgq1ha9gatoatYWvYGraGrWFr2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGrWPr2Dq2jq1j69g6to6tY+th8zmGCxOYwQJWUMAGKmggtoQtYUvYEraELWFL2BK2hC1hy9gytoyN1PCZhwuxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVCljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpI0uyo4E9cGTJwARmsIAVFLCB2Aq2gq1iq9gqtoqtYqvYKrYRIMmxB44AGZjADBawggI2UEFsgq1ha9gatoatYWvYGraGrWFr2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGrWPr2Dq2jq1j69g6to6tY+th08cDTGAGC1hBARuooIHYEraELWFL2BK2hC1hS9gStoQtY8vYMraMLWPL2DK2jC1jy9gKtoKtYCvYCraCrWAr2Aq2gq1iq9gqtoqtYqvYKraKjSxRskTJEiVLlCzRkSXF0W3NUcAGKmhgDxxZMjCBGSwgtoatYWvYGraGbWSJOiYwgwWsoIBuq46XLQ00sAd6lkxMYAYLWEEBG4jNsBm2jq1j69g6to6tY+vYOraOrYfNZ2AuTKDXFUc/F+ZooFe4+hR8VuXCBGawgBW8tveaJVN8VuVCBQ28bNm3zPNhYgIvW/bt9XyYWEG3NccGKmig266rxOdPlux77EkwsYICXnWvt7OLz58s19SY4vMnn/2gjlfd4tvrSeDzYXz+ZPGZLz5/cmEBK3jZfBKMz59cqKCBbvND7c2/+uZ48/eJLT5psvjEFp80WXwuik+aLNV3yJv/RAUN7IHe/Ccm0G2+Dd78J0pcXN7mJypoYA/0Nj8xgRksINevYlNs3ubFD4m3+Yk90Nu8T7nxmZILM1jACgrYQAUN7IEdW8fmbd5n6vhMyYUVFLCBCrrNj7q3eUefKbkwgZfN5+/4TMmFFbxs14vlxWdKjqjwmZILDYyE6ekBJjCDBayggNgStoQtYcvYMraMLWPL2DK2jC1jy9gytoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Co2weYB0opjBv0qGX+gggI28LJd6wgUnym5sAd6gExMYAYLWEG3mWMD/TfLr+oxwOF/dgxwDPS64w8UsIICNlBBA6+98IlZPp1zYQIvm3rD8dSYWMHL5vPPfDrnQgVjKGNM5xw4BkMGJjCDBayggA1cAyd1TNy8hn/qmLg50feiOBawggI2UEED/ZjJhZ4PExPotuZYwAq6rTo2UME1XFXHdM6BY4hkYAIzWMAKCthADfQkuOZ2VJ/DuTCDBfS98EPtSTCxgQr6RF4/AWPOtOOYMz0wgRksYAUFbOCzrq/YUn22ZjHfIW/zEzNYwAoKeO2F+RnyNj/RwB7obd78kHibn5hBt/lx8DY/UcDLdo1ZVp+tWcaV6vcP3a8zv38Y6PcPExOYwQJetu6XkSfBxAYqaGAP9CSYmMAMFhCbYTNshs2w+f1D9yPp9w8TE/i01YcfnSsJFlZQwAYqaBe67bp/GOizNRcm0G3iWMAKuk0dL9u1tl71OZwLDeyBVz4sTGAGC1jBy5aSYwPdlh0N7IH5AbrNNz1nsIAVFLCBChrotusM+RzOhW7zo1MyWMAKCvhU+Npu1Sdu1mt1geoTNyfWB5jADF4KTwKfuLlQwAYqaOBly75vV4AsTGAG3eZ7LBUU0G2+b6KggW674sonbtbip/sKkFp8c64AWVjACgrYQL9BvsiTYlAKykElqC4yL+5nwQRsoIIG9sD+ABOYwQJi69g6to6tY+th85mTCxOYwQJWUMAGKmggtoQtYUvYEraELWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DK2gq1gK9gKtoKtYCvYCraCrWCr2Cq2iq1iq9gqtoqtYqvYKjbBJtgEm2ATbIJNsAk2wSbYGraGrWFr2Bq2hq1ha9gatoZNsSk2xabYFJtiU2yKTbEpNsNm2AybYSNLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpbIaOjN0cAe6N2R6pSCclAJqkES1II0yIL6ohaOFo4WjhaOFo4WjhaOFo7RrM2xB45mPfA6hNcyA9VnTy68DuE1Glt99uRCARuooIE90Jv1xARmEJthM2yGzZt19RPmzXpiD/RmPTGBGXSbOFZQQO98dNIgC+qT2uh4dEpBXrE5+paqo2+pOfZAb6QTE3htqXgxb6QTKyhgA71728mCLtc1gFx9JuTCBLqrOBawgu4SxwZeeya+k95EJ/ZAb6L+R72FDspBJagGSZBX9MPmP97iu+I/3tfIcPV5jQsrKOC1pc130Nv0RAN7oP94T7xsLvPf7kEl6FL5VvkP96AWpEEW1Bf5b/Y1VF19ZuPCDArom+kH3xvsQG+wfmi9vQ7KQddWNj963lonCuhHxLfFW+tEV/neeWsd6K21+YH01qp+eXlrVT9O3lp9UMunKi4UsIEKGtgDvbVOdJtvr7dWH1jzqYrVB6p8UmL1cSiflFjVN9Jb5sS+0CclLkxgBgt4FbOHo4E90BvqxARmsID+164D5ZMHFyYwg/7XsuN1JK/3AqtPHpTq1II0yIL6oqu5TUpBOagE1aBwlHCUcJRwlHDUcNRw1HDUcNRw1HDUcNRw1HCM1jbwKuPH42pukySoBWmQBfVFV3OblIJyUDhaOFo4WjhaOFo4Wjg0HBoODYeGQ8Oh4dBweFvz0Uefyrcwg9cV4sOIPpWv+kCkT+WrfVS4LlgfJfSJePV6cbH6RLza/c/679rEBl4754NqPhFvYV/oE/EWJjCDBayg28yxgQq67do3n54nPgDn0/MWel3/s6mCAjZQ+WsG9sD8ALFlbLmAAl4KN3i7G2RBfZG3u0EpyIt3xwJWUAO9Tfn4oM+7Ex8U9Hl3CwtYQQEbqOC1rT5q6PPuJsoDdFtxzGAB3SaOAjZQQQN7oDfCiQnMYAGxNWwNW8PWsDVsis3bow9i+my8hQX0un6i1Yv5ebME+ub4GTJvtH6GrIEKejb4Ubce2D0dfHO6V7hsPnlNrtmZ1SevLWyggl63O/bA9AATmMECXnV9NNKnqS008Krrg40+TW1hAjNYwAoK2AL9sr/mmFafZLZQwAYqaKBv2XUh+iSzhQnMYAEr6Lbq2EAFDXTbdbJ8Opn4w55PJxN/hvLpZAsFbKCCBvZAbwx+T+7TyRZm0G1+3rwxTBTQf0L96HhjmGhgD/TGMDGBGSyg/1z7MfMfKL8H94lj4veWPnFsYQYL6Fvmu+ntYqKBPdDbxcQEZrCAvmV+dLwNTWyggjZRfLaYXDN7xWeLLbyKXQ9K4nO95Hr8EZ/VJdcvsfisLrmeecRndS18iq97ZfFJXZM0yIL6oqslTUpBOagEuaQ6CthABQ3sgf7jMzGBGfS64ugVmuO1qX6krqY1KQXloBJUg7yib7+3qokKGtgD/Ydnoh9mL+btR/zsePuZ6BWc+iJvPYNSUA4qQdcxbX5mveVMbKCCBvZAbyPNLwhvDc2vgusHQ8d/1yALev519SvrajWTUlAOKkE1yCW+8d6MJmqgN5iJ1342P4feNCYKeF2ifhCvljHJgvokny81KQX5jqtjASsoYAMVNLAH+g/WxARiS9i83Y3N8du9iQ28bH7QfbbUwst2TVwVny0l14xO8dlScj1Mis+WWljAy6Yu9gY48bJdj5jis6VEXXw1wFm2L7qa36QUlINKkN9LPhz9xtE32n/WzP+A/6xNzOC1pddDkfg0qIUCNlADvamZ76A3tespQnxqk5jvoP+ATWygggb2QG+CExOYQbf5gfNmOFFAt/nh9GY40cAe6D9g3Y+Z/4BNzOB1eH3Xrt+vSRJ0tVc/Bt5eB1lQX+TtdVAKcomfI/+Nm1hBAS3Qf826X4T+azbRK/j59CY7UcBrS32XryY7yYL6JJ8gNSkF5aASVIMkqAVpkAWFI4UjhSOFI4UjhSOFI4UjhSOFw1voNUlUfDbUwgT6IWuOBaygHzJzbOAVc9fLg+KzoRb2wKuNLkzg9Rt3vfYsPhtq4fUrd71+KD4bqj18y67W2675ouKzoRYa6DbfSP89nZjAp83ccDXpSTVIglqQLhKvqI6+pb7b4lvqR1YEbKCC15Ym3+2rNU+8WvPCBGbw2lQ/FldjbmngJUu+11djXnjJkm/j1Wz9uh6flR1H0D8LNzbGPws30cBru66HKfF5SQsTmMECVlDABipoILaOrWPr2Lrb/ID0CgrYQAVtoU9GGsdhfDV2Ygb9QJljBQV0RXZU0MAemB5gAn2H3JYK6DtUHAVsoM/kfTga2AP9C3ETE5jBAlZQwAZiy9gytoKtYCvYCraCrWAr2Ao2b8rXk7r4ZKSJ3pQn+pFsjhksYAX9SKqjH0k/heML1H5QxxeoB/ZAb+bXQ7v4ZKSFGSxgBQVsoIIG9sCGrWFr2MYXqP3aGV+gHihgAxU0sAeOL1APTGAGsSm268e8FT9DV4AsVNDAHugBMjGBGSxgBd3mLdYDZKIGelRM9Ap+3jwUijcnD4WJDVTQt9evKL8Td/QJRgsTmMECVlDABipoILaELWFL2BI2z4erJ0R8gtFCt5mjgga67bqMfILRwgRmsIAVFLCBl+0aYRWfYLSwB/pP/cTLdvVuiE8wWljACgp42a6uB/EJRgsN7IGeDxMTeNm8Z8EnGC2soICXzbsefILRQgMvmz/I+wSj5s/PPsFoYQYLWEEBG6iggT2wYWvYGraGrWFr2Bq2hq1ha9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshq1j69g6to6tY+vYOraOrWPrYfMJRgsTmMECVlDABipoILaELWFL2BK2hC1h8yzxriCfYLTQbd2xB3qWTEzgZfPeGp9gtLCCAjZQQQN7oGeJd/34BKOFHlfJsYICukIcFXSF77EHyEAPkImu8J33AJlYQN8h32MPkIkNVNDAHugBMjGBGSwgtisq/H7eZypN6ouunOi+B1dMTMpB3tP5cKyggA1U0EDvU/Uj6yExMYF+G+1/djxvDKyggA1U0MAe6B+nnphAbIbNsBk2w2bYDJth69g6to6tY/OQ8K4un660sIH+MOanx0Nioj/5XX/ApywtTKA/+aljAd1WHQV0mzgqaKDv2yX2CU4LE5jBAlbQ6143HG10p/vmjP50c8xgASt4ba93uvm0pYUKGtgDveF7R5rPW1qYwQJWUEC3+TZ4Bkw0sAeO/vfumMAMXjbvX/KJTs07S3yi08IGKmhgD/QMmJjADBYQm2ATbIJNsAm2hq1ha9gatoatYWvYGraGrWFTbIpNsSk2xabYFJtiU2yKzbAZNsNm2AybYTNshs2wGbaOrWPr2Dq2jq1j69g6to6th00fDzCBGSyg28RRQLc1RwUN7IF+E3EtBS0+r2phBgtYQQEbqODV9eiR6dOxJmYflEmOGSxgBa+uTe8Y9ElYCxU0sK+M8olYCxOYwQJWUMAGauAVFd4f55OvJuWgq7du/LkaJEG+/eMPKmhgD5QHmMDL5Kf8yohJNcgP1cAGKnjdPPgZ8JsHJ795GJSCclAJqkES1II0KBwtHBoODYeGQ8Oh4dBwaDg0HBqOMeTnl/sY8xuYQL++/PCPYb+Bfn35FWoCNtCHF11hBvbAKwwWJjCDBazgZfOeXZ8DtlBBA912nXefA7YwgRksoNuqo4ANvI5jdrKgvuhKgkkpKAeVoBokQS0oHCkcKRw5HDkcORw5HDkcORweAt7h7VPC9JooJD4nbGEP9JHBiQnMYAErKGADsRVsBVvFVt3WHTNYwAoK2MDL5n2ZPodsYQ/0gJiYwAwWsIICNhCbYBNsDVvD1rA1bA1bw9awNWwNW8Om2BSbDzB6n67PFrvWrRNfmW2Qt/8yMIEZLGAFBbw20TvdfF7ZQgN7oLd/74rzhdkWZtBtvrXe/icK6Da/XLz9TzSwL/SF2dT733wJNvXuNZ/FtlDABl51vU/NZ7HpNbtIfBabXi9giM9i02vykPgsNvXeM5/Fpj6Hx2exLayggG7zLfMBx4kG9sDso7zJ8VL4zB6f0KbeveYT2tRnkPiENvXuCZ/Qps13yFv8RAN7oLf4iQnMoI9X+zZ4i5/oCt8cb+YTDXSFb6Q384kJzGABKyhgAxU0EJtg82buPRU+O25hASsoYAMvmz+y++y4hT3Qm/nEy+bPsj47bmEBL5s/iXaaeaeZd5p5p5l3mnmnmXeauc+OW1jACmJTbIpNsSk2w2bYDJthM2yGzbAZNsNm2Dq2jq1j69g6to6tY+vYOra+bM2n2i1MYAYLWEEBG6iggdg8Na4uhuYLsy30q2T8gQJWUMDLdk1JaD6Jb6GBPdBTY2ICM1jAy3b1IDSfy7fQ9y05XnXN0aNiYgIzeNW9hv+bL8y2UMAG+kC/ORrYA8eUhIEJzGABK3gdnevZovmMvoU90PNhYgIz6NtbHb2Cnyxv8+bnwtv8xAR6BXUsoB8H3zJv8xMb6Nvr58Lb/MQe6G1+YgIzWECf3+Kn0Nv8xAYqaGAP9Nmz3c+Qt+5xHLx1T+ToeOvufua9dU80sAd6657oU3Rc4a17YgEr6HvhtjHfaKCCbvMTMKYcXZjGnKOBblPHDBbQbcXRbebotu54zWm5HsObTxRc2AOvdmzXs3fzKYELKyjgNVXmevZuPvlvXFw++W9hAjNYQZ3T5Foa73UM7IHjzQ7f+fFqx8AMFrCCAjZQQQv0J/mHHzN/lJ9YwAr6zlfHBipo4Jpl2OZswIEJzGABKyhgAzWwrVmpbcwGnOh7MbCAFRTQ98KPQ1PQwB54Nd6FCcxz4mvz2YALKyhgAxU0sAd6452YQN8Lv9ZNwAYq6HvhLcB6YH+ACfS98HM85vcOrKCADVTQwL7QJwfa1anQfHbgwgoKeO3F1VHQfIbgQgN74PUjvDCBGSzgZbs6FZrPFFzYQAXdlh17YH6ACfSp377pPltwYgUFbKCCBvbAMaF+oNcVR98LP6hFwAb6XlRH3wt17IHeeTcxgRksYAUFdJs5el3fSG/H16T+5vMALftRlwYqaOBVwe9LfB7gwgRmsIAVFLDFNvis3okG9kCf1TsxgeyFt+OJFfS98DOvvhd+1LUH2gNMoO+FnxYrYAV9L/wcezueqKCBPdDb8cQEus23txewgm7zs9kbqKCBfaFPIFyYQLeZYwEr6Lbu2EAFDeyB3ronJtA7mh+OBazgZbve3Go+gdCuGU/NJxDa1W3RfAKhXR0UzScQTvTWPTGBbvO9yG7zbcje3ey2q3UvbKCCl6365lyt267+h+YTCK36ll2/6AszWEDft+QoYAMV9GvdbT6/f6DP75+YwAwWsIICNtD3wo+kPMAEZtD3wo/k6KIfKGADFTSwB3o+TEyg1/UL0ZNgYgO9rp9C/0Wf2AP9F31iAr2un25v8+Jn09v8xB7obX5iAq/j6+HoE/0WVlDABipoYA/0t3AmXsdX/Mx7654oYAN9L65T6FP67Op5aj6lb2EFvUJ1bKAGetv0nySfvGdXL1XzyXt2zZxpPnlvHAefvLdQwAYqGMfXp+mZ/wD6NL2FBaygH8nx1xqooIE90H9jJyYwgwVsc1GMNlb8mmjgdT1cXWnNJ+QtvPbC74J8Qt7CAl570fyg+m/sxAZeR8fv+3xC3sIe6K1wYgLd5kfHW+HECgrYQAUN7IH+e6x+SMY6Ib4X3rLU99hb1kBvWROvLVM/UJpBHyv0Ct7eJgp4bZn6cfBWONHAHuitcGICM+g2v2j9l3eigA1U0MAee+y/sd6T4xPnFlZQQK/rTcRb4UQD+8KxMpe3obEy18QMFrCCAjZQA73F6sAEZrCAvhfdUcAGKmhzXaE21uAa6IuNTExgBgtYQQn0nzrvu/KpbAsVNLAHetObmMAMFrCC2Lzp+ZOlT2VbaGAP9KY3MYEZLGAFBcQm2ASb/6h5B5tPUjPv0fJJagsN7IHe9Cb6llVH3wZxFLCBChrYA72RTfS6zTGDBayggA1U0G1+5v32dqDf3k5MYAYLWEEBXeFXtbe3iX2hz0FbmMAMFrCCAjZQQQPddrUWn4O2MIEZLGAF42T5IlsLFYyT5dPRzLv+fDqaeRedT0dbKGADr2LeRefT0Rb2QL9lnZjADBawggI2EFvBVrBVbBVbxebt2Dv5fDraRH9FJPtDjk/fCm4b68a2cYf9RZHFaeO8cdl48+rm1c2rm9fGv/eTa7qxbdzh/tg4bZw3LhvXjWXjzds3b9+8Ha/PwApOG+eNy8Z1Y9m4bawb28abN23etHnT5k2bN23etHnT5k2bN23etHnz5s2bN2/evHnz5s2bN2/evHnz5s2bt2zesnnL5i2bt2zesnnL5i2bt2zesnnr5q2bt27eunnr5q2bt27eunl9JpT3FY2pUAN9LtTEBGawgBUUsIEKYlNshs2wGTbDZtgMm2EzbOY2deyB/QEmMIMFrKCADVQQWw+bT4pamMAMFrCCAjZQQQOxJWwJW8KWsCVsCVvClrAlbAlbxpaxZWwZW8aWsWVsGVvGlrEVbAVbwVawFWwFW8FWsBVsBVvFVrFVbBVbxVaxVWwVW8VWsQk2wSbYBJtgE2yCTbAJNsHWsDVsDVvD1rA1bA1bw9awNWyKTbEpNsWm2BSbYlNsik2xGTbDZtgMm2EzbIbNsJElRpYYWWJkiZElRpYYWWJkiZElRpYYWWJkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZI+sqQ7+uzf7KiggT3Qs2RiAjNYwAoKiM2wGTbD1rF1bB1bx+ZZ4gNXPhlrYQMVNLBPVJ+M1a/BKPXJWAsz6LbuWEEBG6iggT3Qs+QaAFGfjNWv0R/1yVgLC1hBARuooIE90LNkIraMLWPL2DK2jC1jy9gytoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Co2wSbYBJtgE2yCTbAJNsEm2Bq2hq1ha9gatoatYWvYGraGTbEpNsWm2BSbYlNsik2xKTbDZtgMm2EzbIbNsBk2w2bYOraOrWPr2Dq2jq1j69g6th42n/q1MIEZLGAFBWygggZiS9jIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMkjS6pjASsoYAMVdJs69kDPkus9IPX5aQszWMAKCthABQ28bNe8FvX5aQsTmMECVlBAtxVHBQ3sgZ4lExOYQbc1xwoKeNnET4BnyUQDL5v4bnqWTEzgZbvmPKivf7ewgn7exp91mzkqaGAP9CyZmMAMFvCyNVd4lkxsoIIG9kDPkokJvGzN98KzZGIF3ebb4FkyUcHLpn55epYM9CyZmMAMFrCCAl429VPoWTLRwB7oWTIxgRksoNt80z1LJjZQQQP7Qp8NtzCBGSxgBQW8bNeos/psuIUG9kDPkokJzGABPUsGCthABQ3sgeO+ZGACM1hAbBlbxpaxZWwZW8FWsBVsBVvBVrAVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBWbYBNsgk2wCTbBJtgEm2ATbA1bw9awNWwNW8PWsDVsDVvDptgUm2JTbIpNsSk2xabYFJthM2yGzbAZNsNm2AybYTNsHVvH1rF1bB1bx9axdWwdWw9bfTzABGawgBUUsIEKGogtYUvYEraEjSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyRJfeq9f82XUZ/otVNBTuTn2QM+SiZ7K5pjBAl62a1aK+ky/hQ28bN03x7NkYg/0LLmmP6jP9FuYwct2zedQn+m3UMDLdr1npT7Tb6GBcV9SuS+p3Jf4/L9x0+BL7y2soN8piGMDFfT7klGsB477koG+b90xgwWsvgiV6+ayWoPbxurs526urDW4w3NtLd+qubjW4Lyx90MO9B5HP0yjN3VgAjNYwAoK2EAFDQybPB5gAjNYwAoK2EAFDcSWsCVsCVvClrAlbAlbwpawJWwZW8aWsWVsGVvGlrFlbBlbxlawFWwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvFJtgEm2ATbIJNsAk2wSbYBFvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsVm2AybYTNshm2uudecRxR1Z93YNu7wXHhvcNo4b1w2rhvLxpu3b96+eTveNtYEv6a4axuLgk/OG5eN68ay8fCqs25scIrhnzYiZGAFBWyggl7tevFO/XOii/Nj47EXxTlvXDYee1GdZeO2sW5sG3e4PDZOG+eNy8Yx1NWKgA0cUt/ZYht3uD42ThvnjcvGdeOxs+bcNtaNbeMOy2PjtHHeuMBt/Hvfr1Y2rhtHx1qjQ7TRIdroEG10iDY6RBsdoo0O0UaHaKNDtNEh2ugQbXSINjpEGx2ijQ7RRodoo0O00SHa6BBtdIg2OkQbHaKNDtFGh2ijQ9Rneo6bR5/oubCAcUvpszwXNtDPa/YmOiJgcg8eczwXp43zxmXjurHfWg5soIJDmpw7PBbjnJw2zhuXjevGsrFfxJ6/Y4LnYtu4wyMpJqeN88Zl47rx8Kpz21g3to07PJJicto4b1w29tv37ChgA/0Y+zHwm4+JPXDExPUGpo6pnYvzxmXjurFs3DbWjeOhQccjiuN4RBk4pN05b1w2rhvLxm1j3dg29sPrLcVX8AtOG+eNy8Z1Y9m4bawbu9d733Us73u9S6o6nkQmy8ZtY93YNu7weBKZnDaOXuAxS3ViBYe0ObeNdWPbuMPjnmNy2jhvPHbWD/i455gsG7eNdWPbuAfbCJzJaWP3+kiDjcCZXDeWjd17vVurNu45JtvGHR6ZMzltnDcuG9eNo7d9zGGdqOCQFucOj8CZnDbOG5eN68ay8djZ5qwb28YdHoEzOW2cNy4b141H/esCsxEX1U/QiIvJdWPZuG2sG9vGHR53FZN9QEIcM1hAl17vh6qNuJjcNtaNbeMOj7iYnDb2nRU/4CMuJteNZeO2sW5sG3dYHxsPr+/XWDx8ctm4bjy8foJGvEzWjW3jDo94mZw2zhuXjb07x8+/CdjAIVVn27jDI14mp43zxmXjurHvbPOTMuJlsm5sG/fgPuJlcto4b1w2HvWzs25sG3d4xMjktPGoX5zLxr5f18u82sety+ThFWfdeHibc4dHklyr2GkfSTJ5eM25bDy83Vk2dq/6vo8kmeze63Vd7SNJBo8kUd/HkSST3au+jyNJJrvXR+98Smvw8Po+joSZPLy+j+M5Z/C4gVHfx3EDM3l4fR9HIk0eXt/HkUiT3Wu+LyORzLd/JJL37vaRSObbORJpcto4b1w2rhvLxm1j3dg23rxt87bN2zZv27xt87bN2zZv27xt87bNq5tXN69uXt28unl18+rm1c2rm9efqrwTd0x/nZjAIfULYyTS5LqxbNw21o1t4w6PUPKnpz5CaXLeuGxcN5aN28a6sW08vM/9sscIpclp47xx2bhuLBu3jXXj0c+SnDs8wmqye6/nMnuMsJpcNq4by8ZtY93YNnbv9SKmPUZYTU4b543LxnVj2bhtrBsPrzp3eITVteKbPUZYdT8+I6we/ndHWE2uG8vGbWPd2Dbu8AiryWnjzVs3r4dVGufFw2px21g3to077GG1OG2cNy4bD292lo3bxrqxbdzh8dW1q6/THuOza5Nt4w6PL69NThuP7fRzNz6+NtjGn/fzaGnjvLH/+eTb4/mwWDZuG+vGtnGHPR8Wp43zxpu3D684y8ZtY93YNu7BPsk1OG2cNx5ecx7e5iwbt411Y9u4w+mxcdo4bzyuW9+GkQ+TZePh7c66sW3c4fG9xslp47xx2dj393o9wdL4aOPktrFubBt3eHy5cXLaOMOzU9W9NW9cNl79fMaEVWPCqjFh1ZiwakxYNSasGhNWjQmrxoRVY8KqMWHVmLBqTFg1JqwaE1aNCavGhFVjwqoxYdWYsGpMWDUmrBoTVo0Jq8aEVRsTVq+HdBsTVidmcE0OtDFhdaKA47wWZ93YNu7wyIvJaeO8cdnYrQMFbOCQVmfbuMMjLCanjfPGZeO68biI1bltrBvbxj04j7CYnDbOG5eNh9ecZeO2sW5sG3d4hMXktHHeeE3EtDGldaKAQ9qddWPbuMMjKSanjfPGZWPfWb8O80iKyW1j3dg27vBIislp47xx9NhaHncSk2XjtrFubBt3uD42Tht7V6Brfdh4YgWvY3xNVbU52XWggmNPi3OHxz3E5LGn4pw3LhuPI+xnc9xDTG4bjyPsZ2TcQ0zucHtsnDbOG5eN68aysXs9N/K4F5lsG3d43ItMThvnjcvGdWM/yH4YfAhpooJD6gd8BNTgEVCT08Z547Jx3Vg2HjtbnXVj27jDI6Mmp43zxmXjuvHo5L14fjzaL4D59ejJeeOycd1YNm4b68a28ZqEZGPa68QERg+1lfnVtsF1Y9m4bawb28YdztFDbeNz0ovzxmXjurFs3DbWjW3j0Rl6ndwyO20Hp43zxtFDbaXUjWXjtrFubBt3uD42ThuvyV42JsVOrGD0UFuZPb+DdWPbuMPy2DhtnDeOHmorUjeWjdvGurFt3OH22DhtPOr7Bdaih9rGR6MXp43zxmXjurFs3DbWjW32b9uY7TrQu0cmRg+1ldljO7hsXDeWjdvGurFtHD3UVvpj47Rx3rhsXDeWjdvGuvHw+n6N/hHnOuJlcto4eqitPsrGdWPZuG2sG9vGHU6PjdPs37YxF3ZiAaOH2uqIl8ltY93YNu5wfmycNo4eaqu5bFw3lo3bxrqxbdzh8th4ZL7v+PhE/WTZuG2sG9vG47fGt78+Nh6/NX7cat54eLtz3di9fkHW0Qky2b1+A1PHDcxk9/qdTx03MJPd6xdbHTcwk917rV5qddzATB5ev9jGDczk4fV9HDcwk4fX93HcwEweXt/HcQMzeXh9H8cNzGT3jnMxbmAmu9fTtY4bmMnubb6P4wZmsnub7+O4gZnsXg+QMV82Nd9+HV7f5vGQNa7t8ZA12Tbu8LiHmZw2zhuXjevGsvHmtc1rm9c2b9+8ffP2zds3b9+8ffP2zds3b9+8Ha88HhunjfPGZeO6sWzsbxVVRwUNHNLrwpDxkDU5bZw3LhvXjWXjtrHv7DVsYzKesyZ3eDxnTU4b543LxnVj2di911CQyXjOmmwbd3g8Z01OG+eNy8Z1Y3+Xqjk2UMEh9YM8kmrwSKrJaeO8cdm4biwbj51VZ93YNu7wSKrJaeO8cdm4buzeaxzLZCTVZPeaH/yRVOYHR9araja/jj0wgRksYAUFbKCCBmJTbCOdrqEXG1/IXlw2rhvLxm1j3dg27vBIp8nD69fASKfJZeO6sWzc4JEqPrwxptwulo3bxrqxbezbeU3MsjHldvH489nZNu7wCITr2zc2Ply9OG9cNq4by8ZtY93YNu5w3rwjEHwoZUyqXVw2rhvLxm1j3dg27vBYC9GHGcak2nx9lMfGpNrFZeO6sWzcNtaNbeMOj3d5BiYwg0NanOvGsnHbWDe2jTssj43HzvoBl7xx2bhuLBu3jXVj27jDY6FUH0eZC6VObhvrxrZxh8dCqZPTxnnjsvHm1c2rm1c3r25e3by2eW3z2ua1zWub14bXL7axEOtk3dg27vBYiHVy2jhvXDb2Gbp+eruADXRp8gtsrMI6uQfPVVgnp43zxmXjurHv7DXt3eYqrJN1Y9u4w2MV1slp47xx2Xh4q7Ns3DbWjW3jDo9VWCenjfPGPgu6OVZQwCEVZ93YNu7wiJ3JaeO8cdl47Kw5y8ZtY93YNu7wWIJ1cto4bzy83dnrX7OfbS21Otjr+wiWjoQZPBJmstf3EZAxJXdx2bhuLBu3jXVj27jD7bHx5m2bt23etnnb5m2bt23etnnb5tXNq5tXN69uXt28c+lmv8Dm0s2DdWPbuMMjkSb7my7XZTjmcGZ/DhtzOBfrxl7Sn8nGHM7J45KcnDbOG5eN68aycdtYN968ZfPWzTt+3Pw5ZszhzP5IMeZtzn8/LqtrFpnZuKyumWNm47KaXDeWjdvGurFt7Nvmjxdj6ubitPHwFufhrc7D68d5XFb+ZDCmbs59GZfV5G0fxyXj/Q1jWubiurFs3DbWjW3jDo9LZnLaeHh9v8aPmPdh2PgRmywbt42H1/d9/IhN7vD4EZucNs4bl43rxqP+dTzHTMvs/SJjdmX2vpAxuzJ7/0cfv0WTZeO2cYfHb4v3kYxZlIvHtf1wHufrOlZj9mP2vpAx+3Fx3Xhcw8W5bawb28ajLVz722cbHJz4M7MNDi4b142F4zPa4GTd2OAR/+M41O041O04jBvPweMaLn7MxzVc/O+Oa3hyh0c0Tk4bu8uHI8aMvuyDXWNG32Ld2Dbu8LieJ6eNvb4PX4xJfYvrxrJx21g3to2H18/vuJ4np43zxmXjurFs3DYeLj+P417s4j4m8i1OG+eNy8Z1Y9m4bawb28abd9yLXeNyfUzkW5w3LhvXjWXjOKd9TORbbBt3eLSd63NefUy6y1e/bx+T7iaPNjI5bTy2TZ3LxnVj2bhtrBvbxh0ev1OT08abt27eunnr5q2bd/zGjf0dt1FXv3UfE+oWF/Zx/K5Nlo3bxmNfurNt3OHxuyZ+zMfv2uS88eZtm7dt3rZ5RyZM3s5d286dbudOt3M3MmHy5tXNNdp+8W0bbX9y2jhv7HWuFbL6mLC3WDZuG49My862cYdH25+cNs4bl43rxrJx23jz9s3b8Y4Je4vTxnnjsvGoX5xHnas9jkl3+Rr37mPS3eKycd1YNm4b68Zjm5tzh8dz1eS0cWZ7xm/o5LqxbNw21o1t420fRz4MHp9wGSgX+hb7R5cmKmhgn59B6ml8dGlgAjNYwAoK2EAFDcTWsDVsDVvD5t9qGvvm32rqfnT9q0wD/atMY4f8q0wTM1jAa9OvSc3d58UtbKAfKHM0sAcaNsNm2Aybf6tpIqfFOC3GaTFOi3+raWDH1lH4p8+ufr3uM9sWXv3GV69bH4szOo7FGScm8HqWuiYv97E448QKCthABQ3sgT6zZGICsfl7flc3ZB9rL16ddH2svXh927qPtRcH+iomExOYwQJWUMAGKogtYyvYCraCrWAr2Aq2gq1gK9gKNu8XvWb59rH24sQMSqBPar16GPtYOXFiBgtYQQEbqKCBPdAbZPerxBvkxAJWUMAGKmhgDxwtdqDvhTr69ppjAxX07e2OPdDndExMYAYLWEEBG6ggCv8gWh9YwatC8kt5fBFioEYjo0GOFQ69BYwVDicmMIMFrKCADVTQQGwpNn18zneigA1U0MAe6J/znZjADGLL2DK2jC1jy9gytoJtfNrh4cjOjy83DIzAGysRTkxgBgtYQQFRVI5v5fhWjq9wNoWzKZxN4WyOppcdbWXfWGjQQ2EsNDgxgRksYAUFbKCCBmJTbIpNsSk2xabYFJtiU2yKzbBZBN5YaHBiAVtgj8AbywROLGAFBWygggZG4I1lAidG4I1v+E6soIANVNDACLzxZd+JCSwr+8bSf55yY+m/iQZGGo2l/yYmMIMFrKCADVQw4nWs9zfxqnCNRPSxAt/EAm5/QMAGKmhgDxxfPxmYQGyCTbAJNsEm2ASbYGvYGraGrWFr2Bq2hq1ha9gaNsWm2BSbYlNsik2xKTbFptgMm2EzbIbNsBk2w2bYDJth69g6to6tY+vYOraOrWPr2HrYxnp9ExOYwQJWUMAGKmggtoQtYUvYEraELWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DK2gq1gK9gKNpr/mBc0EVvBVrAVbBVbxUaWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJTKyRBz7wjayZGACM1jACgrYQAUNxJawJWwJW8KWsCVsCVvCNpLgunGZXwHujgoaGPfV8yvAAxOYwQJWUEBsFVvFVrEJNsEm2ASbYBtN77pNai1usdtoWQPjLr61CgrYQAUNjGeGsfTdUGgCM1jACgrYwHhmGCvb+R3/WNnO7/jHynZ+KzxWtpsoYAMVNDDuq8fKdhMTmEFsHVvH1rF1bB1bD5s+HmACM1jACkZnxljRbqIGpgcYd/GaGqiggXEXr/kBJjCDBaxg3MVrVtDAuIvX8gATmMECVlBA34vrjl/HY6o5JjCDcRevtYICNlBBA+OZYawgNzGBGUTR4qLVFhet8uipPHoqj57Ko6fy6Kk8eiqPnsqjp/LoqTx6Ko+eyqOn8uipPHoqj57Ko6fy6Kk8eo5vFU/ERoNUGuT4VvG4JnkgHd8qHti5aHn0VB49lUdP5dFTefQ0Hj3Hl4YnZrCAFYyL1nj0NB49jUdP49HTePT01dkWFrCCAsZFO74e7Jfn+HrwxAzGRWs8ehqPnsajp/HoaTx6jq8HD+QpdHw9eGIGh+I///Mf/vTXf/2Xf/63v/zr3/7p3/7+5z//6R//I/7F//3TP/63//jT//nnv//5b//2p3/827//9a//8Kf/55//+u/+h/7v//nnv/k//+2f//78r8/d/fPf/ufzn8+C/+svf/3zRf/5D/ztx+u/eq27VOZfv9ZFylEi+QZSJL0uYtekMy9hpUcBrT/8/fz677fH2oOWhQ1oj9sbcE2dGhtgj1cbUA8bcC0O5X//+fPwzgb4XZsXeHaMvdqA9vrvyzWP0f/+87HirQ2QtQfP6H+1AXY4giVOobx3BK5xqHkZpfRqC9LhUtRr3ss4CaovN+F0LdeUV4nn0KLJ62v5cDEWX+DVizy7tBs1nnt1u0bRdUU/O3O345l+OhyHazJdL014iedQV1R4btKPFeRwTh/1v2iWv1Q4XJY+e3ZcVf3NCq3GZfHIr0ucDqZYnJCW7PXB7K9rZJ9AN47ms1eeGkV/DKnH6aSukHn22FJBH/f3pHFpPZ93Xu5JPtR4Pm6vzXg+brMn7ccDek1hfd1O+gqL50B4flmini6tdWFY5cJ4jprfryAR2dpeVzhcWs/x2zin6UGNmn8soYeNsIjt/Zfv54045OZzbHSVeI6Nbhd4y++dD319Pk5XhdZ1Qp79JvVViXII8OcYbezJs5/mZYn86Tkth0ORU9E4p9sP0U/ntBwurGwp4vtlgd8cy8SxtJcH4vPUO5V4Zkz8hPT++iek2OnC0tiO59mNGvnZWn6o0U/3Zhb3Zm2rILf35DlQtdrpc5DodX7XdPoxjPubZPs9Yvrxh70ezuv1nmjco6SeaCUp//jTXsvnx7TWT4/pcV+yrzM7NiOnJK/35ZSg/pbubG3Wty35scXWQ4RmjbObn90WtJYv7EvpcduW6377+fO+nH7hW9w+5md3GvuSfmxzcvqF92WrRpt7/jJuNX7cDknHW791kT1H98vrGqft8Cmno8Z+G/tLjcN1+hyYWtvxHILqL2ucz0x7RLN7nt328syInI5qXCEl66HG6UptPcVVVh6va5yu1JxXouZc7L0atdb4ue+vE0ROiVrX4Xh28PLb0H+8TtvjdFtuPGv11yUOl+nzRpoMksfrGqfLQ33piLEh17eZX1c5XKjPwb51Wp6Dfdvl8WMGtePje45D+uxIfFnidDz8bZV5POxwWg4XabpeRY5fqVbqyyrHS13jLuqJr5vLseGWEgc1ldpeN5jWTz+YRt9QMn28CHd9/KE/D/URd+nPJ3x5/VOn+Q/9ya0tLpEn99c/U3q6Oy081u+PkfmnHgqVT4/pcStqiiis9fFyK063ZNnX8Jk3D5pe3pKpnR6I4+mp6NZH8by9uV2jlngWreWHK/3HGvb4/KbO0sdX2PGIxqPL9Vv1+ib3VCMXahzOin3c82Qf9zzZxz1P5yNh0Uqe/S6vj8TpAar0+KWt+w/LT78s1k83hDmu8WL6usbxQS5+E55N7XWNfjoeJfqYs9T2ssbxmLYaudF+2JcvXKEtjmnWH7bjxxr94yu0f3yF9j/2CtX4Qcn90N77qf/poXSYlP3B+Mfk6ocr9PokXfS8i71V41oVZh3Qtj/C/VTDV57/NIb9geIPzOFe4lGya3vvKvdv7s1uqGwva6SHfDwE8GgfjwE89I+80IuvbjqfAEs+HIx+fBiNZ9Hyw5WuXyjiqx/PQ2r1dZF0ukxbifHGJ9t+UH4akjiNBliMEdn2Q11+upk891Q+6KncesDb/cGVWuKAPH/g2uvBldNAU3lE4y/ph3GN9oUi+aH/9UXycxH9eGjDv5vw2djGucStjvB0Gm26ObqRcvp0eCOdLrG74xv3z4oezsqxFyl6Xko+/cDkz0dE8+dDovkbxkSPh0MiDcvx9zaffvg1LpDrO5IvR0XPRSwGNfWHBvNzkZI+b7fH0ad77fbzAax0HH662W6LfNxuT4Mut9vt7bNyaLfny6PFNWb9zWvMUowQXEttvy5STw/5UqLdte1H+5cR/GO76zGRoHQ9/NSdu5LuXe2ncaibV/uxxL2rvcrnV/tpFOrm1X4chLp7td8+K+/+SvXownkOe7bXl4c8Pr88TsNQNy+PY4l7l8dpEOru5SH148vjNAJ1+/K4fVbevjwiPZ6Xh713o1wfKTo8H/V0jR0S9eY0otS+4Tptn1+n7fPrtH3Dddo+v07bd1yn7Ruu0+PV8Q0PlprX41xV7a8fLE8jUC1HT0yr5fC7fxqC6g9GS7cr/eef/eOdg1WOqW0/+/LTnFA9Dspx31/32Sf6Uy+InqafMMthv0B+vlBPgz/ao81d36593Xmhx+cP5vRsvWxZfipxnH3CmH7eZyh8qUi2HuNp2xH5WhGNRP1hdsGvRY63D8Y1ssfyz6f3NBDVNJ5QNbc92386waeRqLHy09iSvOXy8y+9ecVvw/I/X/F2moPyqNwN7TO/7Ocix7FKxsNlb7+/FDk9UaX4ubu+UPf6mj+NSd1uOKYfN5zTaNDthnMscrfhHIvcbTjnq6Q/4pDkwwnuh9anNbqYte4z/zV/5Wcv87OX9c2fzlszcdNpcCpXBiBqPdRon9+cdf345uxY4t7N2Wlo6e4878fj05uz/EjfcHN2+6wcbs7OV0fMUnxeHe29GsI4iLTXbxGcRqfag9e2Hqm+VUN6vHl1qvGbfbk1cd3X+//sSj+XuPdCQ/q8zz+nj/v88+nWXXK8RiV5mx30yzsN6fRIdWsa/vFo3HsXIJ+elW9uxek5psu6I6t9aym/HozbRey9IvKIWY7yOJ6WY5EW5/axTz/9WpEYBJHnAPabRVJ0DEvqhyKn4al0rU27AvVaX5Yyyd6NkJevfOTTC01KP7ceerrOtw53XjzJuX3eOXQuUiLZn0/ddihyvDdszGPV1z8xp37/u2+qlcfH0X4scS/aTyNLd6P99HLUzWg/jk7dfV3t9lk5va92vDo4Hna4eTjVKPnBtJLXt+u/q/H4uEZN8StTt3lcX6rBTMNnudc1avr8huxU4+YN2W+Oh7bYl24f15BHfvOYRhdkkfT63J4Gp54jhTGRXuuh1R03RLkN0f46Cqt9w8m1P/jk8iNVTg33NLKUHp33Cva3eb50UJl3UOxwlR1fkoopRzUfzu1peCqVHp1t9XG4tTtuR4nf272b7JfDcfzNjgkhz66Q+vo3+/x6062OB/8qyae/2ac7oZu/2ccSN98vT5//Zp/ekbr5m30cnLr7m337rBx+s89Xx62Oh3ONmx0PTT+PsfN23Os0aJ9fpe3zq/T+nrzOwdPYxa1nl3P81HhltbZt6vYv8aPHVSXuTM/Lp3Gpe9PzfrMriSmxp6ef43bcm+N33pBejMfsfNiQ/vExtcfHx/RY4hsOh7C6j6R6OBynwYbPr/Tn2N5KH5F+eMI+jUfVWC1JtgC7hnR/LHEctLzzFuBxK4Thju3lpl+34vT2XYrnlpr3e+z7Ja5R+W0JMnm8V4SZ/U9u6c0i3O2nff7WVw5qvNQjdji1vfyhJdJDuS99WHq5K+ciN8/MucjNM/ObIvfOzLHltpgAKn2fAPqVvrGWYm/aj6uZfKlItP/nNr2+WS+nAano+Nzmo9Qv5Gmr8XpRk8e7h6NoiSKaDnvy8e9+eXz8u38u8Q2/UU1iO1pLp8NxiiHpJTq1pcuri72c3nRqLV7P1kd7/WtZTkMwNXMrlPvr+Vfl+LpU5zXHR3n56FGOAyi3HtTLaUAq2YNlZux5il8OFfzu5DwKJ2e71f1Cq9ES9+z67O47nJz2cQd7+Yb3pcrn70uVz9+XKt/wvlT5/H2p8h3vS5VveF/qN1fHrQ72Y42bHey/q/H4uMa9DvZzjXsd7OU08LF1PEjv+laNm/24d7fjWON8THknd19z6+capwGpu8fjZo0P9uXWgMPtGocBh99cY7cGHMpxzb6bAw7nDbk34FBOr0vdPbmnGncv9pvb8f4Fcm/QopwW7bs7aHHekHuDFqW2j++FTu9L3R20OG/HrUGL397p1u1O91UvRjm+mHP3dvlU5F4/xvk+lwWsk7bXF5l8vjRvkY/X5j2XuHc/Jp+vzlvk4+V5i3zD+rz3z8rpfuz4FNR5c+NxWFU2fUMU5o9bbTquU/WIB499wvZXDkdO0bOU0/bE/svhkI+D8Lhk390gPG7HvdHb3/Rvbb8uj21O3Vc6yZ5/sVMkvwxCfXze03Ys8i29wjePyLHI7SNSv+OI1I+PyHnCZIpXNlN+d/5nejCmlNPLIud3+vnBffYy6+tuodPA1M25BsU+fwO12MdvoJ5L3Pu5tM/fQC328Ruoxb7hDdT7Z+Xwc3m+Om7NNTjXuDfXoNg3PK7bNzyun/fl3ur8/eMFUs4l7l3p9/fk9Y3Qab72vbnW5wiL1bd0f7r9JcJOLzfdvePvn0+XKr1/fmI/nohSH59Pl6qPj6dL1cc3TJe6f1YOEXa8Ou7d8dfT8n13o+O8HbfGX+rpQf3erXY9DUjdu0s+b8W9Z5fTwbj77HKucevZpaaPZ57W9A0zT8/bceuQ/mZxpliC1JIdvq10XMnw1pu3x+/X3LufrOnz901q/vh9k3OJe2GcP3/fpOaP3zep+RveN7l/Vk7dL5/fTqaP7yZr/nwS/7HG3Z+Ez28EP39cqeXz3/rTZtx//e/+l69e/1CXT+9Ij9970ph+8rx93heD/ukrSeW0uERmkLPs18YXSvAewQ/Llf9con/cl346GC2WhHg+acrrg1GPD/Z3ZhXV05JwN5c+Ppa4+Skw+/SUHD/iFWun7muF/vIRr+N0Ij5aY68rHMd6ovvqWolxq9Hu16gxjvesIS9r1HpcAzrHByWf3F9e4/nTS/z8NbLngYxexbZF1y8fepH8cYs/lrjX4uXj3s3TWpRZWcde9wz+6bx+eo0fK9y6xo8fh7t5jZ8/MHfzGj8uAnf3Gj8urRVdxT98juSXr8OdaggfjBA51Dh+hSzHQ8qT2+H7cKf1+W62lGOJey3lNOD0DcHx0+Horw/H8XN53BC3sn+mrrxZQz+vsU13+dJn+x4t7hYe7fCpu+PybabR7MzKocjpiSnm/9g2q/NrJWJ9MBN9s0SNrdhWkXi3RCvvHdAsfIlof5b+YhF+FlqSN09tT/H82A/n5TQFoLR4Win74tFf+iRjiR+YWg6X2M3POtZur8/u7U9UHmrc/tymvm631T59aDpuhfKFFHscUuy0Ip9KtHyV/c3pn36i7HiLbvwy7MMJ+lON0870bbGi/XW/n2r0x3HAO74u+eTtO6g/781pQyzH0oD7Sz9fynWL554nttc1jr90UmMKwDMJTr90h1/tThfBY+9o0B/v647v2CaOSBI7bMdpnfMYDujpdFBPX45gSsQ+ovBrjVP/0b3vbdbTaNHND24e9yU94nOsaV/O6tdf/uOsKh6iei+HIvnjAJDTqNPNAJDTa1A3A0COn4y6HwDHaVF8crP0/N7F+mOR/vrcHL/Zy89Mttd3/uca9FU+HwLeq1EagwuP19/9bcde/binsvc+2lvpTX8+JNpbNZ59nTGtO9nhE7Xp+KQcjyBPTO8V0cJax2WbmvXFIiZRpNubRSqfsKmlvFnEYnxA95vmL52cGtPVZH9J5Us1NI6I2CO9WSOeqMTy4SI5rs1XHvHC/pMPh0ROo1ApM3n/ye1wtZ1Gop7jeczik/Z4vL01vBL93Jp+KHNcB9aEL4ua2ruHmC/WP1nevWL2dQf1vRpMMpC+rb/8pW+SP+LKbSm9tx0txZNrS6dWmD++uzl+Gr1JxOyTt/dvv/SB9cadyZPt3SqNvsCmD32zimb2aP9w6xerxJDKkw+Bfa5iMY765JTe3Zbt6Fp6fXTl+Fmp+/l0Gq268mmbe9D7+2VuxtxvdupuzB3fmaoWHxJ58vEQ1+9Iy9+cb9muvfb2tRfLEj9Z3m1NnYum9VbfrdLYlq79vSqa48vQF8u7VaRQxQ4/Raf1E3L8jDw7hvWtGldPbozCmEp6s4rx6oBZerxZpW/b0k+3ysd3ufkwvB5GCo81jIlvtv0GfK2G0DHUXj8FnTt1Ou2n7O91/LolxzdL73zl+Vzi1oDhucStEcPTAnDpus7ieb0/Xq2OI6dxqZ6UrqWX41LnEjlWk+o52zvjUkXo0Cn7PJovXR6Fz8OnoskOl4d9Oth3LnFrsE8+fw3qC4cjv39QaXNa3my5z7/JF7ifPWWHnpSPx2HPJW6emj92HPbHw3Eah/3NqeEhWfXxsspphOtelB0r3Jv7cPz+VSncpJ06yZ4PMschnRsTQY4lnmnIB7C01TeL6HY/s1/tXysSA1RPtvbOdXZ9lz2Oq5TXP//HlxhrizurJ/f0VpVnV2rciJTtJuL6CtVbNbYngi/VkMo3wVp6q0Zh6mjZvwv4S43Db8TNyX16fLMixYBu2jsb8uN+jRQ97c9cqy9ryOmdqpu5fCxxL5dP71bcy+XjwciFVyt+uFn++WCcprD2eG6tfbvB/LlIO310Slgab3t8+HlU6bwZjc3Ylvj64r6w2Ogj29tF+G6MvH1U440VebTHyyKnl0tricnrtZxqpE9/Lo8Vbv1cHl+SvTlV8Pyi7b2pgi19w1TB89uD8Thmkl+v/tzSx1NZzyVuBVBLH09lPR+Mtk3h0sPBaJ8ejFNPYMnxFlEp+ztmqf+0Gce1/e7MoW+nt3fuzaE/l7j3M5se+g01jg/rPIzlHz6upD/1kx1GkHp0K/Vt/QX96YPG56Vk7rXYc5HmS7HPvsO8vXHyy+dMz2VYyvLJ28/Ll8tkytTDF1pP7Z8F0/dloMpPd7i/2xJeq2w/vFf5tR2qfEC31X1U4GtlZDu8sr0Z+XOZVvIfXiY/eFHqsfdl/jwL4liEZdyf/c7yZpEcGZuzvi5ybM6Zz5zlZ+y/bs7l87U6f1ODpiipvP4dPxa5eUPxmy25eUdRvyOfHucFQOIykW6vT87pXQqpMSFbfljiuvxc5PTofG+Vh1bl5lXy+sXidnqX4t5bm+cSt14sbqdvSN1887OdJofee/Ozneb8332x+P5ZObTd49Vxb5WHJp+vgfqb7bi1ykOTjxdUa3Ic8Lq7yvZ5S24tS3A8IDdXevhNjVsrPbTTGNHNg3qa1HJ3pYfzdtxb6eE3NzXb7I26TR7+5Tbi8zex2udvYrXW/tAS954Vf3dImZ7e9i/X/3xIj/PC7z3cnJ5aVeIa05Zef9bm+OTL5Csrub755HvvvJzeXrp5Xk4Ty63FgiS2dxL9vCvp8fGwzLnErY6m467cvTE8F7l7Y6jf8Ob16fWFLNEzm/epx79cY/b5Ur3tOLZz85butOrfzVu6Y4l7t3THRf9u3tKdvkZ185bO9Btu6W6flcMtnX2+VG/rn69a/pvtuHdL1z/+cErr3/LhlPOW3Luls88XHv5NjXu3dMdBqpsH1b7hlu64Hfdu6Y6/LxpTrk3e/ImKWbTNXk/Fss9vX04vT5YcS9I+O773EQi7X0Pj97r0H1aduV+jPqJGfexTZH6qoY+PO//PmxE36jUdN+PzRRB/U+Ne19a5yM07mN9syb07GE35G+5gjrdSwuyUpC/PzalGZoZLbq29V0NigktuWl9fI6l9OkCkp68d3RsgOpe4+fxzPKLbHNvH6yOq+Rs+RaGnr1BljXNbHj8M3P28Jadf25tfbtPjy073bkD09N7Vvd9KzfIdNyC/Ozm3vtxWjk/8Fk+W+93DzwuT6WkFv5sfbtP8+UqVWj5eqfJc4tbTh5bPV6rU8vFKlVq+YaXK+2fl8It5vjpufbjtWOPmh9t+V+PxcY17H24717j34Tat9z6ccvqW1bHGzbU7727Hscb5mN76cJueBj5uHw/5o/fl1ofbbtc4fLjtN9fYrQ+36fEzVDc/3HbekHsfbtPTen53T+6pxt2L/eZ2vH+B3Ptwmx6HpG5+uO28Ifc+3Kby8SLqKv3zboPzdtzqNvjtje6dD7fp8ZXBu3fL7eOVOM+3ufd6g7V9PsCv7eMB/nOJe/dj7fMBfm0fD/CrfsMA//2zcrofKx/3BquWb4jC+nmrLR/3n/6mxq3+U3+L58Mg1G/oPz1vx61DepwHfqv79FzhTu/p+WWYeCZ94rbO0ldeqGm8lNN6ea+GxQIGee8+/dpLOdyIPfLrfZHTSMPdN3uORZ7nMwZvTV++lnss0aO5PUdG9L0SDCHvX1pr98+Kxg911n2Zta+c2R9q1DdrZGqUwxV2Goq61zF+LnFreoF+/prTscTNu5bj8Wz/5XuSXzsnW59nfzM59u14twa3LdcSA2/WqPlWjY8Hw/TjsbDfvIkfgx095zdf5o+ld5/48s3V48oGtw7Fb0rcOxanc8oSwj/cEn9pzYrEErHZ3qwR97N5X7vvazVoJ9Zfv+b9mzVJKquJmByWt7pf5bQ21W+qVKro61VjLJ16ke6tRmqnMai763Wd12nJLP/dD6sR/uaY8LzxPMlvrxmzb0t5uwpP6NbrmysMPZ8FeIE91/JulbatDfT2OkW8+vnknN+tUrcq8u5qR6XsVdq7VbY+w2JvHxfdqvTHm1XqtgpUze+e6frYq7x91bF0rNZyyJZyHGjf3k2rpwvmd2VYTuK5MelQ5vhdj7uLmP1ua+LB5MmHJQ6/slMflFEWp9iXCv61jP7/cWy2XoF9CZIPduqDMjWx5MZpXVk7vk31XceG7yM+ucq37FR9Nz4fD+bA7J9U/+Lyd/2xVTmsLnhe/TfWEH9if7NIS0yfz/pmEYnJRc9RgHd3R6PjVO3ttZn33Xm/CN93aPru2swa871VU313S2IJjGcReXdLhM9VSP2Gs5MOkSDfs3rwecXq1G5dKcdJ24XF1eWwsNjxQ1PxmYe8z938+SNRdnravDln8ljiVr+OtfyHlri5MtnpeBZWRyr6OBzP04PZncVrjltR6Vzax/Z/3Qr9/PHwNKB192MVx8+YZb4QmuXlvpxr7N+PtUON0+jL3e+pnYrc69o+l7jVtf2bEne6to/f67vVR3WucKeL6vhdzFvbcK5wZxtOr5rEutyy9RU8k/R2gc6S6fJOgfTIfGKnvVci8VG7fRm0L5VofPnE3tuKsq2T2d/bim0VVKn6XonGqPU+oPeVHWHx4n1Rli+VoH+vyFs7kjVuMJ5jPm9dm6k1VnrX93ZElc6E/WM2XyjBoj2p57dKaAxP7Gvnf6FAjx/1Lm8dhx6j7nv/5lcKRPvqKh/uwnsFhD4q+aGLyh63S0h0i4rUN0vEkMKzWnqnRE68v7F/tuMrjSsxKJu2WUtfKsGof368FTSZoabnbfxbLSMzcfLHuQdf2YpIieeQ2XuHs8TLAc9dSu9tBRMgyuOtY/G8p4tlFmX/UsdXrs4sXJ2Pt0rUSEyp+1dH7pf4YSLHftMt90skXsfL+0qPP5Xox2fcSF0OZi33f8Bs+75kf2cvksq2AvD+UqH8tBenp2yN1dmz5leTLc8/YHFj039Yue4LP6MWt1f7tOJfdiQfXzm587pYP70ede91sXOJe6+LHZPT+C7d9mLDrwfjtGTP9TEebm5eLzb5myJl/6pJeVnk+GzKxEDZe3F+2Z1TJ/72yc8fD+tPC5mc5lkbn6d7jhvrochxrL1ub9CV17tzerWppcJj0TZ3ND3SF4q06NpqbV8i/ktFLFLsh4ftX4uUTx8zf7MdbXvot8N2nGY+8R2SamXrufz5zdXTa3jPJ71ttcgtBdpXDisfhn0OHpzOzem9gEfh2+PbVVJ/eiGwn7oAntkfa4Km7YPMvxQ5frKpyPYtuL6t8P7roT1uS3R19Synbcnf0IqPhzbHNIgffv9/3ZLjZ/8svtyZpHc5lJHv2KHzI2CMQtiesj9fcPWUspoY89rf2paffgBPi/jJg/u7x6FE/4YL//TO1O0LX9K3XPjHHbp7uZ1W8vvC5Sb1Gy63ely7mXdByuuTfJy0xjfpnregh7XJTkNE37MzTAh5bE9nv+7NaUnRVLlpS68X9u3Hr/je3hs9/n5Ff5LaYXeOY02PeFZ89vadipRvOMPtOy7X4+6kGBktees4/XV32necYv2jw77zdeP9+36/hH07LuMSr2HWx3bn90uY6PErAZlJMdtbYf2nBwQ9LSafoo/meZ62+0f7ucjxgo27trL38T/Ha38qUr7h5Bx3J9M7UbbfnV93R/7oLamJt7m3rpZft+Q0SvpIfJxjbzrtC5caLed5m9IOl1r/g5/entcGCw88Ds/Wx2W+7uaa5T96d3Ih1/aVWH7ZnfoNuWbfchN7fBGamN5nFaf0UyM+LfX3lWeV07bwWmVN+zctf9mW77hmjzePd49K///hRvbuUenfEbOnTHkOhcby61naYUvk85+v3r7h5+u02t7tn6/+Hf1bx925+fOVHo/HH70pN3+/ro7WP/YHTFosPiw/PPCknz8J8fiGW9nTQtsaH0N6jqP0d/raa4uPH1Str/van/uin3a2P2vYp73tv6lxc3W233Rzbx/Mfv05xuvp8PPO8nOVm5+IOvaV98x4jLzdVx7JaGmfuPy1IjGDyXI6fHfncXoF6/m0E1NJ+/5e2q9VTgkrOX64Xs9QOHfq0rXVZPu+0tc6dXmXtPSW3r2vuHl2zkXunp3TYoD3z85p5YdvODvabJtC/XpM5bkhx/ev4+zU/fPhP5c4XK/CzCT54aO7P48tn2/6bl4m5xutm5fJucjdy+Q3XRY3L5PTGyI3L5Nj93T8YPzw5R/5+UfnNN5VmQ9eS349dH/u/6SfLrea3u3/vHmGz0Vun2H9ljNsf+gZ5g3Xvr2B+esZPg14SYoVJSTtSz7/coZPd42Jay3/0LH8+Eqf8M0zfC5y9wyfxrvun+HTcNfNM3zqzs1Mmcz7hMX/4hwfVwqq0Yof+5eNfzk95Rta8bmP++45rt9xjk8DXvfP8Wl5vm84xyXFRMjyvJ0+nOPTYFe1uLOvZnI4x+072vF3JHX7lqQ+rdH3hXPcPz7Hx+6XUpgSvw1V9Z+fmE4fsKoxVXX/wlFq9oUaEov0SXu7RrwoL9siBF+s0eO1lUf5hhr2Zo0Wx6O9fTxaHI/29vFosS/69vHYa7x7PFjEUd8+HhrHQ98+Hhr7Ym8fj73Gu8eDl7ysvbsdFm9G7y+ZfrFG9Iz3t4/HXuPd7egRy/2QQb/pAW7MK9xXMSk/P77a8TXTeI+4/LBax9eq1LhWizzs3SqsHVjavurN16po9DReC/a+2zN+90H4W3qz7Ft6s+zz3qxj7zpfKC77B/W+2tF/78j+rsrdQ9u/5d615z/20Na4r3kOXKTDoe2n9SpTjHCV/WPWv3wl8HiLtXVt//DbpT8XOS2CtX1rsLxZwpgibO+WePxXNwP6hbGg2qPjRn74gtLPX9U8XayVO6za9imO7xcpL0el7o+PvR55fG7Jce0gXhSoxQ67c3rZ+VFZhLifjsnpWk2M6T55n8X6SZnXQ37noeGH3RkaPg4b1ri3EKmvR8vT8Wvl40Kau7MvMPLz72hKpwsuBoXq/iuaHz/XOM7UItbyqcZpO1LE675u3K81yjcEfTq9vnW3k+J0gkUjT9reEfzLCT5+lVb47k95+RCczqNb/1WJq9/kK8PTt3/Kv6MbKuXvGC5I+fPhgvMrCzHnuufHYZbk+ZWFm7ef5yK3D6x8y4Ftn/fSH1+e2Iapnz+G6XBo5TsOrXzHof2WIa70DUNc5zcfbl6z5yL33tVJqXzDlJffVbmZTL+pcvss67ec5c+Huc6vg9xuQPIdYw/yLYe2fsdUglQ/n0pwnNV+s186nULlZr/0scbNfulzjXv90uca9/qlb9ewN2vc7Jc+17jXL32uca9f+naNd4/HzX7pc417/dLnGvf6pW/XePd43OyXPte41y99rnGvX/p2jXe342a/9PnFmpv90uk0OH27X/pc5W6/9LnK3X7pc5W7/dL6HRO09DsmaCX9lrtX/fzu9VjiZr/0b96funtgv+WxQL/liUvbH3tg7/ZKp9PHse72SqfTu1x3e6XTaWToXq/0ucStXunflLjRK318w+52p/TpJa7bndL3i7zulL7/0uGpU/r4EtfdTmmzb+iUtv4tndJfKfO6U/r8uu3nndL1Eb0Dz2r58GB/mhV8v1P6NMR1t1P6+MWsm53Sx+242Sndv6VjoH/eMXB+25ZPIKby+m3blB/n0fsbndL5kT7tlP7NS793f8e/40WH/PiO2a/58fns19srUNXXK1CNxHnZgG37hM/2xuFPn2I9vwh9d/KrfUfnuH1H53hO3zGBIKfPJxCcfohvzzi177gHNvmWA9u+5cDqH9p2Cp95KvvXdn5djK6dfkGZVPxo+dAAT0Nc31Pl3nrrv6lxa8H139W4s+L6ecnZ+IZd2s7MT3n03Ao5RWMss/R4WeK0Efe+T53y6f3Lex+oftY4fYK4853ZJ+/rpP70uv7xJZaYffDD527ljQI/fN31doEWt6t7R8tXCmzPeOmtArGudPvhuwj3C9xahP9Y4MM1+O+9Enx8aohFG1LdVlctP31H5bhsfIoHdin1rRK6fRuvvrcV1rZPILa3SvR4reT5fGNvlWisutv0vR1pnWXjH+/tyGNbtcze24ocL+CnvL+B/4UShY8v1u1bLl/aingNK+X23o6wvvZzbL19eizeLiGdHdkCN31lK5Qzkj8v0d4qUWJF6CfaeyUaI6jbghlfKbFHTn3vWBQ+mVr3r8a/W+K9k7ovMrMt6f+lEnyporb2Zgl2ZF/G/isl4gY8VXvvpNboYXw+yzzevC74gkl+66TW+ATjDz2U9wtwaUp+fRyeKdCOuVeJi+1G8f79XeWDFfrWbmjcXdW3zoUI0x/rWwVi3Xfp5b0CMbuh188K7FMbvnQQ6WR+KytbdD7uy02/twU/n8b//vy///wvf/n7P/31X//ln//tL//6t//7/Hv/eZX6+1/++X/89c/z//6vf//bv2z/9d/+3/+z/sv/+Ptf/vrXv/zvf/o/f//Xf/nz//z3v//5qnT9tz895v/8N9NnRJrlx3//hz+l5//v1+dYn50K8vz/xf/7s4Ph+Yeu/5+uv9CupcieYzbl+hf+N54/F//w/B/77/95bfL/Bw==",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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b+/oZ4ynV19ecMIF78unV19ucMAdxjvxTrwT78Q78S68C+/Cu/AuvAvvwrvwLrwLb+JNvIk38SbexJt4E28+3nM+5L5cL/jxnmNdAXd4wBNevE7CeGvf5+8XjHfj3Xg33o134914N959xxuvF3y98Qq4wwOe8IITLviONxre1uCAOzxgvA1vw9vwNrzxghlvMN5gvIE3JrzghAvG2/F2vB1vx9uZ5854O+PtjLfj7RzfwTwP5nkwzwPvwDvwDrwD72CeB+OdjHcy3ol3cnwn8zyZ58k8T7wT78S78C68i3lejHcx3sV4F97F8V3M82Kek3lOvIk38SbexJvMczLeZLzJeOlVFMe3mOdinot5pldReAtv4aVXQa+CXgW9CnoVG+/m+NKroFdBr2Jfb3+94AYH3OEBT3jBCV9vf93j2+lVp1edXvWGt+GlV51edXrV6VWnV51edXrVA290eMATXjDewEuvOr3q9KrTq06vOr3q9Kp3vD1h5pledXrVB96Bl151etXpVadXnV51etXpVZ94J8eXXnV61elVn3gnXnrV6VWnV51edXrV6VWnV33hXRxfetXpVadXfeFNvPSq06tOrzq96vSq06tOrzrrq876qtOrTq86veqsrzrrq06vOr3q9KrTq06vOr3q9KpvvJvjS686ver0qm+8Gy+9GvRq0KtBrwa9GvRq0Kvxut7xSrjgO8+DXo2Gt+GlV4NeDXo16NWgV4NeDXo1Am80OOAODxhv4KVXg14NejXo1aBXg14NejU63j5h5pleDXo1Ot6Bl14NejXo1aBXg14NejXo1Rh4B8eXXg16NejVmHgnXno16NWgV4NeDXo16NWgV2PhXRxfejXo1aBXY+FdeOnVoFeDXg16NejVoFeDXo3EmxxfejXo1aBXg+vBwfXgoFeDXg16NejVoFeDXg16NTbezfGlV4NeDXo1uB4cGy+9GvRq0KtJrya9mvRq0qv5ut75mvCCEy4Yb8NLrya9mvRq0qtJrya9mvRqNrztHt9Jrya9mvRqcj04Ay+9mvRq0qtJrya9mvRq0qvZ8fYOM8/0atKryfXg7Hjp1aRXk15NejXp1aRXk17NgXdwfOnVpFeTXk2uB+fES68mvZr0atKrSa8mvZr0ai68i+NLrya9mvRqcj04F156NenVpFeTXk16NenVpFcz8SbHl15NejXp1eR6cNKryfpqsr6a9GpyPTgLL/evJr2a9GrSq8n66tlHPd6//ajNfe/Xzd3hAU94wQkXfO8TrtcLbnDAHR7whBeccMF4G96Gt+FteBvehrfhbXgb3oY38AbewBt4A2/g5Xpwcf9qcf9q0atFrxa9WqyvFuurRa8WvVr0atGrRa8WvVr0atGrRa8WvVoD78BLrxa9WvRqcT24uH+16NWiV4teLXq16NWiV4terYl33k4uerXo1aJXi+vBxf2rRa8WvVr0atGrRa8WvVr0aiXe7DDzTK8WvVpcDy7uXy16tQov66vF+mrRq8X6arG+WvRqcb99cb99FfPM+mpxPbi4f7W4f7W4375YXy3WV4v11WJ9tVhfJffb89XggDs84MnrLDjhgvGyvkrWV8n6KllfJffbs014wQkXjJf7V8n9q+R+e7K+StZXyfoqWV8l66ukVxn3+GZnnjvzzPoq6VVy/yq5f5Xcb096lfQq6VXSq6RXyf32HBxfepX0KulVcj2Y3L9KepX0KulV0qukV0mvkl4l99tzcnzpVdKrpFfJ9WBy/yrpVdKrpFdJr5JeJb1KepXcb8/k+NKrpFdJr5LrweT+VdKrpFdJr5JeJb1KepX0KllfJeurpFdJr5JeJeurZH2V9CrpVdKrpFdJr5JeJb1K7rcnnw8WvSp6VfSquB4s7l8VvSp6VfSq6FXRq6JXRa+K++3F54NFr4peFb0qrgeL+1dFr4peFb0qelX0quhV0atifVWsr4peFb0qelWsr4r1VdGroldFr4peFb0qelX0qrjfXnw+WPSq6FXRq+J6sLh/VfSq6FXRq6JXRa+KXhW9Ku63F58PFr0qelX0qrgeLO5fFb0qelX0quhV0auiV0WvivvtxeeDRa+KXhW9Kq4Hi/tXRa+KXhW9KnpV9KroVdGr4nqw+Hyw6FXRq6JXxfVgcT1Y9KroVdGroldFr4peFb0q7rcXnw8WvSp6tenV5v7V5v7VplebXm16tenVplebXm16tbnfvvl8cNOrTa82vdrcv9rcv9r0atOrTa82vdr0atOrTa8299s3nw9uerXp1aZXm+vBzfXgplebXm16tenVplebXm16tbnfvvl8cNOrTa82vdpcD27uX216tenVplebXm16tenVpleb++2bzwc3vdr0atOrzfXg5v7VplebXm16tenVplebXm16tbnfvvl8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8Zp46VWjV41eNXrV6FWjV41eNXrV6FWjV41etcAbeANv4A28gTfuedWi4Htetf6C73nVPr16GC+9avSq0atGrxq9avSq0atGrxq9avSq0atGrxq9avSq0as28E689KrRqzY5rybn1bx/L7TJeUWvGr1q9KrRq0avGr1q9KrRq0avGr1q9KrRq0avGr1q9KrRq0avWjLe5OeIXjV61T69OvPw6dXhwlt46VWjV41eNXrV6FWjV41eNXrV6FWjV41eNXrV6FWjV20z3s14Nz9H+/4cxev2OV4Nvt5gfRWsr4L1VbC+CtZXQa+CXgW9CnoV9CroVdCroFdBr6Ld8UYrmPHGC2a8ETBeehX0KuhVsL4K1lfB+ipYXwXrq2B9FfQq6FXQq6BX0RlvZ7yd8Q7GOxjvYLz0KuhV0KugV0Gvgl4FvQp6FZPxTsY78U68rK9i3vM5JuOdjHcy3sX5vBgvvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq9j376O414M97vVgj8149/37KO71YA/WV8H6KlhfddZXnfVVp1edXnV61elVp1f9dee5vwq+51VvL/ieV70FjJdedXrV6VVnfdVZX3XWV531VWd91bke7FwPdq4He0z4znOPhPHSq06vOr3q9KrTq06vOr3q/Z7PnV51etXpVR/357fTq876qtOrTq86ver0qtOrTq8614Od68HO+qqzvupcD3auBzu96lwPdtZXnfVVZ33VWV/1hXfhXRzfxfFd9+eoL44vver0qtOrTq86veqJN/HSq06veuJNzqvEm3jpVadXvfAW3sJbeAtv4aVXnV51etXpVadXnV51etXpVadXnV51etVZX43XC25wwPe8Gq8B3/NqvBbPT7hgvO3+HA16NRre1uEBT3jxvQkfb4vD+/LTqw83+HhbP9zh423H9fTq/W9j9Wd/+5cTPt54Hd6Xn17Fec2nVx8OuMPHG2dun159+Hjf+zz7s7/9ywUfbz/v+enVh4/3veezP/vbv3y87z2f/dnf/uXjHec1n159OOHjHc/r78tPr+Z5z0+vPhzw8c5zvJ5effh453lvT68+fLzrzPPTqw/vy0+v8sz506sPH2+e9/z06sPHm+c9P7368PHm8T69+nDBx1tnrp5effh49/E+vfpwhwd8vPuch0+vPpzw8e7znp9e7fM+n159+PGeeXh69eG3N1/nvZ1efXnC6/A5906vvvz25vMzcnr14dOrL7fD572dXn35eJ+fndOrLx/vcz6fXn054eONcz6cXj387G/P2IcbHPDx9nZ4wBM+3vfvyujP/vYvH+94nnO85zx/9rd/ucEBd3jAE15wwgXjDbyBN/AG3sAbeANv4A28gbfj7Xg73o634+14O96Ot+PteAfegXfgHXjH412HJ7zgx3vOn1HwvjxfcIPjvs7sMN45ef6C8U68E+/Cu/AuvAvvwrsY72K8C+/Cu/Am3sSbAXd4wIw38WbCBe/L9YLxFt7CW3gLbzHPxXiL8Rbj3XifXn2Yed7M82aeN96Nd+PdePf1rtcLbnDAHb7e9ZrwghMuGG/D2/A2vA1vG/CEF5ww3naP74oX3OCA8QbewBt4A28UzHg74+2Mt+PtHWaeO/PcmeeOt+PteAfegXcwz4PxDsY7GC+9WoPjO5jnwTxP5plerYl34p146dWiV4teLXq16NVaeBfHl14terXo1Vp4F156tejVoleLXi16tejVolcr8SbHl14terXo1Uq8hZdeLXq16NWiV4teLXq16NUqvMXxpVeLXi16tTbejZdeLXq16NWiV4teJb1KepWv681Xhwc84QUnr1MwXnqV9CrpVdKrpFdJr7LhbQkXfOc56VUG3sBLr5JeJb1KepX0KulV0qvseHuDmWd6lfQqO96Ol14lvUp6lfQq6VXSq6RXyfoqWV8lvUp6lfQqWV8l66ukV0mvkl4lvUp6lfQq6VVOvJPjS6+SXiW9yoV34aVXSa+SXiW9SnqV9CrpVSbe5PjSq6RXSa8y8SZeepX0KulV0qukV0mvkl5l4S2OL71KepX0KjfejZdeJb1KepX0KulV0qukV/W63no1OOAOD3jyOgtOuGC89KroVdGrolfV8LYJLzjhgvEGXnpV9KroVdGroldFr4peVeCNe3yLXhW9KnpVHW/HS6+KXhW9KnpV9KroVdGrGngHx5deFb0qelVcDxbXg0Wvil4VvSp6VfSq6FXRq5p4J8eXXhW9KnpVXA/Wwkuvil4VvSp6VfSq6FXRq0q8yfGlV0Wvil4V14OVeOlV0auiV0Wvil4VvSp6VYW3OL70quhV0avierA2XnpV9KroVdGroldFr4pe1ca77/Hd9GrTq02vNteD+zXgCS844YLveDe92vRqN7ytwwOe8ILxNrz0atOrTa82vdr0atOrTa924I2EC2ae6dXmenB3vPRq06tNrza92vRq06tNr/bAOzi+9GrTq02vNteDm15t1leb9dWmV5vrwT3xcv9q06tNrza92qyv9qdX+/DxznF4X3569eHjPff2n/3tXz7ecw//2d/+5eNd7fCCj3c9r1nwvvz0ap1xPb368PHm8T69+vCAJ3y8ecb79OrDBR/vuef/7G/Pc5//2d/+5eN9/16U/uxv//Lx1nlvT68+vODjff9elP7sb//y8e7zHp5efbjBx7vPe3t69eG3t869/Wd/+5ff3nr/3pL+7G//csH78M+9/fHsb/9yOzwPx+E83OEBH+/795+MZ3/7l483ntcseF8+vfpZvRxu8PH2frjDAz7eft7n6dWXj/f9O3zGs7/9y8f7/n0+49nf/uXjHec1T6++3OHjHef1T6++fLzzvOfTqy8XfLxzvfn06svHO897O7368vGuM7enV1+e8PGuM8+nV18+3jzjOr368OnVz9/4hxsccIcHPOEFJ1zwvjzxTrwT78Q78U68E+/EO/FOvAvvwrvwLrwL78K78C68C+/Cm3gTb+JNvIk38SbexJt4E2/hLbyFt/AW3sJbeAtv4S28G+/Gu/FuvBvvxrvxbrwb777eZ3/7lxsccIcf7zo84QUnXPC+/PTqww0OuMPHW+c9PL368PG+f4/QePa3f7l4zr789Op5ztOrDwfP6fDj7YfxPr36MN6nVx/G+/Tqw3ifXn0Yb2e8T6+e99DxPr36MN6nVw8PvE+vPoz36dWH8Q7G+/TqeQ8D72CeB97JPE+8k3meeJ9efRjvZLxPr573MPFO5nnhXczzwruY54X36dWH8S7G+/TqeQ8LbzLPiTeZ58SbzHPiTc7nxJuM9+nV8x4KbzHPhbeY58JbzHPhLc7nwluM9+nV8x423s08b7ybed54N/O88W7O5329z/72L7ff7+HZ3/7lx5uHBzzhBSdc8L789Or9u8jGs7/9ywF3eMATXnDCBe/Lgffp1XtPy3j2t3+5w8e75+Hjfe9pGc/+9i8nXPC+fHq1X2eeT6/268zt6dWXOzzgCS844YL34TPP4wU/3jP206ufK/HDHR7whBeccMH78unVlxv8eNfhDg94wgtOuOB9eb3gBuNdeBfehXfhXXgX3oU38SbexJt4E2/iTbyJN/Em3sJbeAtv4S28hbfwFt7CW3g33o134914N96Nd+PdeDfefb3P/vb93tM4nv3tP3dgDgfc4QFPeMEJF7wvtxeMt+FteBvehrfhbXgb3oY38AbewBt4A2/gDbyBN/AG3o634+14O96Ot+N9etXP8Xp69eGCj/e9L248+9u/3OCAOzzu6zy9+jDep1ef5xeMd+KdeCfeiXfinXgn3sl4J+OdeBfehXfhXXifXn14wgtmvAvv06uHn159uMEB4028iTfxJt5knpPxFuMtxlt4n159mHku5rmY58JbeAvvxrvxbuZ5M97NeDfj3Xg3x3czz/vO87O//cvX++xv/3KHBzzhBSdc8B3vs7/9420NDrjDA8bb8Da8DW/DGy+Y8QbjDcYbeGPCC064YLwdb8fb8Xa8nXnujLcz3s546dXoHN/BPA/meTDP9GoMvAPvwEuvBr0a9GrQq0GvxsQ7Ob70atCrQa/GxDvx0qtBrwa9GvRq0KtBrwa9Ggvv4vjSq0GvBr0aiTfx0qtBrwa9GvRq0KtBrwa9GoW3OL70atCrQa9G4S289GrQq0GvBr0a9GrQq0Gvxsa7Ob70atCrQa/Gvt75esENDrjDA57wghO+3vm6x3fSq0mvJr2aDW/DS68mvZr0atKrSa8mvZr0agbe6PCAJ7xgvIGXXk16NenVpFeTXk16NenVZH01WV9NejXp1aRXk/XVZH016dWkV5NeTXo16dWkV5NezYl3cnzp1aRXk17NiXfipVeTXk16NenVpFeTXk16NRfexfGlV5NeTXo1F97ES68mvZr0atKrSa8mvZr0aibe5PjSq0mvJr2ahbfw0qtJrya9mvRq0qtJrya9mhvv5vjSq0mvJr2aG+/GS68WvVr0atGrRa8WvVr0ar2ud70SLvjO86JXq+FteOnVoleLXi16tejVoleLXq3AGw0OuMMDxht46dWiV4teLXq16NWiV4terY63T5h5pleLXi2uBxfXg4teLXq16NWiV4teLXq16NUaeAfHl14terXo1eJ6cE289GrRq0WvFr1a9GrRq0Wv1sK7OL70atGrRa8W14Nr4aVXi14terXo1aJXi14terUSb3J86dWiV4teLa4HV+GlV4teLXq16NWiV4teLXq1Nt7N8aVXi14terW4HlwbL71a9GrRq6RXSa+SXiW9ytf15mvCC064YLwNL71KepX0KulV0qukV0mvsuFt9/gmvUp6lfQquR7MwEuvkl4lvUp6lfQq6VXSq+x4e4eZZ3qV9Cq5Hkx6layvkvVV0qvkejAHXu5fJb1KepX0Kllf5adX73v++enVPtzg4z37SZ797V8e8IQXnHDB+/LTqw83GO/Cu/AuvAvvwrvwLryJN/Em3sSbeBNv4k28iTfxFt7CW3gLb+EtvIX36dXZt/Psb//yvvz06sMNDrjDA57wgo93nvfw9OrDj/d9/jz727/cfj/n2d/+5c5zBjx5zoIfbxwuHt+XG96nVx/G+/Tqw3ifXn0Yb0u47ntoeJ9efRjv06sP43169WG8T68+jDcY79Or5z10vJ157ng789zxdua543169WG8nfE+vXrew8A7mOeBdzDPA+9gngfep1cfxjsZ79Or5z1MvJN5nngn8zzxTuZ54p2czwvvYrxPr573sPAu5nnhXczzwruY54U3OZ8TbzLep1fPe0i8yTwn3mSeE28yz4W3OJ8LbzHep1fPe3h69eFnntfhhAvel59efbjBAT/eOjzgCS844YL3b372t3+5wQF3+HhXPzzhBR/ve9/vePa377PX8dnf/uGnVx9ucMDHe/Y9Pvvbd8bhCS844YL35adXH27w8Z69Xs/+9i8/3jP2p1dnT8izv33XPJxwwfvy06sPNzjgDg94wng73o634x14B96Bd+AdeAfegXfgHXgH3ol34p14J96Jd+KdeCfeiXfiXXgX3oV34V14F96Fd+FdeBfexJt4E2/ifXp19tU8+9v3PufV06sPJ1zwvvz06sMNDrjDA8ZbeAtv4S28G+/Gu/FuvBvvxrvxbrwb7/7tnc/+9i8/3joccIcHPOEFJ1zwvvz06sN4G96Gt+FteBvehrfhbXgDb+ANvIE38AbewBt4A2/g7Xg73o634+14O96Ot+PteDvegXfgHXgH3oF34B14B96Bd+CdeCfeiXfinXgn3ol34p14J96Fd+FdeBfehXfhXXgX3oV34U28iTfxJt7Em3gTb+JNvIm38Bbewlt4C2/hLbyFt/AW3o134914N96Nd+PdeDfejXdfb3u94AYH3OEBT3jBCReMl141etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41ehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV0Gvgl4FvQp6FfQq6FXQq6BXQa+CXgW9CnoV9CroVdCroFdBr4JeBb0KehX0KuhV0KugV51edXrV6VWnV51edXrV6VWnV51edXrV6VWnV51edXrV6VWnV51edXrV6VWnV51enf3tP8Geh+NwHu5vfv+/4fPsb//N8/A+vOB88/v/155nf/tv3pffvfrh4+3H289r9oCP9/1Z2zz723/z8fb+919/+N///Lc///O//OVP/+sP/+0/f/74P/7jX//473/+679+/vjv/+ffvl/5l7/9+S9/+fP//Kd/+9tf//in//4ff/vTP/3lr398f+0Pr89//uHn3v3+9XNz/vWPv/7w847+4ef+Tf36uVmzfv7cz9fn/Pn6mu+vv79h/fwN8uvnP/V+4HzHzyX7r5//zH/8+3mJ/zzf1+PXiO/3zPZrrveX4/3l81C0X3Ee6r8fautXtPdD4/siPzPV6/siY/wa+/3l+f9+x7qvO37FeVbeh/JXj/dDdb9x/4rxfmh/5+Hn74ZfP438jHrVr/wtjrfmx/MZ78/fWD9/zDPa39P4k6Ef7/h8+89d7fX6/e0/ExjPH8+3r/fI+/n29v32nxX2r5+V5ufbf64vfv2s9b8v8LPU//nj7/n+WYX+PPfMXYv/6gv03wMYP4Nc+Xuy89eM+5br10+LzzeMO4f5Mw3nsfn/P+jtHp31MzHz+7KVv+rnUP397//49/8L",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgACgAMuAgANgAQuAgAMgAUlAAAIiy0KCwIoAgADBIB4JwIMBCAtCAELJwINBCEACAENAScDCwQBACILAg0uAgADgAMuAgANgAQuAgAMgAUlAAAIiy0KCwMuCICYAAQuCICZAAUuCICaAAYoAgAHBICbJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAHgAMuAgANgAQuAgAMgAUlAAAIiy0KCwcoAgAIBIC5JwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAIgAMuAgANgAQuAgAMgAUlAAAIiy0KCwgoAgAJBIDXJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAJgAMuAgANgAQuAgAMgAUlAAAIiy0KCwkoAgAKBID1JwIMBFotCAELJwINBFsACAENAScDCwQBACILAg0uAgAKgAMuAgANgAQuAgAMgAUlAAAIiy0KCwolAAAI0SUAAAleKAIAAQSBTycCAgQAOw4AAgABAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAjQLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAifJigAgEMAAQAoAIBEBAADKACARQEAACgAgEYEAAAoAIBHBgAAKACASAAAACgAgEkBAAEoAIBKBAABKACASwAAASgAgEwEAAIoAIBNBAAEKACATgQABigAgE8EAAcoAIBQBAAIKACAUQQACSgAgFIEAAooAIBTBAALKACAVAQAFygAgFUEAB4oAIBWBAAgJiUAACHQHgIADAAeAgANADMqAAwADQAOJAIADgAACYIlAAAh+R4CAAwBHgIADQAKKgwNDiQCAA4AAAmeJQAAIgsnAgwAAi0IAQ0nAg4EAwAIAQ4BJwMNBAEAIg0CDi0KDg8tDgwPACIPAg8tDgEPJwIPBBAtCAAQLQoNES4IgEwAEi4IgEUAEwAIAA8AJQAAIh0tAgAALQoRDgsiAA6ASAAPCyIAD4BFABAkAgAQAAAKFCUAACPrHgIADwYnAhEEEi0IABIuCIBFABMuCIBIABQtCgwVLQoOFgAIABEAJQAAI/0tAgAALQoTEC0IAQ4AAAECAS0OEA4tCAEQAAABAgEuDIBGABAtCAERJwISBBgACAESAScDEQQBACIRAhInAhMEFwAqExITLQoSFAwq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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3friW5cWf9Ln3ti00yIkjqVQYDQ/ZoBgIEyZDlD/hg+N1nM5jkijrlw8qz9+m5US91V8XKf/ztTJLJ/M/f/tef/uU//s8///mv//tv//7bH/7Hf/72L3//81/+8uf/889/+du//vEff/7bX5//9j9/e4z/SbX+9ofyT89/tt/+oOOf/bc/1Oc/2/M/9/HP9NsfUhqQnzD+Wa5/yvVPff5zVGi2oC5oC/oF/bEgLcgLygJZsCr3Vbmvyn1V7lfl/HgsSAvygrJAFugCW1AXtAWrclqV06qcVuW0KqdVOa3KaVVOq3JaldOqnFflvCrnVTmvynlVzqtyXpXzqpxX5bwql1W5rMplVS6rclmVy6pcVuWyKpdVuazKsirLqiyrsqzKsirLqiyjch1QF7QF/QJ9LEgL8oKyQBboglVZV2UdlduAfoE9FqQFeUFZ8Kyc04Bn5awDbEFd0Bb0C+pjwbNy7gPygrJAFjwrl8cAW1AXjMrjQI3m5zDa34Rn5TIUowFOKAtkgS6wBXVBW9AvGG1wwqrcV+W+KvdVua/KfVXuq3JflftVuTweC9KCvKAskAW6wBbUBW3BqPw8p2W0wQlpQV5QFsgCXWAL6oK2YFXOq3JelfOqnFflvCrnVTmvynlVzqtyXpXLqlxW5bIql1W5rMplVS6rclmVy6pcVmVZlWVVllVZVmVZlWVVllVZVmVZlWVV1lVZV2VdlXVV1lVZV2VdlXVV1lVZV2VblW1VtlXZVmVblW1VtlXZVuXRBuUxoF8w2uCEtCAvKAtkgS6wBXXBqlxX5bYqt6uyjMM7WqWMwytpwPjr/m/agn7BOJgT0oK8oCyQBbrAFqzKuirrqmyrsq3Ktirbqmyrsq3Ktirbqmyrsq3KdVWuq3JdleuqXFfluirXVbmuynVVrqtyW5XbqtxW5bYqt1W5rcptVW6rcluV26rcV+W+KvdVua/KfVXuq3Jflfuq3FflflXWEWhiA9KCvKAskAW64FlZHwPqgragXzACTdOAtOBZWWVAWSALdIEtqAvagn7BCLQJacGqnFflvCrnVXkEmuqAuqAt6BeMQJuQFozKdUBZIAuelW3s6Qi0CXVBW9AvGIE24VnZxvaMQJtQFsiCUXnYR6BNqBeMhqZtwPjr41yMZmX+b55/uI7jPJrVhLagXzCa1YS04FmnjsqjWU2QBbpgVB6u0awmjMp9QL9gNKsJaUFeUBY8K7dx1Y1mNcEW1AXPym0chNGsHEazamMzRrOakBeUBaPyUIxmNcEW1AVtQb9gNKs+pKNZTcgLyoJn5T42YzSrCbZgVB5XwmhWE/oEG21nwvjrOuD5h3sbMG7e8oDnH+7PzbDRUiakBXlBWSALdIEtqAvaglU5r8p5Vc6rcl4b5nfdj8cg21Q3tU19kd96P2RQ2pQ3lU2ySTe5YxwHvwOf1Db1RX4T/hgb6nfhk/Km4UhjW/xGfJJuGg4/xH4vPm7PzW/G09hfvxt38tvxSWlT3lQ2DUcelf2efJJtqpvapr7Ib8wnpU15U9m0HbYdth22HdXrjX2raVPeVDbJJl3kz7Hjt938QXaSVx5npu8t7XtL+9rS6s+c4zmg+kPnpLJJNukm21Q3tU19kT98TtqOtB1pO9J2pO1I25G2wx85sw3yv1sH+d/tg3STbaqb2qa+yK/2SWlT3lQ2bUfZjrIdZTvKdpTtkO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7bDtsO2w7bDtsO2w7bDtsO2w7bDtqNtRt6NuR92Ouh11O+p21O2o21G3o21H2462HW072na07Wjb0bajbUfbjr4dfTv6dvTt6NvRt6NvR9+Ovh19OdrjsSltypvKJtmkm2xT3dQ2bUfajrQdaTvSdqTtSNuRtiNtR9qOtB15O/J25O3I27HbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO923nc777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO92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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AH3LLyMXHCdpmtVjp\n86M1p4q65L9vNsd72KJTx6YJc8kI3cBbEYeROqlHIhqmftExTflSkaZqwMPf267dDEXCAyc0mvBu\nE7IFAz+IwqRvfAw/Ho2o3jWHzo5jzbXOW71CDO3wanM+WLlV1Rafs1AK3Ajzwu9rIS403MnD6EQ2\n1H4ArmjcXq1VmPoiOQrEFHxj6nMttRVss6beZeQ1YS1aXwu/54x2J5y3srXtdXoL1aSxBPZ6X/+v\nXzT2z9ETL44aEl15Eqk5khmGHoN4e2/3PRexS44KLcxPiJHA26Fj4L4fufyCnBY71GH8uGswbEt5\nxNV8Hpzn6R78E46QLiNPji4vgFBMdVp+5YsafVguN+xurT4yX9LWUIKtSfXsE93kK6FdmomYw1Qu\nE/GMXdz22kWhR2IYCBvEIiHJ6+7RNAMWpoUfOycfWFntpExtSIhupi3VkX2FhIrdc5LhE3VBzQyA\nAXiYcRfN3F6z39aGjWPz4+cTvoCDaJdfjzKXFZxYEabVvIpfVK1Cmo0sICvRD9kVavxZhNfishhT\njnOjarMEaHGye2msWK1jh5dtDtpyAx4+e0Dduaitynb2eIOYxSmMMxH8kXD5LelAsEKquZDVPGo7\nJjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsA+lWdxSOc6ow2ZRkN\nELTltZKYEMU9I4HFQyhVYQ50EAYRFw8yH+zYOWivTDD0K+uPaZz65hZJHRlXSnoSSDr2H03672/p\n0+PJvShR4rGeyn5avjxXZCcUWJ/4cXKJ48UnAxIkwMZST2LEUUpr3C3eG9ElMnIxJ3JChocB3cY1\nTCHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5w\nKlMm81nJR8AEQ8s1NDGFK5EfeeaDEuY+DdcXj778PlKIQEoCRbHMogotSnwRX19Vo2gBhpbveV/E\nW/8ugQyzh95ZB7FZ26GALORMlT17P9PLZ8OIvLVWJSaEcZE67tJITF/NBD0Ecw8vffackE9RBoKA\n66Zx9+fKeF1ApdD53DmgdWaEZDviQxqN6IlipFmaAC4H+vvCJvxbBxtXCUviW5khl5f4bo3tLGcr\nWPD3i+UOuHf1WXj7EW1KtOTw5QYLRCRAYQKTsx0WLLZmfgzUFJk2lxPB9Ml0wXP0QcItypC0xEHf\nzb/AMhRHGoweLHEmF/yX+HMeLeNffav/dzno3G31vE5CldCGLoCrTXshaCVPzNcAG1JO1yyv6uKg\nFsw3oBFiHo0QlRoMtJXvRUt/c9Yw/PM1qU04JZJaXKGOU6a3ZZqQlCZ9hxkxvnU4zAvA8O0RrZZb\nO3ACkjtMA7iYvikg79Z8sn4FLjq+zxOXmyueuXjBEXWEwzFxEhm5TKg5E007eDMuvY4aWb7TsrfL\nJHLORslnCd897BkpToMkrBdAPT5OlKrtuwgudoZdYYgSDxo4g/fc3LP3v1UY4vHV0auK3TAoc1PW\nHe9Vp0C6lbxMVOh204CAOuNcsHLs+1vqv1RoeevZhtIFAvCygSkeqUDzg6wdEFpmYb9Xlyw3gjAb\nTFxGH73dWS4Kv00slhHANkHg7MRg1c+qDtu4eRYt5CsdSNJTjocfGodxEq6MCENuOwlTrxZZ5EU1\nTnyNxeWzS8sct6lQgqksmSD//Jy9HJTdduMT9zOnpL/yyozqbnfek92thIRWBiiebqkIC+j8WlBP\nwjvSnzvuaDGG34fyhfyffaNiBQRoDvo0EWzT1HmbAUmYK7Q3XiXYgQ5tQYXXLu2n8hQMtTctn3e1\n9K/z5evDNKQ2humqiFvEzjv8cVfFUs+H69RGjQrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rd\nIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSX\nm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJS\nNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdj\np07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACKR2QcwJNJEySal0qRK3p98Rtn1TMnWUE2wCNkfT7HQADJDsmUgZU0uPLYwmfMOofZz+v\n3I1QIkmxGMgVkOerjwDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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bUe2HXnnYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg23nYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYRw7aNaBu4A2yQTfYhrahLxg5OKFs2JFlR5YdWXbkkYNWBtiGtqEvGDk4oWygDXUDb5ANO7LuyLoj645sO7LtyLYj245sO7LtyLYj245sO7LtyG1Hbjty25Hbjtx25LYjtx257chtR247ct+R+47cd+S+I/cdue/IfUfuO3LfkfuKXK7rCipBFFSDOEiCNMiCWlBolNAooVFCo4RGCY2RkyZOGmRBQ6M59U0jMReVIAqqQRwkQRpkQaFBoVFDo4ZGDY0aGjU0amjU0KihUUOjhgaHBocGhwaHBocGhwaHBocGhwaHhoSGhIaEhoSGhIaEhoSGhIaEhoSGhoaGhoaGhoaGhoaGhoaGhoaGhoaFhoWGhYaFhoWGhYaFhoWGhYaFRguNFhotNFpotNBoodFCo4VGC40WGj00emj00Oih0UOjh0YPjR4aPTT61ijXFVSCKKgGcZAEaZAFtaDQKKFRQqOERgmNEholNEpolNCIPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ABwKCxkAHAoKCwAcCgIKAC0IAQInAhoEDAAIARoBJwMCBAEAIgICGi0KGhstDgQbACIbAhstDggbACIbAhstDh4bACIbAhstDgkbACIbAhstDhQbACIbAhstDhUbACIbAhstDhYbACIbAhstDhgbACIbAhstDhkbACIbAhstDgsbACIbAhstDgobHAoXBAAcCg8IABwKEAkAHAoRCgAcChILABwKEw8AHAoNEAAcCgwNAC0IAQwnAhEEDAAIAREBJwMMBAEAIgwCES0KERItDgUSACISAhItDgQSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgsSACISAhItDg8SACISAhItDhASACISAhItDg0SACISAhItDgMSLgiARQAqIwAAC8MNIgAqgEwAAyQCAAMAAA75IwAAC9gtCwcDLQsDBAAiBAIELQ4EAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHKwIABQAAAAAAAAAAFwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEYACQAiCQIJLgyARgAJACIJAgkuDIBGAAkAIgkCCS0OBQktCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEUABy0IAQgAAAECAS4MgEQACC0LAwkAIgkCCS0OCQMuCIBFAAIjAAAMxw0iAAKATQAJJAIACQAADq8jAAAM3CcCCgQLLQgACy0KBQwtCgQNLQoHDi0KCA8ACAAKACUAABcoLQIAAC0KDAktCAEEJwIFBBkACAEFAScDBAQBACIEAgUnAgcEGAAqBwUHLQoFCAwqCAcKFgoKCiQCAAoAAA1OLgyARgAIACIIAggjAAANLS0IAQUAAAECAS0OBAUuCIBFAAIjAAANZg0iAAKATQAEJAIABAAADmIjAAANey0LBQMnAgQEGC4CAAOAAygAgAQEABklAAAXnC4IgAUABwAqBwQILQ4JCC0OBwUuCIBFAAIjAAANtAwqAgQDJAIAAwAADjMjAAANxikCAAIALRfGuCcCBAQCJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIF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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3fju24kWf9LnXdF+K/CNKvMhg03D2egQHDbrjdH/Ch0e8+W0FFLGae3kzl3llz41quOieWtiT+JJEU9Z+//a8//ct//J9//vNf//ff/v23P/yP//ztX/7+57/85c//55//8rd//eM//vy3vz7+7X/+dpz/k3L97Q/lnx7/bL/9oZ3/lN/+oOc/9bc/jPOf/bc/pHTCeMD5J8vhkByyQ3GoDs1BHNShO3jl6pWrV65euXrl6pWrV65euXrl6pWrV25euXnl5pWbV25euXnl5pWbV25euXll8crilcUri1cWryxeWbyyeGXxyuKV1SurV1avrF5ZvbJ6ZfXK6pXVK6tX7l65e+XulbtX7l65e+XulbtX7l65e+XhlcdZ+TyPRnYoDtWhOYiDOnSHMSEfh0NyyA5n5X5CdWgO4qAO3eFROT9O7JwelXM7ITlkh+JQHZrDo3IeJ6hDdxgX5EflcpyQHLLDWbmcUB2aw6NyORVnE5zQHcYFZxuckByyQ3GoDs3BKxevXLxy8crVK1evXL1y9crVK1evXL1y9crVK1ev3Lxy88rNKzevfLbBch7Tsw1OEAd16A7jgrMNTkgO2aE4eGXxyuKVxSuLVxavrF5ZvbJ6ZfXK6pXVK6tXVq+sXlm9cvfK3St3r9y9cvfK3St3r9y9cvfK3SsPrzy88vDKwysPrzy88vDKwysPrzyuyuU4HJJDdigO1aE5iIM6dAevnLxy8srJKyevfLbBepzQHMRBHbrDuOBsgxOSQ3YoDl45e+XslbNXPttgbSeMC842OCE5ZIfiUB2agziog1cuXrl65eqVzzZY+wnFoTo0B3FQh+4wLjjb4ITk4JWbV25euXnlsw22fII6dIdxwdkGJySH7FAcqkNz8MrilcUri1dWr6xeWb2yemX1yuqV1SurV1avrF65e+XulbtX7l65e+XulbtX7l65e+XulYdXHl55eOXhlYdXHl55eOXhlYdXHlflehwOySE7FIfq0BzEQR26g1dOXjl55eSVk1dOXjl55eSVk1dOXjl55eyVs1fOXjl75eyVs1fOXjl75eyVs1cuXrl45eKVi1cuXrl45eKVi1cuXrl45eqVq1euXrl65eqVq1euXrl65eqVq1duXrl55eaVm1duXrl5ZW+D1dtg9TZYrQ3WB1gbNEgO2aE4VIfmIA7q0B28snpl9crqldUrq1dWr6xeWb2yemX1yt0rd6/cvXL3yt0rd6/cvXL3yt0rd688vPLwysMrD688vPLwysMrD688vPK4KrfjcEgO2aE4VIfmIA7q0B28cvLKySsnr5y8cvLKySsnr5y8cvLKyStnr5y9cvbK2Stnr5y9cvbK2Stnr5y9cvHKxSsXr1y8cvHKxSsXr1y8cvHKxStXr1y9cvXK1StXr1y9cvXK1StXr1y9cvPKzSs3r9y8cvPKzSs3r9y8cvPK3gabt8HmbbB5G2zeBpu3weZtsHkbbN4Gm7fB5m2weRts3gabt8HmbbB5G2zeBpu3weZtsHkbbN4Gm7fB5m2weRts3gabt8HmbbBZG+wnqEN3GBdYGzRIDtmhOFSH5uCVh1ceXnlcleVsg9JOSA7ZoThUh+YgDurQHcYFySsnr5y8cvLKySsnr5y8cvLKySsnr5y9cvbKZxsUPaE4VIfmIA7q0B3GBWcbnJAcvHLxysUrF698tkE5d+bZBid0h3HB2QYnJIfsUByqQ3PwytUrV69cvfLZBjWdkByyw6OylhOqQ3MQB3XoDuOCsw1OSA7ZwSuLVxavLF75bIMqJ3SHccHZBickh+xQHKpDcxAHr6xeWb1y98pnG9Tz6JxtcEJxqA7NQRzUoTuMC842OMErD688vPLwysMrD688vPLwyuOqrMfhkByyQ3GoDs1BHNShO3jl5JWTV05eOXnl5JWTV05eOXnl5JWTV85eOXvl7JWzV85eOXvl7JWzV85eOXvl4pWLVy5euXjl4pWLVy5euXjl4pWLV65euXrl6pWrV65euXrl6pWrV65euXrl5pWbV25euXnl5pWbV25euXnl5pWbVxavLF5ZvLJ4ZfHK4pXFK4tXFq8sXlm9snpl9crqldUrWxscJ4iDOnSHcYG1QYPkkB2KQ3Xwyt0rd6/cvXL3ysMrD688vPLwysMrD688vPLwysMrj6tyPw6H5JAdikN1aA7ioA7dwSsnr5y8cvLKySsnr5y8cvLKySsnr5y8cvbK2Stnr5y9cvbK2Stnr5y9cvbK2SsXr1y8cvHKxSsXr1y8cvHKxSsXr1y8cvXK1StXr1y9cvXK1StXr1y9cvXK1Ss3r9y8cvPKzSs3r9y8cvPKzSs3r9y8snhl8crilcUri1cWryxeWbyyeGXxyuqV1SurV1avrF7Z22D3Nti9DXZvg93bYPc22L0Ndm+D3dtg9zbYvQ12b4Pd22D3Nti9DXZvg93bYPc22L0Ndm+D3dtg9zbYvQ12b4Pd2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OLwNDm+Dw9vg8DY4vA0Ob4PD2+DwNji8DQ5vg8Pb4PA2OM422PMJ2aE4VIfmIA7q0B3GBWcbnOCVm1duXrl55bMN9nKCOKhDdxgXnG1wQnLIDsWhOnhl8crilcUri1dWr6xeWb2yemX1yuqV1SurV1avrF65e+XulbtX7l65e+XulbtX7l65e+XulYdXHl55eOXhlYdXHl55eOXhlYdXHlfldBxHUArKQSWoBrUgCdKgHhSOFI4UjhSOFI6zSXY1akESdA6tH0Y9aDidDfOiFJSDSlANakESFI4cjhyOEo4SjhKOEo4SjhKOEo4SjhKOEo4ajhqOGo4ajhqOGo4ajhqOGo4ajhaOFo4WjhaOFo4WjhaOFo4WjhYOCYeEQ8Ih4ZBwSDgkHBIOCYeEQ8Oh4dBwaDg0HBoODYeGQ8Oh4ejh6OHo4ejh6OHo4ejh6OHo4ejhGOEY4RjhGOEY4RjhGOEY4RjhGO5IxxGUgnJQCapBLUiCNKgHhSOFI4UjhSOFI4UjhSOFI9p5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKdp2jnKdp5inaeop2naOcp2nmKdp6inado5ynaeYp2nqKd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5znaeY52nqOd52jnOdp5jnaeo53naOc52nmOdp6jnedo5zaDaGSjHFSCalALkiAN6kHDydr5pHCMcIxwjHCMcIxwjHCMcAx32KSii1JQDipBNagFSZAG9aBwpHCkcKRwpHCkcKRwpHCkcKRwpHDkcORw5HDkcORw5HDkcORw5HDkcJRwlHCUcJRwlHCUcJRwlHCUcJRw1HDUcNRw1HDUcNRw1HDUcNRw1HC0cLRwtHC0cLRwtHC0cLRwtHC0cEg4JBwSDgmHhEPCIeGQcEg4JBwaDg2HtfNiVIJqUAuSIA3qQcPJ2vmkFBSOHo4ejh6OHo4ejh6OHo4RjhGOEY4RjhGOEY4RjhGOEY7hDpu4dFEKykElqAa1IAnSoB4UjhSOFI4UjhSOFI4UjhSOFI4UjhSOHI4cjhyOHI4cjhyOHI4cjhyOHI4SjhKOEo4SjhKOEo4SjhKOEo4SjhqOGo4ajhqOGo4ajhoOa+dq1IOGk027Pw7DBGawgBVsoIAKdnAECjbBJtgEm2ATbIJNsAk2wabYFJtiU2yKTbEpNsWm2BRbx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sI2w2ncoxgRksYAUbKKCCHcSWsCVsCVvClrAlbAlbwpawJWwZW8aWsWVsGVvGlrFlbBlbxlawFWwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvFRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0skTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCzRmSXFsIINFFDBDo7AmSUTE5hBbA1bw9awzSyphh0cgTNLJiYwgwWsYAMFxCbYBJtiU2yKTbEpNsWm2BSbYlNsHVvH1rF1bB1bx9axdWwdW8c2sA1sA9vANrANbAPbwDawjbD14wATmMECVrCBAirYQWwJW8KWsCVsCVvClrAlbDNLuuEInFky8bSlwzCDBaxgAwVUsIMj0LLkQmwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWwD28A2sA1sA9vANrANbAPbCJtNN3RMYAYLWMEGCqhgB7ElbAlbwpawJWwJW8KWsCVsCVvGRpYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEtGZEk+IkvyEVmSj8iSfESW5COyJB+RJfmILMlHZEk+IkvycWBL2BK2hC1hS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYyvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2BSbYlNsik2xKTbFptgUm2Lr2Dq2jq1j69g6to6tY+vYOraZJcUwgRksYAUbKKCCHRyO6ThAe+oYhhksYAUbKKCCHRyB8xlnIraELWFL2BK2hC1hS9gStowtY8vYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2FjabuDYXwpqJWQ3tPBRDBTs4Amc2TkxgBgtYwQZiq9gqtoqtYWvYGraGrWFr2Bq2hq1ha9gEm2ATbIJNsAk2wSbYBJtgU2yKTbEpNsWm2BSbYlNsiq1j69g6to6tY+vYOraOrWOb2Win2czGiQnMYAEreNrm6WnZeKGCHTxt+Tx/bZab42nLapjBAlawgQIq2MERaNl4IbaELWFL2CwbczcUUMEOjkDLxgtPmy1wZ3PfHAt42koxbKCACnZwBM7lJ2175wKUEzNYQLPZls2FKCdK4FxxMhlasWF4/rU6/+3516odNwuFCxXs4Ai0ULjwrFvNZqFwYQEraDbbBguFC0/budJPtolujiPQQuHCBGbwtDUxrGADBTSb7T4LhQvNZhtpoXBhAjN42sTEFgoXNlBABTt42sQ2x0LhwgRm0Gy2kRYKFzbQbHb2WShc2AOtzV9oxexXzEUp7SSwJn3923PL9NzIOleknJjADBbw3LJzeYdss9ocBVSwgyPQmnQ/DBOYwQKetp4MGyjgaeu2ZdakLxyB1qR7NTTbXAjSbGpYwAo2UEAFT9uYihFoTfrCBGawgBVsoIAKYivYKraKzdr8sF9sbf5CARXs4Ai0BjnmapgHaAo7hMKmC5subLo1kWE7yprIhQp2cARaE7kwgRksYAWxdWwdW8fWsQ1sA5tdIUc3tArD8FHh8UhuOBxtvpdjAjNYwAo2UEAFO4gtYUvYEraELWFL2BK2hC1hS9gytowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9gqtoqtYqvYKraKrWFr2Bq2hq1ha9gatoatYWvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2MiSRpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0meDLIYVbKBtTjNUsIMjcDbIiQnMYAEr2EBsim02yGE4AmeDnJjADBbwtNlgn02achRQwdNm4zg2aepCa5AXnrZkW2YN8sICmk0MGyiggmY7eyVselS2r73Y9CjHAlbwrJsPw7OufRvGpkflnA07OAKt6V142qzn36ZHORawgmZrhqaw7bX2Zj3pNicqW5+5zYnK1vltc6IcM1jACjZQwNNWqmEHzWZia28XJjCDBazgaau2H6y9XahgB09btc2x9nZhAk+bdZ/bnCjHCppNDM1m22DX7gs7OALt2n1hAs02DAtYwQYKqGAHR6Bduy9MIDbBJtgEm2CzqGh2TlpUXDgCLSrsIzo2J8oxgwWsYANPW7P9a1FxYQdHoEXFhQnMYAEr2EBsHVvH1rFZKDTbSAuFCyvYQAEV7OC4sNjsJ8cEZrCAFWyggAp2EFvClrAlbAlbwpawJWwJW8KWsGVsGVvGlrFlbBlbxpaxZWwZW8FWsBVsBVvBVrAVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rAJNsEm2ASbYBNsgk2wCTbBptgUm2JTbIpNsSk2xabYFFvH1rF1bB1bx9axdWwdW8fWsQ1sA9vANrANbAPbwDawDWxkSSJLElmSyJI0s0QMK9hAARXsgTNAsmECM1jACjZQQAU7OAIztowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9gqtoqtYqvYKraKrWFr2Bq2hq1ha9gatoatYWvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2EbZ8HGACM1jACjZQQAU7iI0syWRJJkuub18Owwo28LSd0ybK/AbmhR0cgZYlFybwtInZLEsurOBpk2QooIIdHIGWJRearRlmsIAVbKCACnZwBFqWXIitYqvYKjbLEqmGAirYwRFoWXKh2dQwgwU0WzdsoIAaaKkhdmAtH9SOkOXDhQ08K6gdIcuHCzt4bu/5LZViUwgdE5hBs9kPsny4sIECWl3bfdbmz6kxxaYFOlbQfrEprM1fqGAHR6C1+QsTmEGz2f61Nn9hAwVUsIPD0aYFOiYwgwWsYAMFVLCDZjuPsU0AdCxgBRsooIIdpK617gsTiC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKr2Cq2iq1iq9gqtoatYWvYGraGrWFr2Bq2hq1hE2yCTbAJNsEm2ASbYBNsgk2xKTbFptgUm2JTbIpNsSm2jq1j69g6to6tY+vYOraOrWMb2Aa2gW1gG9gGtoFtYBvYRtjqcYAJzGABK9hAARXsILaELWEjSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0smROxjxnMZc5GfPCBgqoYAdHoGXJhQnMILaMLWPL2DK2jC1jK9gKtoJtBsgwbKCACnZwBM4AmZjADBYQW8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWwD28A2sA1sA9vANrANbAPbCNucgXlhAjNYwAo2UEAFO4gtYUvYEraELWFL2BK2hC1hS9gytowtY8vYMraMLWPL2DK2jK1gK9gKtoKNLBGyRMgSIUuELJkzMM93QMqcgXm+4lHmDMwLM1jACjZQQAU7OAIbtoatYWvYGraGzbLkfA+lzBmYF3ZwBFqWXJhAs2XD0zYmVrCBAirYwRFoWXJhAjOITbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1js9Q4F3Uuc1ZlF8MKWgU1FFDBDg7HOavywsf2lnOWTLFZlY4FrGA7MRsKqGA/sRiOwDMfHM1WDTNYwAqarRlaXTEcgfkAE2h1u6HVHYZn3fMF/GLzJx/dLobnr0i2ZWcSlGTiMwkcR+CZBI6nLdmWnUngWMAKms12dTGFbc7Z/Eu2zTmbf8m2f8/mX7Jtztn8Hz0whhksYAUbKKCCZrNtqCPQ2rydXHOm5IUFrGADBVSwgyNQDhCbYBP7QbZLpIINPH9QsR11tnnHDo7As807JjCDBaxgA7EpNjWbba+OwH6ACcxgAc1me703UEAFzWbnbx+B4wBPW7UtG5Ewc6bkhRVsoIAKdjDybM6UvDCBGSxgBRsooIIdxJawJWwJW8KWsCVsCVvClrAlbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawFWwFmwXI+Q50sZmSjudZUu0PWIBcmMAMnudkbYYVbKCACnZwBLYDNJsYZtCuWWpod0HzzypodecfGIFygAnMYAEraL9iGAqo4Glrh+EItNS40GzdMIMFjKGMOZ3zQgEV7OAInE8dExOYwQLaEIlt+hwimWi/wo685cNEy4cLE5jBAlbw3GetGAqooNmq4XC01e4czZYNM1jAGK6a0zkvFFDBDo7A+XwxMYEZLKD9imaoYAdHoN0/2CwOm8PpmMEC1usF2jLXtbtQQAU7OALnC9UTE5jBs26ZeP4KG4+12ZqOHRyB1uYvTOD5K2xI0mZrOlawgWazXWJt/sIOms32g7X5CxNotm5oNvsV5/1DOd/WLzZb01FABTs4Ai0JbPjSZms6ZrCAFWyggAp2cAQqNsWm2BSbYrP7BxsLtdmajgqazfaO3T9MtPuHCxOYwQKeNntKstmajgIqeNrOT94Wm615oeXDhafNnr5sDucjRgwLWMEGCqhgB8eF1eZwOpptGGbwtJ1fSqs2h9OxgQKetvN2sdocTscRaM8XFyYwgwWsoNmqoYBma4YdHIGWGhcm8KGwZZGqTdws5+oC1SZuOgqoYAdNYXvHHjUuTGAGC1jBh60e9tvOAHFUsIPjRNveM0AcE5hPtN92BohjBc2mhmazw13NZptTOzgC2wEmMIN2STKSIA3qQcPJUsLobMH1fLSrNnPSMYMFrGADBVSwgyOwY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2ETabOemYwAwWsIINFFDBDmJL2BK2hC1hS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYyvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2MiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSZ0NvRpWsIHWrWWkQT1oOFlX5KQUlINKUA1qQeGo4ajhqOFo4WjhaOFo4ZjNWgwbKKDtwm7YwXMXnqOx1WZPOiYwgwWsYAMFVLCD2BSbYlNs1qyzHTBr1hc2UEAFO2i2s/vHZk86JtB6YYxKUA1qQRKkTtZ0s50u1kjPdRSqzYWs2fa3NdILBVTQttSOgjVSQ5sL6ZjADFrHpVENMtcwFFDB03WuMVxtJuSF1kQvPF3n4G21mZCO5y87V2eoNhPSsYGnrRlpUA8aTtY8J6Ugqzjx/MtFDG1L1XAE2sX7wgTaltoPtDZ9YQUbKOBps/1m1+5Jw8mu3FbeLtyTclAJqkEt6JTY+WEzGx17oF2dLzz/frWdbw32wrOC7Qhrr5N60LmV1Q6NtdYLE3hu6Ny91lovNJVVsNZ6oW2sbbe11vnzrbVW20/WWs9BrWpTFR0TmMECVrCBAtqpYttrrbXZqWSttdn2WrtstpHWMJttpLXMCxsooIIdHIHWUJv9TGuoFzZQQAU7OBxt8mA930KsNnnQUcEOnn/tHKiqNnmwnu8FVps8aL/d5g5eVIJqUAuSIA3qQcPpbG4XhSOHI4cjhyOHI4cjhyOHI4ejhKOEo4SjhKOEw1rb+VJltTmAdjLYFMCLUlAOKkE1qAVJkAb1oHC0cLRwtHC0cLRwtHC0cLRwtHC0cEg4JBwSDmtrYnvB2tqFHbQzxE4Wa2vnQGS1qXxV7byxVqV23lhLOV9crDYRr6r9WbuuXZhByys7Ya39XNhAARXs4Ai0a96FZhPDDBbwtHX7bdaUum2ONaULLXHPP2vT8xwTmMHif82m5zk2UEAFOzgC7VJ34XmAulEJqkEtSII0yIqr4Qi0C92FBbTNs79mlzobFLR5d44j0C51FyYwgwU8d4aNGtq8O0cBT9tIhh0cgXa1s/FBm4LnmMECVrCBAirYwRHYsDVsDVvD1rA1bA2bXSBtENNm4zmOQLsY2nClTbarNu5o0+outJY27AhZSxt2hOyqdmEBrYLtdbuqXXieGDbCaJPimg0V2uS1dphiJDCDBTxPNxtWtMlrjgIq2MHhaNPUmo1G2jQ1xwpa3WEooIIdHIHpABOYwfPPnnNMq00yc0xgBgtYwXPLUjIUUMEOjkC79FxotmyYwQJW0GzF0OpWQ6t7HjebTuaYwAwWsIINtF8hhgp20Gx23OyqdGEC7Zphe2demCZWsIECKtjBETivT7bP5gXK9oNYBdsPomAHR6DaltnP1AJWsIECKtjBEdhty2zvWBu6MIMFrKApbJ91DbSmZw9KNter2eOPzepqxfaDNRx75rFZXY4P8bleQbVJXReVoBrUgiRIg3rQcLJWVLJhAjNYwAo2UEAFe6C1OHtgs2lbzR7NbNrWOUWp2qytizSoBw2ns1ldZBWbYQYLWMEGCmi7+TxQNjWr2QObTc1yPCvYH7XmM0mCNKgHDSdrOfYsZ5OyHDNYwAo20G5ozxPCJlo1e/iyiVY6qQTVoMdf1/lXJEiDetBwOq8vF5nEDpE1owsLKKDdYtsxtKZxYQLPU9R+xtkyLqpBLUiCNMh+uO3FPgKt1VyYwAwWsIINFFBBbMNtzWZLtfPBs9lsKccMmm0YVtDOk8PQTpRkaGdKMezgCLQG2ExsDfDC03Y+YjabLdWaic8GqPNvtSAJ0qAeNJzsYnfeGjabBtWabbRd1sS21C5rF3bw3NLzoajZNCjHBGawgFbXxNbUzqeIZlObmtgPtAvYhRksYAUbKKCCHTSb7Thrhhcm0Gy2O60ZXljBBprN9pldwC7s4Ll7rex5/booBZ3t1bbK2uukGtSCJEiDTGLHyK5xE/UAE1jBczPVTkK7ml14VlA7ntZkL0zguaVW4GyyF9WgFiRBGtSDhtPZYC9KQeEY4RjhGOEY4RjhGOEY7rApUReloBxUgmrQeWTPSaLNZkM5Kmi7rBqOQGuhF9ouE8MMnufRVNgl8sIGCqjgaTtfe242G+pCu1U9Xz9sNhuqddsya73nfNFms6EcK2gPg7aR1qYvVPBhu2oNp7NFX5SCclAJsorN0LbUfra15vMBstncJscMFtC21H62teYLBVSwg+em2u+zxjxst1hjHvPfZvCUDdvGs9le//Kc733Y77dPvR1W1T71dmEFz+06H6aazUtyVLCDI9Ca5IUJzGABK4hNsSk2xWbNd9hGWvO9MIEZLGAFJfaDfbzqwg7ajjKbfbzqwgSeF/XDztCz+TpWsIECKnje0h12Pp2NeKJNRpLzdcZmk5EcM2gzeQ/DCjZQQAU7OALj49otx8e1W46Pa7ecsCVsCVvClrAlbAlbxpaxZWwZW7Y9WQwbKKDtyWrYwRFot8cX2p5shrYnxdBsVmx+XHtiA82mhgp2cATWA0xgBgtYwQZiq9gqtvkBWTtL5gdkJyYwgwWsYAMFVLCD2ASb2G/rhhksYAUbKKCCHRyBeoBmG4YZLKCAZ4VkTeQMBZnbe4aCYwYLeG7vPNx2J36hgAp2cASOA0xgBguIbWAb2Aa2gW2EzSYYydkT0myCkaPZxLCAFTSbGgqoYAdHYDrABGbQbN2wgg0U8LSdvRvNJhg5jsAzHxwTeNrOrodmE4wcK9hAARU02zAcgZYPFybwtBUTn/ngWMHTdj7IN5tgJMUUlg8XdnAEWj5cmMAMFrCCDcRWsVVsFVvD1rA1bA1bw9awNWwNW8PWsAk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTbFptgUW8fWsXVsHVvH1rF1bB1bx9axDWwD28A2sA1sA9vANrANbCNsNsHIMYFmE8MCmk0NGyiggqft7K1pNsHoQsuSCxOYwQJWsIGn7ez6aTbByNEuHWfjtVlFjgk0RTEsoCnsF1uAXCigKezHW4BcOAItQKwHxBaCc8xgASvYQAEV7OAIrNjOqLD7eZupdFELOu/255/ToB5kFc88tqlKjgnMYAEraNtve9ZC4kIF7Tbajth83jC0m4gLE5jBAlawgQIqiE2wKTbFptgUm2JTbIpNsSk2xWYh0SYmMIPFn9bqfAqZaM888w8IqGD3Zzhb7O1CC4lznLrZYm+OZrMzwELiwgrab5sooIIdHI42wcnR6lbD88hb15xNWxLrmrNpS44j0Br+hba93TCDBaxgA0+bdaTZvCXHDo5Ay4ALE3jarMPLFnBzrGADzaaGCnbQbOe5bhOdxDpLbKKTYwYLWMEGCqhgB0dgxVaxVWwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtgE2yCTbAJNsEm2ASbYBNsik2xKTbFptgUm2JTbIpNsXVsHVvH1rF1bB1bx9axdWwdm+WDdXLbWm6OZrPGa/lwYQUbaDY71+0m4sIODkdby80xgRksoNm6YQNNMQw7OAItQC48FdYxaJOwHAtYweYZZROxHBXs4Ai0ALkwgRksoFz9cTb56qIedPbW2Q+3jsVJKci2PxkWsIINFFDB01SNhtMZERfZrsqGGSzgefNge8puHiZJkAb1oOF0ZsNFKSgHlaBwtHC0cLRwtHC0cEg4JBwSDgmHhMPCYO57C4MLFbRhVDt0FgYTLQzmQbEwuDCDttPsZLUwuLCBAirYwRFoYXCh2ezEtjC4sIAVtHFCO+5zoHCigh0cgRYGw463hcGFGTz346Qa1IIkSIN60LjIpoRdlIJyUAmqQS1IgjSoB4UjhSOFw0LA7nttSpicE4WazQlzbKCACnZwBFoIXJjADGLL2DK2jM3uIuz22+aQOY5Au4u4MIEZPEdvrC/T5pA5NlBABTs4AusBJjCD2Cq2iq1iq9gqtoqtYWvYGraGrWFr2Bq2hs0GGK1Pd84WS0YtyP7SMFSwgyNwjvtPTKDNLrBTSwtYwQaeNuuKs4XZHDt42pJt7dn+HRNoNjtdbMjxwgo20Gx2YtgQo3Wv2Sw2xwRm8KxrfWo2i02z7SgbaMzWmGykMdv22lCj9Z7ZLDbNJrbBRkNbgs0xgaftnNnTbG6bYwUbaLZhaOPzydAG6M/NsQltes6TaTahTa17wia06fkaRbN11xwr2EABFeyg2Wwb8gGeCjuNbB6cYwVPRbWNPJu5o4IdHIFnM3dMYAYLWEFsBZs1c+upsNlxjiPQmvmFCcyg2ewXWzO/sIEC2kD8YdjBEWjN3J5EO82808w7zbzTzDvNvNPMO83cZsc5Rqh0OUBsgk2wCTbBJtgEm2ATbIpNsSk2xabYFJtiU2yKTbF1bB1bx9axdWwdW8fWsXVsHdvANrANbAPbwDawWWpYF4MtzOZoZ8n8A8PRpvA5JtDmhahhASvYQAEV7OAItACxHgSby+dol9VhaHUnCqhgB21qy3mu28JsjgnMYPFJAXOG34UNFFDBDsa0Apvm53juHZuHZDP6HBsooII90JLAukRsRp/alCSb0qc2Jcnm9DkqaBWa4Qi0Nm99JjavzzGDtr12LKzNX9hAARXs4AicM4rsEM4pRRMzWMAKNlB8BtCc9Df3g7XuC9k71rqtj8em/TlWsIECnr9iKqx1XzgCrXVfeNrskd2mCDoW8LTZE7nNEnQU0Gx2LKx1XzgCrXXblCabKKg2P8cmCqo9kdtEQbXHcJso6NhAq2u/zdrxiWJTAh0TeNY9n73FJv/ZySU2+c9RwR5ozfTCck2TE5vb59hAuSbPiU3vc+zgCLSZQxcmMIMFrOC5kecDtti8P8cRaJfxC88ffz5Ni837cyxgBX2WoczZgBcq2MERaLOKLkxgBgvos1Jlzga80H7FxBFojffCBNqvsP1gjffCCjZQQAVtDunEESgHmMAMFrCCDRRQA63xnk/xYhMAHTNYQPsVYthAARW0X2HHeM7vNZzzeycmMIMFrGAD7Vio4Qi0ZnphAu1XdMMCVrCBAirYweE4JwqenQoyZwpemMEC2mTBw7CBAipoU9zVcATOCfUTE5jBAlawgQJa3fNMtXmBevZxiM0LdMygzXjMhvYrmmEDBVSwgyPQ2vyFCTSbGFpd20hrx+ekfrF5gDpsr9uN94UFrKBVsL1uF+ELFezgCLR2fGECc2zDnFw/sYINFFBBfoW144nWji88p0MeduTPFtsP2+tni3UUUMGz0/Kww3JehC8827Hj2UN62DE+27FjASvYQAEVNJttr47AfoBms6PZM1jACjZQQAXNZudDH4HjAM1mZ8nIYAEr2EABFTSbnTtjONoEQsfTdk6nE5tA2M8ZT2ITCPvZbSE2gbCfHRRiEwgdBVTwtJ39D2ITCPvZ/yA2gbAns6UEZrCApy3b5pytu5/9D2ITCHu2LTuv6I4dHIHZftswTGAGC2jnutnsxvtCARXs4Ai0G+8LE5hB+xW2J4uACnbQfoXtSeuivzCBGSxgBRsooAY2q9sME5hBq2uHsFWwgQJqoFhdO9zW5rMdTWvzFzZQQAX79eKmzFXHJsbrnDJXHbswgwWsYAMFtP1rR95a94UJzOD5K+YhtBZb7ES0FjvRWuyFZ4ViZ5+12AsLaENAdoytbRbb1dY2i+0+a5u2H2zynmMCM1jAClpdNezgCLRWeGG6Xl2WuQ7YhQWsYAMFVLCDI9BW6Tln5Mhc8evCCp7nw9mVJmUOkE08f4XdBdmEPMcRaINkZ+eW2IQ8xwyee8fu+2xCnmMDBVTQbLZ35jiZ4Rwom5jADBawgg20urZL5joh9iusZVX7xdayLhTw3LJmO+q8xjqeW9asgrW3CxN4blmz/WCt8MIKNlBABTtotvOktel0jgnMYAEr2OIX2zW22a62VjjRWuGFCbS6zbCAFWzgeU5aG5orc13YwRFoSx1cmMAMFtD2zkQFOzgcbYpcP3uTxKbIOWawgGcLsKSda3BdKKCCHRyBttjIhSnQZqRnu12xGWPBunBfeMDnWR6cFs4Ll4Xrwou3Lt66eOvibfPf275ofeEBy7FwWjgvXBauC7eFZeHFK4tXFq8uXl28unh18eri1cWri1cXry5eXbx98fbF2xdvX7x98fbF2xdvX7x98fbFOxbvWLxj8Y7FOxbvWLxj8Y7FOxbvwDtnizmnhfPCZeG6cFtYFtaF+8KLNy3etHjT4k2LNy3etHjT4k2LNy1eu4jYU59NyHJMYAYLWMEGCqhgB7E1bA1bw9awNWwNW8PWsDVsdhmyh1ubkOWYwAwWsIINFFDBDmJTbIpNsSk2xabYFJtiU2yKrWPr2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGthE2m5DlmMAMFrCCDRRQwQ5iS9gStoQtYUvYEraELWFL2BK2jC1jy9gytowtY8vYMraMLWMr2Aq2gq1gK9gKtoKtYCvYCraKrWKr2Cq2iq1iq9gqtoqtYmvYGraGrWFr2Bq2hq1ha9jIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiFLhCwRskTIEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCxRskTJEiVLlCzRmSVqaLM0D8MOjsA5GXRiAjNYwAo2UEBsDVvDJtgEm2ATbIJNzJYMBVSwgyNQD9BsxTCDBTSb7TNtoIAKdnAE9gM02zA8bdaPa3PDHCvYQAEV7OAIPLPEMYHYBraBbWAb2Aa2gW2EzWaMOSYwgwWsYAMFVLCD2BK2hC1hS9gStoQtYUvYEraELWPL2DK2jC1jy9gytowtY8vYCraCrWAr2Aq2gq1gK9gKtoKtYqvYKraKrWKr2Cq2iq1iq9gatoatYWvYGraGrWFr2Bq2hk2wCTbBJtgEm2ATbIJNsAk2xabYFJtiU2yKTbEpNsWm2Dq2jo0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkjGzJBtWsIECKthBs533nmNmyUSzDcMMFrCCDRRQwQ6OC/WYWdINE5jBAlawgQLaGyzJsIMjcL7EMjGBGSygvSxTDRso4Gk7BzLVpsA5jkDLkmw/07LkwgyetnP0Um0KnGMD7e51/lmziWEHR6BlyYUJzGABK2g2U1iWXKhgB0egZcmFCczgaav2KyxLLmzgaau2DZYlF3bwtJ0jZmrT5RwTmMECVrCBAp62ZofQsuTCEWhZcmECM1jACprNNt2y5EIFOzgCLUsuTGAGC1hBbIrNsqRZY7AsuXAEWpZcmMAMFrCC9kQ1UUAFOzgCLUsuTGAGC1hBbAPbwDawjbDZ1DrHBGawgBVsoIAKdhBbwpawJWwJW8KWsCVsCVvClrBlbBlbxpaxZWwZW8aWsWVsGVvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBVbxVaxVWwVW8PWsDVsDVvD1rA1bA1bw9awCTbBJtgEm2ATbIJNsAk2wabYFJtiU2yKTbEpNsWm2BRbx9axdWwdW8dGliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLJkkyWZLIkkyWZLMlkiU3kG+d7H2oT+Rw7eNrOWe9qE/kcE3jaznc51CbyOVbwtJ1vg6hN5HNU0Gy2OZYlEy1LLjxt5wsRahP5HAtotmHYQAFP2/nGhNpEPscRyH1J5r4kc1+S532JFZv3JRMbaHcKxVDBDp42u2mw6X2OCbTfpoYFrOBpU7PNFXwmKnjauh03y5KJliUXnrZum2NZcmEB7ZQznKFge2eGwsQMFrCCDRRQwQ6OQMWm2BSbYlNsik2xKTbFptg6to6tY+vYOraOrWPr2Dq2jm1gG9gGtoFtYBvYBraBbWAbYSvHASYwgwWsYAMFVLCD2BK2hC1hS9gStoQtYUvYEraELWPL2DK2jC1jy9gytowtY8vYCraCrWAr2Aq2gq1gK9gKtoKtYqvYKraKrWKr2Cq2iq1iq9gatoatYWvYGraGzW4wzhd61OYrjvONFLX5io4j0LLkwgRmsIAVbKCA2ASbYFNsliXnnFS1+YqOBaxgAwU0WzPs4AjsPrqjZUbFxAYKqGAHz2LnCzJqkxQdE3hu+vnKitokRccKnrZhh8Wi4kIFOzgcbeqiYwIzWMAK+siV1kNABc1WDEegRcWFCcxgASvYQPttYqhgB0egRcWFCcxgAWugNelhv8Ka9IUN9D4xrdGXqTX6MrVGX6bW6MvUGn2ZWqMvU2v0ZWqNvkyt0ZeptWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2ASbYJO4G7Q5mo4VjLtBm6DpqKAdzW44Aq1JX5jADBawgg0020QFO2i28z7KpmQ6JjCDBaxgAwVUWwTQWs5cPvziAc8FxC9OC+eFy8J14bawGNuOnMv2XdwXHsHXyn0Xp4XzwmXhurDdjR6GAipo+3YYjsD5FDFxGsU4L1wWrgu3hWVhXbgvHPf3tuSfYwKnVI3LwnXhtrAsrAv3hQdcbPday7C1/4LzwmXhunBbWBbWhfvC5k32u+qsU4zbwrKwLtwXHnA7Fk4L54Wjw9YmlDo2cEqrsS7cFx7wXAX04rRwXrgsPH+s7fC5FOjFsrAu3Bce8FwP9OK0cF54eu3snWuCXtwWloXNm+0AzXVBLx6wzf92TgvnhcvCdeG2cHSM23RTxw5O6XnD0GbgXJwWzguXhevCbWFZeP5YOygzcC4ewTID5+K0cF64LFwXbgvP+ucJJjMuzrfPVGZcXNwWloV14b7wgPOxcFr4vAbY87zNI3Ws4JR2Y1lYF+4LD3jGxcVp4byw/djzxTOVGRcXt4VlYV24LzxgewPEOS1sXhvksZmlwXXhtvD02gGa8XJxX3jAM14uTgvnhcvCdWEbo7Hj3wRUcEqb8YBnvFycFs4Ll4Xrwm3h+WPtoMx4ubgvPOAZLxenhfPCZeG6sNU/35xTmTFy8YBnjFycFs4LW/1qB3fGyMX2u8436FSu755Mnl47uNeXTyZPrx2ImSQXT6/tn5kkF0+vHZeZJBdPr7WsmSQXT6/99pkkF0/vmWY6k+Ri855vyanOJLnYvOfLcaozSS42rw202ezTYPOeb6+pzoS52Lw2gGYzUIOntxnnhadXjOvC06vGsvD02m+ZiSS2/TORrCNWZyKJbedMpIvzwmXhunBbWBbWhfvCAy6LtyzesnjL4i2LtyzesnjL4i2Ltyzeunjr4q2Lty7eunjr4q2Lty7eunjr4rWnKOtvnTNVL8zglNqJMRPp4rawLKwL94UHPEPp4vlj7YSZoXRxWbgu3BaWhXXhvvCAZyiJ/a4ZShfnhcvCdeG2sCysC/eF7W7cznF7vrowgVPajcvCdeG2sCysC/eFBzyTSq01zaS6OC9cFq4Lt4VlYV24L2zec4Ul7TOpLp5eMZ5eNbYeqWRYwQYKqGAHo8N/Tmy9MIEZxJawzXSyY9FnOl2sC/eFBzzT6eK0cF64LFwXNu+5KJT2mU4X68J94QHPdLp4/vlq3Bce8EyVi9PCeWHbTuvc6zNVJs9blG7Hbt6iXFwWtj9vvXZ9BsLFsrAu3Bce8AyEi9PCeeGy8OKdgWA9Zn0GwsW6cF94wDMQLk4L54XLwtNrv30GwrB9OAPhYl24LzzgefdycVo4L1wWttPWNsF6XS4UcEqtcc1AuHjAMxAuTgvnhcvCdeHzx9q3HdSmpQbrwn3hEWxTU4PTwnnhAs8uUjUsYAWjC49ppMo0UmUaqTKNVJlGqkwjVaaRKtNIlWmkyjRSZRqpMo1UmUaqTCNVppEq00iVaaTKNFJlGqkyjVSZRqpMI1WmkSrTSJVppHpNIx2GGSxgTNm7ppFOFHAe1GTcFx7w/N7axWnhvHBZuC5sU/cmCqjglGbjAc/Prl2cFs4Ll4Xrwm3heQY3Y124LzxgPRZOC+eFy8J14ekVY1lYF+4LD7gfC6eF88Jl4ZgeOSeaXijglFor6n3hAY9j4bRwXrgsXBe2HzvPwxkTF+vCfeHh3I8ZExenhfPCZeHonO3HfMK5WBbWhfvCA07HwmnhvLD1+pnWcujCBto+HoYKdnD+0nTy/OrjxWnh+UuLcVm4Ljz3cDWWhXXhuYfVeMDlWDgtnBcuC9eF28Ky8PR2477wgOuxcFo4L1wWrgu3ha3Lz3aDjQ5d2MEptR0+A+ritHBeuCxcF24Ly8L2Y8+Vt/pxfRhy8oCvT0NOTgvnhcvCdeG28OxXNdbojO6H5oXLwnXhtrAsrAv3hQfcfWpQn5NRL8xgdEb3Yz6rXNwWloV14b7wgMexcHRG92PkhcvCdeG2sCysC/eFoxO8p/msYgc3zWeVi/PCZeHojO7paAvLwrpwX3jA6Vg4LZwX9ilYfU5VvbCB0Rnd09XJO7kvPOB8LJwWzguXhaMzuqfcFpaFdeG+8IDLsXBaOC88658nWKrRGd1TTQvnhcvCdeG2sCysC/eFx9WV3ecc1AsTGJ3RPc0nn4vrwm1hWVgX7gsPWKIzuidJC+eFy8J14bawLKwL94Vn/6z9rqt/dnJaOC8cndE9aV24LSwL68J94QH3Y+G0cL66svucoXphBaMzul8fq75YF+4LD3gcC6eF88LRGd3TqAu3hWVhXbgvHJ3gPR/HwmnhmfnVuC0sC+vCfeEBz49Vn2ti9etr1RfPa40Yl4WnV43bwtNr2za/WX3x9A7jAc8bGLvzub5bfbF57WS7vlx9sXnP1QF7njcwF5vXTrY8b2AuNq+dGHnewEyeNzB2vPK8gbl4eu03Xt+wnjy99huvr1hPnl77jfMG5uLptd84b2AmzxuYar9x3sBcbN5qv3HewFxsXguQPG9gqm2/JVKqts3zIcvO7Twfsi4e8LyHuTgtnBcuC9eF28Ky8OJti7ctXlm8snhl8crilcUri1cWryxeWbyyeHXx6uLVxauLVxevLl5dvPPtGzvd5ts3E0fgfMiqdmLMh6yL88Jl4bpwW1gW1oXtxzY7YeZz1uT5nHVxWjgvXBauC7eFZWHzNjsJ53PWxSO4zOesi9PCeeGycF24LWxvOFVDBTs4pedOLjOpLk4L54XLwnXhtrAsPH9sM+4LD3gm1cVp4bxwWbgu3Bae3mGsC5v3HL7qZSaV2M4p/gJZn3NpL8xgASvYQAEV7OAIrNgqtplO5yhLLzOdLq4Lt4VlYV24LzzgmU4Xp4Wn186BmU4X14XbwrKwwjNVzsGMXmaqXCwL68J94QHPVBE7XjNVLrY/r3bsZq/L5BkIF9ufV9ueGQgXl4Xrwm1hWVgX7gsPeAbCxYt3BsI5cNLLDISL68JtYVlYF+4Lj+A6A+Fi854DDL3OQDg/etHrDISL68JtYVlYF+4LD3hmwsX+3mOfM2QvLKBJz5GbXmcgXCwL68J94QHPQLg4LWw/9hwR6XUGwsV14bawLKwL94UHPG9dLp51xFgW1oX7wgOetyIXp4XzwmXhuvDirYu3Lt66eOvibYu3Ld62eNvibYu3Ld7Z2LudbLOxX9wXHvC8Fbk4LZwXLgvXhW3yrR1eEVDBKbUTbCbG5JkYF6eF88Jl4bpwW9h+7DDX7O+9uC884Jk8F6eF88Jl4bqwec8Z632ujeqsC/eFBzyT5+K0cF64LGwTnO1ctqn4Fwo4pcW4LzyC52Rc57RwXrgsXBeeP1aMZWFduC884Bk7F6eF88Jl4elV41l/GPeFz/r5HL7qNvc2OC2cjZNxWbgu3BaWhXXhvvCAy7FwWnjxlsVbFm9ZvGXxlsVbFm9ZvHXx1sVbF29dvHXx1sV7LaicjXXhvvCA27FwWtheUDlPwzldM9tz2Jyu6dwXtpL2TDanazqnhfPCZeG6cFtYFtaF+8KLNy3etHjn2rv2HDOna2Z7pJhTNK9/P0+rc8JYl3lanZPEuszT6uK2sCysC/eFBzxPK3u8mLM0nfPC5rXHgjlLM9sd+pylmc9JZX3O0sz2ZDBnaV6/ZZ5WFy+/cZ4y1t8wZ2A6t4VlYV24LzzgecpcnBbOC5vX+jPmDMxsfRg2AzNYFtaFzWt9G3MS5sVzje+L08J54bJwXbgtPOvb/pxrdlu/yJxIma0vZE6kzNb/IXOd7otlYYXnetwXzzq2/+e62xfPOnaOzfW1rV9kTnTM1hcyJzo6t4Xn+Wb752qDk/vCI1ivNpiN08J5+TNl4bpwW1hi/8yJjs594QHPdbFtP8wJjfO3zwmNzg2e5/C5Jk+fk/pysr87z+HJMxovTgvnhc1lwxFz8l62wa45ec+5LzzgeT5fnBbOC8/6w7gu3BaWhXXhvvCA5/lswxRz/p5zXrgsXBduC8vCuvBss3Yc5zr1F6eF88Jl4bpwW1gW1oX7wou3L965Tr2Ny81pe85l4bpwW1gWXo5pX45pX47pWI7pbDvn53L6nGKXrd93TrFzTgvnhee2NeO6cFtYFtaF+8IDntepi9PCeeHFmxZvWrxp8abFO69x9nvnFLts/dZzKp1z5TfO69rFsrAuPH+LGg94Xtcunr+lG+eFy8KLtyzesnjL4p2ZcPFy7Opy7Opy7Opy7K5r3+TFWxfXdftj23bd/kzOC5eF523XMG4Ly8K68Dw/D+MBz7Z/cVo4L1wWrgu3hWVhXXjxyuLVxauLVxevLl5dvLO92ySLOfUu27j6nG6Xbdx7Trdzrgu3hWVhXbgvPLfZjtHVlienhfPChe2Z19CL28KysC7cFx7Bc8adc4JtDWnrT7FJdo7lxGFYwQYK+LB36+60SXaOI9DWkL4wgRksYAUbKCA2WyLantptDl0X+0G2RLT1OtocOscGCqhgB0egLRF9YQIziK1iq9gqtoqtYqvYGraGrWFr2Bo2W27eHrJt7pyjBtrC8hfan22GAirYwRFoi8VfmMAMFrCCphBDBTs4Am2F+AsTmMECVrCBpjjT2yasdevqtflqjhm0Ynb+2gLwFzZQQAU7OC4cNk3NMYEZrGC/GtmwGWcXzkXdD8ME5quRjSMa5LDZZtYChs02cxRQwQ6OwGiQ44gGOY5okOOIBjmOjC2z6ZlNtzXbL0xgBgtYwQYKqCC2gq1iq9gqtoqtYqvYrOl1w8aPt5bVbf+2Gru6NVBABTs4Aue3ySaiEPavsH+F/SscTeFoCkdTOJqz6SXDcmXfONRDYdh8L0cBFezgCOwHmMAMFhBbx9axdWwdW8c2sA1sA9vANrANbMMDbxxDwe6YZoOc6IE3bEKWYwdHYDrABGawgBVsoAfeSKmDIzAfYAIzWMAKNlDAfmXfSMUDb6SSwQJGGqXSQAEV7GAEXqoHmMAMFhDF/LLKedKm+TGUiR3kD8yPoUxMYAYLWMEGCohNsAk2xabYFJtiU2yKTbEpNsWm2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBthm1/WvTCBGSxgBRsooIIdxJawJWwJW8KWsCVsCVvClrAlbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVG81/foX3QmwNW8PWsDVsDRtZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUvKzJJiWMEGCqhgB0fgzJKJCcwgtowtY8vYMraMLWMr2Aq2gm0mwXmbZPN25r2yTdtxLGAFGyiggh2Mu/jr470TsQk2wSbYBJtgE2yCTbBZ0+sT4xbbVrWbd/zXt3knxl389W3eiQnMYAEriKILqGAH45msjANMYAatmJ2I8043G8Z99fwgr+H8IO+FCcxgASvYQAEV7CC2hC1hS9gStoQtYUvYEraELWHL3pkxak5gBltgibv4WhKYwQJWsIECKtjBeGaoNe7ia81gASvYQAEV7GA8M9R2gKZQQyvWDQVUMO7ibSLNhXKACcxgASvYQAEVRKFx0laNk7by6Fl59Kw8elYePSuPnpVHz8qjZ+XRs/LoWXn0rDx6Vh49K4+elUfPyqNn5dGz8uhZefSsA9vARoOsNMh2xEnbeCBtRwbjpG08ejYePRuPno1Hz8ajZ+PRsyUBFexgnLSNR8/Go2fj0bPx6Nl49Gw8erasYAfjpG3lAOOkbSVO2lYEVDBO2sajZ+PRs/Ho2Xj0bDx6zo8JX9hAARVEYReJc67nmJ/LvVDBDo5AO38vTGAGC1hBbHb+nqtnjPm53As7OALt/L0wgRksYAUbiG1gG2GbH7s9lwkc82O3WgwV7OAItPP3Qtuyamjb0AwbKKCCHRyBFvwXWl0xzGABK9hAARU0mxqOQDtpL0xgBgtYwQaaoht2cATaqXxhAjNYwAo2UEBsFZud1ecaI2N+y/bCBGawgBXkYDUOVuNgNQ6WRIDMT9Wec4bH/FTthQ0U0O7E7JSzG7gLR6A9UV2YwAwWsIINFBCbYlNsHVvH1rFZO+7WLqwdX2gV7LS3VtjttLdWeGEFGyjRyGYrnNjB4Tg/NHthAjNYwAo2UEAFO4gtYbOLj/22+XXZczWYMb8je6H6D5rfkb1wBFrjvdB2qhhmsIC2o9SwgQJiy9gytoLNGu+FGSxgBRsoILYyFf/1X//021/+9q9//Mef//bXf/7H3//0p9/+8J/xL/79tz/8j//87d/++Pc//fUfv/3hr//xl7/802//3x//8h/2h/793/74V/vnP/7498d/fZz+f/rr/3r881Hwf//5L3866b/+ib99PP+r53JK5frrjz7slKPEoxv7Q5H0vEg/57JYiV5GFND64e/n539fDv8Fj5hlA+S4vQHnTcjcgH4824C62YAzpOzvP1rEKxswku/ExwPqsw2Q53+/nSP29vcfNx4vbUDzX/A4g59tQN/swRKHsL22B85pzNdplNKzLUibU1HPd4vmQVB9ugm7c7nay6hzI+qjb+r5ubw5GYu9N25FHh1DQo3Hr7pdo6if0aUue+MxxvOxxuactNdXrMSjrzsqPDbpY4W2OaZH/W+a5S8VNqfl6L4/H+PUr1WQGqfFkZ+X2O3M1uOAPO7pnu/M8bxGtmnDc2+WsrSwoh9D6tgdVA+ZMpZTS4/7v0Q4tR73dU9/Sd7UaKK+Ge1xCxE15OMOPWe6PW8nw8MitZaflqi7U8tPjF45MR5jcPcrtIhslecVNqfWYwAnjuljUDZq1PyxhG42okdsr1e+zxuxyc3H2IeXeIx9LCe45NeOhz4/HruzQqsfkMdzZ31WomwC/DGCEr+kaXpaIr97TMtmV2R7jf46psuF6NMxLZsTK/cU8f20wBf7MrEv+9Md8X7q7Uo8MiYuIWM8v4SUvjuxNLbjcXSjxmNs9GONsbs363FvJkuFdvuXVPukgpV4dMs+z++adhfDuL95DHAv6Zs+Xtjr5rimx+h73KM8xrBpJSl/vLTX8v4+rfXdfbr9LdkW2Z2b8Rizbs9/yy5Bk5KgfSxb8rHF1k2EPsYpo8bjQYzW8o3fUkbctj1GgtPz37K7wkvcPj6GWdkfj0T5UKPtrvC2OMlsc48r41Lj43a0tL3185PsMRpWntfYbYe9pDVrrLexv9TYnKd1xHY8uo3H0xr7IyNHNLvH0ZWnR6a13V6NM+QxwripsTtTZaQ4y8rxvMbuTLVXQGaNXPprNWqtcbkfzxOk7RK1+u54dFlxbRgfz1M5drflnWet8bzE5jSV1MmgdjyvsTs9zk+U+oacH+R8XmVzoj56+/2wPHr7l9PjYwbJ9vE9xy7V2p+W2O2P3DT2R98cls1Jms7XFeMq9ejOfVple6pr3EU98Hlz2TbcUmKnpvIYoXtaRcbugtnpG0qPwYUn4a7H73p5eAwXx1bUNZY//xbNv+sl9zFiGWf7Y3Dy+WVKd3enhcf69TEyf+qh0PbuPt1uRU0RhbUeT7did0uWU41fkjQ9vSXTvnsgjqenoksfxeP25naNx+i8X/gfw+zH0xr9eP+mrqe3z7DtHo1Hl/Na9fwmd1cjF2psjkp/u+epv93z1N/uedrviR6t5NHv8nxP7B6gyogrbV0vLJ+uLH3sbghznOOl6/Ma2we5uCY8mtrzGmO3P0r0MefH4PXTGtt9KjVyQz78lm+coRL7NOuH7fhYY7x9ho63z9Dx+56hGheUPDbtfez6nw6lw6SsD8Yfk2tsztDzU0XR8976SzXOlSN8h8r6CPephq3T/m4M2wPF75jDthzxdVxUXjvL7bO5VzdU7k9r2FLubw4BHPL2GMChv+eJ/vizI54AS97sjLF9GI1n0fLhTNdvFBktLo9Hr8+LpN1pKiXGGx/c153yaUhiNxrQY4yoLxfq8ulmct9TedBTufSAy/3BlVpihzwucPJ8cGU30FSOaPwlfRjXkG8UyYf+9yfJ5yL69tCGrfr+3tjGvsStjvC0G226ObqRcnp3eCPtTrG74xv3j4pujsq2Fyl6XkreXWDy+yOi+f0h0fwDY6Lb3dEiDcv2ept3F36NE+T8ONjTUdF9kR6DmvqhwXwuUtL77XY7+nSv3b4/gJW2w083221pb7fb3aDL7XZ7+6hs2u3+9JA4x/p48RzrKUYIelk25JcidfeQ30q0O1ku2r+M4G/b3YiJBGXo5lK370q6d7bvxqFunu3bEvfO9treP9t3o1A3z/btINTds/32UXn1KjWiC+cx7CnPT492vH967Iahbp4e2xL3To/dINTd06PVt0+P3QjU7dPj9lF5+fSI9HicHv21G+V6pOjwPOruHNsk6s1pREl+4DyV989Tef88lR84T+X981R+4jyVHzhPt2fHDzxYavbHuao6nj9Y7kagJEdPjNSyue7vhqDGwWjpcqb/ctnf75DMDsn64k69NUcr6e5ErXRNPYain9eo7zdbbW83222Je81W9f1muxs+utlsdfxAs719VDbNdn92xPyVx9khr9Vo9JA1eX5h6GXXBcuE/iPVl2q0EXPytzX2v+XWlMbU5e0zfVvi3pne+/tn+m4g6uaZPo7dXI2YYN/yMm78y5m+HYi6M0FzvzfuzRK1Fd3f24rdzqj2MZp5hRtLS/l1Z9wu0l8r0o6Y/9KO7WHZFpE4tsc6Mel7RaJ7rD2GNl4skqLLoKXxvIitfv+8p/+IyY3pXHqMMqm/GiFPJwPn3YiU0gOim2eg/a3DnSnJ+ajvPzbsi5RI9sf9WN8U2c5wEmY46fNXGI73O/pthdr3on1f4t5bDOn9jv6c3u7oz+kHOvrvH5XNmwz7s4P90Z9f+Lc1Sj4YcHx+u/5VjePtGjXFVaYuI/zfqsEclEe55zXSePuGbFvj5g3ZF/tDJX7L6G/XaEd+cZ/Gw+lj/PP5sd29wPToQ44pllo3rW67IcptiI7nUbgbTrp7cHc1fuTgcpEqu4a76+h/DN4z43Sd5/2tncqI1GNw/vlZthv6qDEYXfPm2JbtJNwRswTq8fzWbr8dJa6366szv+yO7TU7hgprWUdgPl+zd0NSNzse8m5M6u41u+jb1+xtiXvX7N1LUXev2bvhqJvX7O0ko9svH8r71+z92XGr42Ff417HQ94NR92Nsf123Oo0yPX9s7T+wFl6+5c8z8HdqMetZ5d9/NR4manKMqnvl/hp+d2JG3k3FnVv4sYXPyUxWWr39LPdjnuzP/YbMkrnMTtvNkTf36f97X26LfEDu6Ox7kNLdbM7dsNI75/prcaFtrWxecKW/Xt7/JQo8ehf+FRiNwXl1vshef9SVvQ3LNPef92K3Wu/KZ5bal7vse+XOMdrlsVp2vFaEeZ8PljSi0W420/ryP53dmpM9259c2g1/a4l0qHclx49Pf0p+yI3j8y+yM0j80WRe0dm23Ilpga1sU4N+k7fmKT4NfLxPfdvFYn2/9imzc36bkAqOj6XCUr1G3kqNSaeSzte3R1FSxTR5zMU7TWdN69R/f3rfv+dL9nSYjtE0m537GKojRKd2m20pyd731z3ReLFvcfY/uZquRuCqZlboTyej8znvp+NH+M4R3n+6LEdQLn3oL4bkEr9YAGC/jjET4cKvjo4R+HgLLe632g1WuKeXR/dfc8Pzqjvd7DvXpC6+7A+3h473Ze49xg03h87zePtsdOyG5C6/bB++6hsHtb3Z8e9DvZdjbsd7F/UON6ucbODfVvjXgd72Q18LB0PbQx9qcbNfty727HtANnvU97WWldj+WUtqfT+/rhZ443fcm/A4W6N3YDD/hy7NeBQdkvp3R5w2G7IvQGHsnu76fbB7e+f7De34/UT5N6gRdm9I3V70GK7IfcGLUqu794Lld0bUncHLfbbcW/Q4qs73brc6T7rxSi7xfnu3i5vi9zsx9je57K0aVJ5fpL9wBtS5f03pMpPLPH3/htS5f03pMpPvCFVfuANqS+eguLpI68vBfxyZH9gcH77JHWz1e7Gxex19uvQ5vLS7sgpepZyWp7YP++O3ZtNN4Nwt0bf7SDcbse9XfpF/9ZydTmWOXXf6SR7/MVBkfw0CGt/v6dtW+RHeoVv7pFtkbt7pOUf2CO7Ivf2yBcTJlO8zJPyq/M/08GYUk7Pi2zf9uSC++hl1qfdQmW/yN6tuQal9fcvl7tZlzcvl9sS9y6Xu3Gpu5fL3Up9Ny+X21ek7l4ubx8V3RwVfXuuwb7GvbkGRX7gcV3ef1z/4rfcW7d594rUzTN9W+LemX7/lzy/EdrN174313ofYbEui65Pt79EmLb37/j1/elSRfX9A/v2RJSi70+XKv3t6VKl/8B0qftHZRNh27Pj5h3/bpG+u9Gx345b4y+ly9u32rsBqXt3yfutuFdiu6rmvWeXL2rce3YZb888LeMHZp7ut+PWLv1i2Y5YnK6nvvnqxnaNq1tv3m6/bHDzfnK8/75JGW+/b7IvcSuM6/H++yb1ePt9k3r8wPsm94/KJozT+7eT6e27yXq8P4l/W+PuJeEHegjfP73S29f6ul2j7/brf/e/ifL0Ql3Tu3ek2y+BaEw/edxlrcuEfv5+xnZ1PQY5y3pufKME7xF8WMj2cwl9t69juzNkxKBxP9pmZ2wf7O/MKqp5uwT/rUUxtyVufiSmv3tItp93iVX11lXkfvm8y66C8DmD/rzCdpgmuq/ONbqWGnK/Ro1xvEeN9rRG3X0OKo0cnxp78Hh6jr/dnbf/To1IrFjyGPRdEvCX79Qcb7f4bYl7Lb68vzt2FxRlhWNdM/hjhfruOb6tcOsc33426OY5vv/00M1zfNtQ7p7ju6GzHF3FHxaq/+W7QbsajaXEW9vU2H6fJsdDyoNl8+WgXZmbLWVb4l5L2Z1jPxAcn3bHeL47th9S4oZYyvoBo/JiDX2/xjLd5VsfdDok7hYO2XwEabvwm33HfO7V3sumyPYTufEkvMzq/F6JWDuuN32xRI2tWFaReLWElNd2aG58o2J9lv5mES4LktqLh3akeH4cm+Oye5+rSDytlHVZ0W99rKvEBeYR3uW1Gnzwq47+/Oje/njZpsbtD7Hp83Zb5d2Hpu1WKGvn92OTYrv1+LRFy9e2vjn9+TK3XWqgc2VYhxP0U43dwMhYFitaX/f7XKNvB7zju2MPXr6Q9/nX7PZqzyP26nrR/k6u93jueaA8r7G90rUaUwAeSbC50u0+CjXoIjjWjgb9eF+3HbNK7JHU+mY7dktHxnDASJuduiuxTIlYRxR+rbHrP7r3Jba6Gy26+Sm27W9JR3yoL63LWf36Y7azqniIGmMTAP14PwB6ej8Adq9B3Q2A3UtM9wNge2wKH2MrI792sn4sMp7f2m2/5shlJvfnd/77GvRVPh4CXqtRhMGF4/kXIWU7dh73VP21zzlWetMfD4n9pRqPvs6Y1p36848X1t3Qk0g8gjwwvVZES3TQaVmmZn2zSG9RZPQXi1Q+blBLebFIj/EBXW+av3VwakxXa+tLKt+qobFHWj/SizXiiar1vPnC5XZtvnLEC/sP3uyStv1cVGby/oMlbcrsbiZaYxZfk+N4eWt4JfqxNWNTZrsObG98c65rf3UX8y3jB7dXz5h13UF9rQaTDNpYPmb8ra/VHnHmSkqvbYekeHKVtGuF+e27m+1Hc6VFzD54ef/2W5/eFe5MHtxfrSL0BYoe+mIVzfyi9ZN+36wSQyoP3gT2vkqPcdQHp/Tqtix7t6fne7ft3k/6Rj7tRqvOfFrmHozxepmbMffFj7obc9t3ph733YmY2+3iL8rcTMsvjndbzj15+dyLZYkf3F5tTYOTRobUV6vwaW4ZOl6rojm+GXpye7UKn5HWxzPm8yq7CRI/8oFuZRSma0svVum8OtB7Ol6sMpZtGZtb5f3HwvlksG5GCrc1OhPf+nIN+F6NRseQPH8K2nfqDNpPWd/r+GVLyvbN0jvf/9yXuDVguC9xa8Twi6+vLy+XjOPZ6jhtt09HUrqWno5L7UvkWE1q5NxfGZcqjQ6dss6j+d437flwcCqanldpVd4d7NuXuDXY195/DeobuyO/vlNpc1pebLnnx9up0jY9Ke3tcdh9iXuHpv2+47Afd8duHPaLQ8NDsurxtMqui/telG0r3Jv7sL1JK2X5jPqmk6ztesnuTQTZlnikYeFD6lJfLKLL/cx6tn+vSAxQPbjLK+fZ+cXe2K+tPL/87z88I3Fn9eCRXqqSbYWlqyt1uYnIx3itxvJE8K0aLVYbfXQQp5dqFKaOlvWLUb/UeH9Zy12JeqQY0E1rZ0M+7tdI0dP+yLX6tEbbvVN1M5e3Je7l8u7dinu5vN0ZufBqxYeb5c87YzeFdcRz66PTVzZFdiuXsDTe8vjwqRfpi80QNmNZ4uubv4XFRj98pP6bRfhuTHt5r8YbK+2Q42mRvl+/ID5wUnY10ruXy22FW5fLvv1O7b2pgtsaN6cKtv4DUwW3C6e1eBzrLT9f/bmNt6ey7kvcC6Dx9lTW/c6QZQqXbnZGfXdn7JaNLzneIiplfccsjU+bsV3b784c+rZ7e+feHPp9iZufUj9+osb2YZ2Hsfzh40r6aRR4c1xGdCuNZf0F/fSpy/1bL/da7L6IZGVUIC9vnDyGZb9ThqUsH7xcXr5dJlOm5k2ZXS9GPIGsy0CVT3e4X20Jr1XKh/cqv/eDamW4pK6jAt8r05bd25Y3Iz+Xkd2rVj9UJh+8KHWsfZmfZ0Fsi7CM+6Pfub1YJEfG5qzPi2ybc+YzZ/kR+8+bc3p/rc4vatAUWypPr+P7IjdvKL7Yknt3FLIdg7qbT9uDUzlN2ujPD07ezqeICdntwxLX5XOR7cjGrVUeJJebZ8nzF4tlt97evbc29yVuvVgsu29I3XzzU3ZvYN1781N26/XdfbH4/lHZtN3t2XFvlQcp76+B+sV23FrlQcrbC6rJbtm/+6ts77fk1rIE2x1yc6WHL2rcWulBSn9/p+4C9eZKD/vtuLfSwxc3NcvsjbpMHv7lNuL9N7Hk/TexpNbftcTNRd2+2KVMT3/s3vZ0l+4e024+3OyeWh893DGRUtLzz9psn3yZfNVLri8++d47LrsXXG4el+3aFxILkvS1k+jzT0nH28My+xK3Opq2P+XujeG+yN0bw/YDb15v1/lv0TOb16nHnw+MtPeX6pXt2M7NW7rdbMWbt3TbEvdu6eT9xTxk9zWqm7d0u/ewbt/S3T4qm1u69v5SvSLvr1r+xXbcu6XTtz+cIvojH07Zb8m9W7r2/sLDX9S4d0u3HaS6uVPlB27ptttx75Zue33RmHLd24uXqJhFK/35VKz+/u3Lbj3pkmNJ2kfH9zoC0e/X0Lhel/Fh1Zn7NeoRNeqxTpH53FT6253/+82IG/Watpvx/iKIX9S42bW1/0zAza6t/ZbcvIMZxw/cwWxvpRqzU5I+PTa7GpkZLllEXqvRYoJLFq3Pz5FR3x0gkt3Xju4NEO1L3Hz+2e7RZY7tIZu98QOfopCxfak9jm05PgzcfdwS3b0ZdPfLbbq96b93A6K7q8O9a6Ue5UduQL44OLe+3Fa2nzvt8WS53j18XphMj+107lsfbtPj/ZUq9Xh7pcp9iVtPH5reX6lS09srVWr6gZUq7x8V3RyV7dlx68Nt2xo3P9z2VY3j7Rr3Pty2r3Hvw22a7n04Zfctq22Nm2t33t2ObY39Pr314TbdDXzc3R83a7zxW259uO12jc2H2744x259uE23n6G6+eG2/Ybc+3Cb7tbzu3twdzXunuw3t+P1E+Teh9t0OyR188Nt+w259+E2LW8voq5F3+822G/HvZ6Yr25073y4Tevx/t3ytsjNCcPb29x7vcFa3x/g1/r2AP++xL37sfr+AL/Wtwf4tf7AAP/9o7K7H0tv9wZrSz8QhfndVrv9KTf7T7+ocav/VNvb/afafqD/dL8dt3bpdh74re7TfYU7vaf7l2HimfSByzpL33mhRngpR0Z5rUaPBQzy2n36vZdyuBE78vPf0nS7Hui9N3u2RR7HMwZvuz59LXdbYkRzk5H1tRIMIa9fWpP7R0XjQp11XWbtO0f2Q436Yo1MjbI5wzS92zG+L3FreoG+/5rTtsTNu5bt/pT/9j3J7x2Tpc9zvJgc63a8WoPblnOJgRdr1HyrxtuDYfr2WNgXb+LHYMfI+cWX+WPp3Qc+fXN1u7LBrV3xRYlb+2K73gRLCH+4Jf7WmhWJJWI378/va8T9bF7X7vteDdpJH89f8/5iTZLKaiK9bZa3ul9ltzbVF1UqVfT5qjE6dr1I91Yj1d0Y1N31uvbrtGSW/x6b1Qi/2Cc8bzwO8strxqzbUl6uwhN6H/XFFYYeXYC8wJ5rebWKLGsDvbxOEa9+PjjnV6vUpUp7dbWjUtYq8mqVpc+w9Jf3iy5VxvFilbqsAlXzq0e6HmuVl886lo59POA/P0Z9+7peXd5Nq7sT5qsyLCfx2Jjnazj17Uzf24uYfbU18WDy4M0Sh9/5UW+UURanWJcK/nXftP8X+2bpFViXIHnjR71RpiaW3NitK9u3b1P91L7h+4gPru1HflR9NT6Pgzkw6yfVv7n83TiWKs9Pvi9W/401xB84XiwiienzWV8s0mJykbbx6s/R6DjV/vLazOvPeb0I33cQfXVtZo353o/n+vrqlsQSGI8i7dUtaXyuotUfODppEwnlR1YP/mLF6iR3zpT9wuiFxdXbZmGx7Yem4jMPeZ27+fkjUX37kbx7cybf/85er8fvWuLmymS7/VlYHano849u9d3Qya3Fa7ZbUelcWsf2f92K9vbjYd9tyN2PVWw/Y5b5QmhuT3/Lvsb6/djn+6PW7ZzNm99T2xW517W9L3Gra/uLEne6trff67vVR7WvcKeLavtdzFvbsK9wZxt28yx4cGsfntv6cbtEi76C1uqLJaKf7VEtvVLiMbTI8OR6cuf2jRIxypCWofxvlWAoLC9rBnynBP2vj2tbfqkEs4k+Dsh9o4TG5f0x4vLa7szxHYhHV/RrJUpMun3slfTaVjCwWI6XdmeLtevba3uiDT4r0F4pkI7MZ6jktRKJDz+uSwV+q4TwdaD+2laUZS3Z8dpWLCsFt6qvlRBmdvTx2g9hge914aJvlaAPvLTXfogInzLQ17ZCld6y8VL7SKxKlUZ+qYTG+Nv6cYhvFBhx1zraS/thxLSStQP/OwWicQxtb/6E1wo87ulimcW2fqnjOxfi3LgQHy+VqHFCtbp+deR+iQ8TOdab7na/ROJ1vLyu9PipRN8+48ZJyc6s5f4ltC/flxyv/IqkbVkBeH2p8NMcod37TVljdfas+dlky337jtAeH1au+0bK9Lh0rNOKf/0h21dO7rwu1nevR917XWxf4t7rYtubxM536ZYXGz7vjHHsP0jCURF9vtjkF0XK+lWT8rTIdgoZEwPb2ovzy8/ZdeIvn/z8uFs/LWSym2fd+TzdY8RAN0X2c0GWN+jK5ufspi+kwi3fMnc0HekbRSS6tkTWJeK/VaRHin142P6lSHp7nuEX2yHLQ3/fbMdu5hPfIamP3jgO8C9vru46QCUvq0UuKSDf2a18GPYxeLA5Nmn3XsBR+Pb4cpbUTy8EjrRbmzTF9OCRlg8y/1pkNyW/tOVbcGNZ4f3XXbvdlujqGrlttiUfP9CKt7s2xzSID9f/X7dk+9m/Hl/uTG2MtilTfiKW+vYOOUYh+pqyn0+4vEtZe5nS7yeWIu3Tu867Rfzawf3dsSmhP3Di796Zun3i5/EjJ/72B9093Ur6kdOt5B843fJ27WbeBSnPD3LZTy2Pnhc9NmuTlfZ7/xgmhBxLL9Kvv2b7Fe/KTVvqm1/Tf+LXtO31Kx63tW9+znas6YhnxUdPxq5I+oEjXH/idN3+nBQjoyUvnUK//pz6A4e4tt877AdfN16/7/dL2O/eo6q8hlmP5c7vlzDZvUmVamZSzPJW2Pj0gFB3S+Ok6I5+HKfl/rF/KtL2fQLxXsbaf/kYr/1UJP3EubZdLYjeibJcd379OeX33pKaeJt76Wr5dUt2o6RH4uMca9ORb5xqtJzHbYo8P9V2swF+5OntcW6w8MCxebbeLvN1N9fk+L1/Ti7k2roSy+efI/kHck1+4oTd3pV3YnqdVZzSp0a8W+rvO88qu23htcqa1m9a/rItP3HObm8eb++V/wc3snf3iv5IzOpu1C36tx6d0rLZkvL+5Wv7WuHdy9dutb3bly/9if6t7c+5e/nS/ntvyd3L1+4zRj9x+WoSSw+3D487n0+1/gP3sbvZWxpfQnoMooxXOtqrxJcPqtbnHe2jt3c72sd2VcZbHe3jBxZ2/KqDe/lU9vMPMY7deoi3e8m3iyre+zTUto98ZMZh2st95JGIPa0Tlr9XJGYu9Zw2W7J780pHPILqWF9H+6XILldbjsvV82HbfVcuHVrSlq8qfa8rlzdIy5D06t3EzWOzL3Lv2KRjtwTg3YPzqJJ+16Oj0peJ089HUh4bsn3rOo5OXT8a/rnE5nRtzIhqHz61+2k494tbvZunyf726uZpsi9y+zTpP3KajLdPk22ndFwsPnzvp33+QNtulKsyC7yW/HzAft/rSe9clppe7fW8eYT3Re4e4d3bVfeP8DYe3z/CvNc6lvcu/5sjvFtYPcU6Ei2tCz3/coR3d4uJcy1/6E4+vtMTfPcI9584wrtRrvtHeDfIdfMI7zpxM/PI8jqL69djnLfrA9Voxcf6PePPh2fbs323Fe97tm8e432R28d4/MQx3i3K9wPHuKSY6V0e99KbY7wb4qo97upr721zjOsPtOP6E0ldfySpdyvzfeMY69vHeNvpUgqTfJcBqvH5kzG7NxtqzMVfv2uUpH+jRoul+Zq8XCNej2/L0gPfrDHiZZWj/ECN/mINif0hL+8Pif0hL+8Pid+iL++Ptcar+4OlG/Xl/aGxP/Tl/aHxW/rL+2Ot8er+4NWuLq9uR4/3oddXS79ZI/rDx8v7Y63x6naMiOWxyaAv+n2F2YTr2iXl8+Nr275cGm8Plw9rdHyvSo1ztbSjv1qFFQOLrGvdfK+KRh/juUzvf73YH373QfgH+rLSIT/QmZUOeb83a9upzneJy/oZvW9279/dsT/ydCI/cueqx++7Y2vc1TxGK9LTHZuO3RpvJcWoVlk/YP3LlwG3N1hLp/aHK5d+LrJ7fXX5vmB5sURnWnB/tcTx390K6P0BoDqi16Z9+GjSL3t0931Tbq+qrLMaXy9Sng5F3R8Tk81Z1rfLBfFuQC39+c/ZDWjJUVl3eGz2Sd+dqolh3AevE1ffKfN8nG8/Gnz0O6PB27HCGjcWrdXnA+SP37Nbij0dvI25rinyy0W07064GA+q6yU0H59rbCdnkWp5V2O3HSnSdV0q7pcau08o3c/53Rtbd3sodge4aeSJrL3Avxzg7YdoG5/6Kc+fgPdDW/9dibPT5Btj0jev4/1HeqDGj4wUjPdHCvbvKMQk65GPzbTI/TsKN3fsvsjNHZt2Q1u3d2zaTjS72UG/fVtiGZ9+XArTZteWn9i15Ud2bf+RXfsDo1v9J87ZbZF7L+c8gu4Hprl8VeXeQf6qyt2j/CMjXOkHRrj273/cbkDlJ0K//MiuzT8xiyDl92cRbKex3+ySTrtQudklva1xs0t6X+Nel/S+xr0u6ds1+os1bnZJ72vc65Le17jXJX27xqv742aX9L7GvS7pfY17XdK3a7y6P252Se9r3OuS3te41yV9u8ar23GzS3r/Js3NLum0G5e+3SW9r3K3S3pf5W6X9L7K3S7p9hNzs9pPzM1K9UfuXuv7d6/bEne7pNtPPBa0H3ksaD/yxNXq77tj73ZJp93HJe52Safdy1t3u6TTblDoXpf0vsStLukvStzpkt5+Guxml3TavbV1t0v6G0Wed0nff8tw0yWdtm9t3eySTrvvUtztkk6iP9El/a0ym1dP+u/bJV2P6B14VMubB/vdhODbXdJpN751s0s6bT+Rda9Ler8d97qkk/5Ix4C+3zGwf72Wbx6mIrsDvB+4v9ElbYtqvNkl3X7iHYf2E+84pP4TE19Tf3/i6+0lp+rzJafOVTc3Dbgv3+xZXjH89O3V/ZvPd+e9yk90jsuPdI73n5g9kMb7swd2F+Lbk03lJ+6B5UfugX/i5a1Hlfa7tp3Cd53K+nmdX5drq7srKPOJD8mbBrgb4vqZKvcWWP+ixq0V1r+qcWeJ9f1y2vHRurQcmU959LiNKrtojHWVjqcldhtx74PUj43Yzc++9UXqR43dJ9UGH5Z98Low6qf383cvO8cnqdqH79u2Fwp8+Jzr7QISt6trR8t3CizPeOmlArHOrnz4EML9ArdW3d8WeHPR/XvvAu+WU62xSsOj82YZhPv04ZTtGtgpHthbqS+V0OVjePW1reiyfPNQXiox4o2SNNY1Ib9RQlhmV/S1HyKDZbSP137IsSxT1l/bihyv3ae8vnf/jRKFry3W5eMt39qKeAMrZXnth7DwfypJ3t0XL5dogx+yBG76zlYoRyS/X0JeKlFiCegH9tdKCCOoyxoZ3ymxRk59bV8UvpFa18/Ev1ritYO6riqzfK7kWyVYub+KvFiCH7J+X+M7JeIG/DGU8NpBrdHD+HiWOV48L/gcQ37poNb45uKHHsr7BTg1W36+Hx7JVre5V4mL5Ubx/v1d5WM8+tLP0Li7qi8di9aY/FhfKhALvbdRXisQsxtGfa/AOrXhWzuRTuaXslKi83FdX/q1Lfh8GP/n4//+8V///Pd//svf/vWP//jz3/7674+/919nqb//+Y//8pc/Xf/3f//HX/91+a//+P//zf/Lv/z9z3/5y5//zz//29//9q9/+l//8fc/nZXO//bbcf3P/+jnDJPeRvqf//Rbevz/x2BH/qfHM+Dx+P/F/vtjPKk3kfO/n39Bzq9IPf5nnP/i/Bv9/GTA43/G//yvc5P/Lw==",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n        offchain_messages::emit_offchain_message,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n    utils::{array::subarray::subarray, remove_constraints::remove_constraints},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash,\n    address::AztecAddress,\n    constants::{PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_SIZE_IN_FIELDS},\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note_unconstrained`, except the note is emitted as an offchain message instead of a\n/// private log.\n///\n/// Like `encode_and_encrypt_note_unconstrained`, this function uses unconstrained encryption. The sender can set any\n/// message contents, potentially preventing recipient decryption and resulting in note loss. Since offchain messages\n/// inherently lack delivery guarantees, constrained encryption provides no benefit and is not offered.\n///\n/// While delivery is not guaranteed, message integrity is still protected via cryptographic commitments in the note\n/// hash tree. For guaranteed delivery, use `encode_and_encrypt_note` with private logs instead. See\n/// `messages::offchain_message::emit_offchain_message` for more details on delivery guarantees.\npub fn encode_and_encrypt_note_and_emit_as_offchain_message<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n\n        // Remove the tag from the log\n        // TODO: This is a tech debt. We should refactor this file such that the log is by default computed without\n        // the tag.\n        let message_ciphertext: [_; PRIVATE_LOG_CIPHERTEXT_LEN] = subarray(encrypted_log, 1);\n\n        emit_offchain_message(message_ciphertext, recipient);\n    }\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let note_nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = (packed_retrieved_note[2] as u1) != 0;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, note_nonce),\n    }\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u64, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u64, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u64)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u64\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u64, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_timestamp) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical timestamp (timestamp of\n        // the historical block against which we are executing the private part of the tx) as this one also takes into\n        // consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by scheduling\n        // immediately after the historical timestamp, i.e. at timestamp `x + 1`. But if there was a delay change scheduled\n        // for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value change was scheduled at\n        // timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier than what we'd expect if we\n        // only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_timestamp);\n        let timestamp_horizon =\n            value_change.get_timestamp_horizon(historical_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the timestamp horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(timestamp_horizon);\n\n        value_change.get_current_at(historical_timestamp)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u64)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_timestamp = header.global_variables.timestamp;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_timestamp)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        smv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "205": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "206": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "208": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "209": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "218": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "225": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "243": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "286": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "303": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "305": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "318": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "320": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "321": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in\n    /// private with historical timestamps. This function can be used alongside\n    /// `ScheduledValueChange.get_timestamp_horizon` to properly constrain the `include_by_timestamp` transaction\n    /// property when reading mutable shared state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'timestamp horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the historical timestamp that is used to construct the proof).\n    /// Reading in private is only safe if the transaction's `include_by_timestamp` property is set to a value lower or\n    /// equal to the timestamp horizon (see `get_timestamp_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_timestamp`\n    /// (timestamp of a historical block at which we are constructing a proof), since due to its asynchronous nature\n    /// private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the timestamp horizon\n    /// computed using the same historical timestamp.\n    pub fn get_timestamp_horizon(self, historical_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The timestamp horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the timestamp horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the timestamp horizon.\n        if historical_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the historical timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the historical timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `historical_timestamp + 1 +\n            // minimum_delay`. Our timestamp horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    historical\n            //      change       timestamp          timestamp horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the timestamp horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         historical\n            //         timestamp                      timestamp horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the historical timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           historical                         timestamp horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because historical_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                historical_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "339": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "356": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "380": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "381": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "393": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 180, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock_high: u128, hashlock_low: u128, timelock: u64) {\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[private]\n    fn redeem_private(\n        Id: Field,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_key_high: u128,\n        ownership_key_low: u128,\n    ) {\n        let secret = u128_limbs_to_bytes(secret_high, secret_low);\n        let ownership_key = u128_limbs_to_bytes(ownership_key_high, ownership_key_low);\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[utility]\n    unconstrained fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenCommitted {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<5> for TokenLockAdded {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable<2> for TokenRefunded {\n    fn pack(self) -> [Field; 2] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; 2]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<6> for TokenRedeemed {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenLockedFirst {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable<6> for TokenLockedSecond {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
